/*!
 * PixiJS - v8.0.0-rc
 * Compiled Thu, 07 Dec 2023 11:23:38 UTC
 *
 * PixiJS is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var PIXI=function(exports){"use strict";class Point{constructor(X=0,K=0){this.x=0,this.y=0,this.x=X,this.y=K}clone(){return new Point(this.x,this.y)}copyFrom(X){return this.set(X.x,X.y),this}copyTo(X){return X.set(this.x,this.y),X}equals(X){return X.x===this.x&&X.y===this.y}set(X=0,K=X){return this.x=X,this.y=K,this}static get shared(){return e$c.x=0,e$c.y=0,e$c}}const e$c=new Point;class FederatedEvent{constructor(X){this.bubbles=!0,this.cancelBubble=!0,this.cancelable=!1,this.composed=!1,this.defaultPrevented=!1,this.eventPhase=FederatedEvent.prototype.NONE,this.propagationStopped=!1,this.propagationImmediatelyStopped=!1,this.layer=new Point,this.page=new Point,this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.manager=X}get layerX(){return this.layer.x}get layerY(){return this.layer.y}get pageX(){return this.page.x}get pageY(){return this.page.y}get data(){return this}composedPath(){return this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)&&(this.path=this.target?this.manager.propagationPath(this.target):[]),this.path}initEvent(X,K,J){throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}initUIEvent(X,K,J,Q,ee){throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}preventDefault(){this.nativeEvent instanceof Event&&this.nativeEvent.cancelable&&this.nativeEvent.preventDefault(),this.defaultPrevented=!0}stopImmediatePropagation(){this.propagationImmediatelyStopped=!0}stopPropagation(){this.propagationStopped=!0}}var f$y=Object.defineProperty,h$w=Object.defineProperties,E$7=Object.getOwnPropertyDescriptors,c$B=Object.getOwnPropertySymbols,y$o=Object.prototype.hasOwnProperty,v$9=Object.prototype.propertyIsEnumerable,m$C=(Z,X,K)=>X in Z?f$y(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,d$x=(Z,X)=>{for(var K in X||(X={}))y$o.call(X,K)&&m$C(Z,K,X[K]);if(c$B)for(var K of c$B(X))v$9.call(X,K)&&m$C(Z,K,X[K]);return Z},l$w=(Z,X)=>h$w(Z,E$7(X)),u$z=(Z=>(Z.Application="application",Z.WebGLPipes="webgl-pipes",Z.WebGLPipesAdaptor="webgl-pipes-adaptor",Z.WebGLSystem="webgl-system",Z.WebGPUPipes="webgpu-pipes",Z.WebGPUPipesAdaptor="webgpu-pipes-adaptor",Z.WebGPUSystem="webgpu-system",Z.CanvasSystem="canvas-system",Z.CanvasPipesAdaptor="canvas-pipes-adaptor",Z.CanvasPipes="canvas-pipes",Z.Asset="asset",Z.LoadParser="load-parser",Z.ResolveParser="resolve-parser",Z.CacheParser="cache-parser",Z.DetectionParser="detection-parser",Z.MaskEffect="mask-effect",Z.BlendMode="blend-mode",Z.TextureSource="texture-source",Z.Environment="environment",Z))(u$z||{});const p$L=Z=>{if(typeof Z=="function"||typeof Z=="object"&&Z.extension){const X=typeof Z.extension!="object"?{type:Z.extension}:Z.extension;Z=l$w(d$x({},X),{ref:Z})}if(typeof Z=="object")Z=d$x({},Z);else throw new Error("Invalid extension type");return typeof Z.type=="string"&&(Z.type=[Z.type]),Z},normalizeExtensionPriority=(Z,X)=>{var K;return(K=p$L(Z).priority)!=null?K:X},b$r={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...Z){return Z.map(p$L).forEach(X=>{X.type.forEach(K=>{var J,Q;return(Q=(J=this._removeHandlers)[K])==null?void 0:Q.call(J,X)})}),this},add(...Z){return Z.map(p$L).forEach(X=>{X.type.forEach(K=>{const J=this._addHandlers,Q=this._queue;J[K]?J[K](X):(Q[K]=Q[K]||[],Q[K].push(X))})}),this},handle(Z,X,K){const J=this._addHandlers,Q=this._removeHandlers;J[Z]=X,Q[Z]=K;const ee=this._queue;return ee[Z]&&(ee[Z].forEach(te=>X(te)),delete ee[Z]),this},handleByMap(Z,X){return this.handle(Z,K=>{X[K.name]=K.ref},K=>{delete X[K.name]})},handleByNamedList(Z,X,K=-1){return this.handle(Z,J=>{X.findIndex(Q=>Q.name===J.name)>=0||(X.push({name:J.name,value:J.ref}),X.sort((Q,ee)=>normalizeExtensionPriority(ee.value,K)-normalizeExtensionPriority(Q.value,K)))},J=>{const Q=X.findIndex(ee=>ee.name===J.name);Q!==-1&&X.splice(Q,1)})},handleByList(Z,X,K=-1){return this.handle(Z,J=>{X.includes(J.ref)||(X.push(J.ref),X.sort((Q,ee)=>normalizeExtensionPriority(ee,K)-normalizeExtensionPriority(Q,K)))},J=>{const Q=X.indexOf(J.ref);Q!==-1&&X.splice(Q,1)})}};var appleIphone=/iPhone/i,appleIpod=/iPod/i,appleTablet=/iPad/i,appleUniversal=/\biOS-universal(?:.+)Mac\b/i,androidPhone=/\bAndroid(?:.+)Mobile\b/i,androidTablet=/Android/i,amazonPhone=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,amazonTablet=/Silk/i,windowsPhone=/Windows Phone/i,windowsTablet=/\bWindows(?:.+)ARM\b/i,otherBlackBerry=/BlackBerry/i,otherBlackBerry10=/BB10/i,otherOpera=/Opera Mini/i,otherChrome=/\b(CriOS|Chrome)(?:.+)Mobile/i,otherFirefox=/Mobile(?:.+)Firefox\b/i,isAppleTabletOnIos13=function(Z){return typeof Z!="undefined"&&Z.platform==="MacIntel"&&typeof Z.maxTouchPoints=="number"&&Z.maxTouchPoints>1&&typeof MSStream=="undefined"};function createMatch(Z){return function(X){return X.test(Z)}}function isMobile$1(Z){var X={userAgent:"",platform:"",maxTouchPoints:0};!Z&&typeof navigator!="undefined"?X={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0}:typeof Z=="string"?X.userAgent=Z:Z&&Z.userAgent&&(X={userAgent:Z.userAgent,platform:Z.platform,maxTouchPoints:Z.maxTouchPoints||0});var K=X.userAgent,J=K.split("[FBAN");typeof J[1]!="undefined"&&(K=J[0]),J=K.split("Twitter"),typeof J[1]!="undefined"&&(K=J[0]);var Q=createMatch(K),ee={apple:{phone:Q(appleIphone)&&!Q(windowsPhone),ipod:Q(appleIpod),tablet:!Q(appleIphone)&&(Q(appleTablet)||isAppleTabletOnIos13(X))&&!Q(windowsPhone),universal:Q(appleUniversal),device:(Q(appleIphone)||Q(appleIpod)||Q(appleTablet)||Q(appleUniversal)||isAppleTabletOnIos13(X))&&!Q(windowsPhone)},amazon:{phone:Q(amazonPhone),tablet:!Q(amazonPhone)&&Q(amazonTablet),device:Q(amazonPhone)||Q(amazonTablet)},android:{phone:!Q(windowsPhone)&&Q(amazonPhone)||!Q(windowsPhone)&&Q(androidPhone),tablet:!Q(windowsPhone)&&!Q(amazonPhone)&&!Q(androidPhone)&&(Q(amazonTablet)||Q(androidTablet)),device:!Q(windowsPhone)&&(Q(amazonPhone)||Q(amazonTablet)||Q(androidPhone)||Q(androidTablet))||Q(/\bokhttp\b/i)},windows:{phone:Q(windowsPhone),tablet:Q(windowsTablet),device:Q(windowsPhone)||Q(windowsTablet)},other:{blackberry:Q(otherBlackBerry),blackberry10:Q(otherBlackBerry10),opera:Q(otherOpera),firefox:Q(otherFirefox),chrome:Q(otherChrome),device:Q(otherBlackBerry)||Q(otherBlackBerry10)||Q(otherOpera)||Q(otherFirefox)||Q(otherChrome)},any:!1,phone:!1,tablet:!1};return ee.any=ee.apple.device||ee.android.device||ee.windows.device||ee.other.device,ee.phone=ee.apple.phone||ee.android.phone||ee.windows.phone,ee.tablet=ee.apple.tablet||ee.android.tablet||ee.windows.tablet,ee}var e$b;const l$v=(e$b=isMobile$1.default)!=null?e$b:isMobile$1,isMobile=l$v(globalThis.navigator);function removeItems(Z,X,K){const J=Z.length;let Q;if(X>=J||K===0)return;K=X+K>J?J-X:K;const ee=J-K;for(Q=X;Q<ee;++Q)Z[Q]=Z[Q+K];Z.length=ee}const T$c=9,v$8=100,w$9=0,D$2=0,y$n=2,m$B=1,H$7=-1e3,I$9=-1e3,M$b=2;class AccessibilitySystem{constructor(X,K=isMobile){this._mobileInfo=K,this.debug=!1,this._isActive=!1,this._isMobileAccessibility=!1,this._pool=[],this._renderId=0,this._children=[],this._androidUpdateCount=0,this._androidUpdateFrequency=500,this._hookDiv=null,(K.tablet||K.phone)&&this._createTouchHook();const J=document.createElement("div");J.style.width=`${v$8}px`,J.style.height=`${v$8}px`,J.style.position="absolute",J.style.top=`${w$9}px`,J.style.left=`${D$2}px`,J.style.zIndex=y$n.toString(),this._div=J,this._renderer=X,this._onKeyDown=this._onKeyDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)}get isActive(){return this._isActive}get isMobileAccessibility(){return this._isMobileAccessibility}get hookDiv(){return this._hookDiv}_createTouchHook(){const X=document.createElement("button");X.style.width=`${m$B}px`,X.style.height=`${m$B}px`,X.style.position="absolute",X.style.top=`${H$7}px`,X.style.left=`${I$9}px`,X.style.zIndex=M$b.toString(),X.style.backgroundColor="#FF0000",X.title="select to enable accessibility for this content",X.addEventListener("focus",()=>{this._isMobileAccessibility=!0,this._activate(),this._destroyTouchHook()}),document.body.appendChild(X),this._hookDiv=X}_destroyTouchHook(){this._hookDiv&&(document.body.removeChild(this._hookDiv),this._hookDiv=null)}_activate(){var X;this._isActive||(this._isActive=!0,globalThis.document.addEventListener("mousemove",this._onMouseMove,!0),globalThis.removeEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.add(this),(X=this._renderer.view.canvas.parentNode)==null||X.appendChild(this._div))}_deactivate(){var X;!this._isActive||this._isMobileAccessibility||(this._isActive=!1,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),globalThis.addEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.remove(this),(X=this._div.parentNode)==null||X.removeChild(this._div))}_updateAccessibleObjects(X){if(!X.visible||!X.accessibleChildren)return;X.accessible&&X.isInteractive()&&(X._accessibleActive||this._addChild(X),X._renderId=this._renderId);const K=X.children;if(K)for(let J=0;J<K.length;J++)this._updateAccessibleObjects(K[J])}init(X){var K;this.debug=(K=X==null?void 0:X.debug)!=null?K:this.debug,this._renderer.runners.postrender.remove(this)}postrender(){const X=performance.now();if(this._mobileInfo.android.device&&X<this._androidUpdateCount||(this._androidUpdateCount=X+this._androidUpdateFrequency,!this._renderer.renderingToScreen||!this._renderer.view.canvas))return;this._renderer.lastObjectRendered&&this._updateAccessibleObjects(this._renderer.lastObjectRendered);const{x:K,y:J,width:Q,height:ee}=this._renderer.view.canvas.getBoundingClientRect(),{width:te,height:re,resolution:ne}=this._renderer,ie=Q/te*ne,se=ee/re*ne;let oe=this._div;oe.style.left=`${K}px`,oe.style.top=`${J}px`,oe.style.width=`${te}px`,oe.style.height=`${re}px`;for(let ae=0;ae<this._children.length;ae++){const le=this._children[ae];if(le._renderId!==this._renderId)le._accessibleActive=!1,removeItems(this._children,ae,1),this._div.removeChild(le._accessibleDiv),this._pool.push(le._accessibleDiv),le._accessibleDiv=null,ae--;else{oe=le._accessibleDiv;let ce=le.hitArea;const de=le.worldTransform;le.hitArea?(oe.style.left=`${(de.tx+ce.x*de.a)*ie}px`,oe.style.top=`${(de.ty+ce.y*de.d)*se}px`,oe.style.width=`${ce.width*de.a*ie}px`,oe.style.height=`${ce.height*de.d*se}px`):(ce=le.getBounds(),this._capHitArea(ce),oe.style.left=`${ce.x*ie}px`,oe.style.top=`${ce.y*se}px`,oe.style.width=`${ce.width*ie}px`,oe.style.height=`${ce.height*se}px`,oe.title!==le.accessibleTitle&&le.accessibleTitle!==null&&(oe.title=le.accessibleTitle),oe.getAttribute("aria-label")!==le.accessibleHint&&le.accessibleHint!==null&&oe.setAttribute("aria-label",le.accessibleHint)),(le.accessibleTitle!==oe.title||le.tabIndex!==oe.tabIndex)&&(oe.title=le.accessibleTitle,oe.tabIndex=le.tabIndex,this.debug&&this._updateDebugHTML(oe))}}this._renderId++}_updateDebugHTML(X){X.innerHTML=`type: ${X.type}</br> title : ${X.title}</br> tabIndex: ${X.tabIndex}`}_capHitArea(X){X.x<0&&(X.width+=X.x,X.x=0),X.y<0&&(X.height+=X.y,X.y=0);const{width:K,height:J}=this._renderer;X.x+X.width>K&&(X.width=K-X.x),X.y+X.height>J&&(X.height=J-X.y)}_addChild(X){let K=this._pool.pop();K||(K=document.createElement("button"),K.style.width=`${v$8}px`,K.style.height=`${v$8}px`,K.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",K.style.position="absolute",K.style.zIndex=y$n.toString(),K.style.borderStyle="none",navigator.userAgent.toLowerCase().includes("chrome")?K.setAttribute("aria-live","off"):K.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?K.setAttribute("aria-relevant","additions"):K.setAttribute("aria-relevant","text"),K.addEventListener("click",this._onClick.bind(this)),K.addEventListener("focus",this._onFocus.bind(this)),K.addEventListener("focusout",this._onFocusOut.bind(this))),K.style.pointerEvents=X.accessiblePointerEvents,K.type=X.accessibleType,X.accessibleTitle&&X.accessibleTitle!==null?K.title=X.accessibleTitle:(!X.accessibleHint||X.accessibleHint===null)&&(K.title=`container ${X.tabIndex}`),X.accessibleHint&&X.accessibleHint!==null&&K.setAttribute("aria-label",X.accessibleHint),this.debug&&this._updateDebugHTML(K),X._accessibleActive=!0,X._accessibleDiv=K,K.container=X,this._children.push(X),this._div.appendChild(X._accessibleDiv),X._accessibleDiv.tabIndex=X.tabIndex}_dispatchEvent(X,K){const{container:J}=X.target,Q=this._renderer.events.rootBoundary,ee=Object.assign(new FederatedEvent(Q),{target:J});Q.rootTarget=this._renderer.lastObjectRendered,K.forEach(te=>Q.dispatchEvent(ee,te))}_onClick(X){this._dispatchEvent(X,["click","pointertap","tap"])}_onFocus(X){X.target.getAttribute("aria-live")||X.target.setAttribute("aria-live","assertive"),this._dispatchEvent(X,["mouseover"])}_onFocusOut(X){X.target.getAttribute("aria-live")||X.target.setAttribute("aria-live","polite"),this._dispatchEvent(X,["mouseout"])}_onKeyDown(X){X.keyCode===T$c&&this._activate()}_onMouseMove(X){X.movementX===0&&X.movementY===0||this._deactivate()}destroy(){this._destroyTouchHook(),this._div=null,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),globalThis.removeEventListener("keydown",this._onKeyDown),this._pool=null,this._children=null,this._renderer=null}}AccessibilitySystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem],name:"accessibility"},b$r.add(AccessibilitySystem);const accessibilityTarget={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,_accessibleActive:!1,_accessibleDiv:null,accessibleType:"button",accessiblePointerEvents:"auto",accessibleChildren:!0,_renderId:-1};var commonjsGlobal=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function getDefaultExportFromCjs(Z){return Z&&Z.__esModule&&Object.prototype.hasOwnProperty.call(Z,"default")?Z.default:Z}function createCommonjsModule(Z,X,K){return K={path:X,exports:{},require:function(J,Q){return commonjsRequire(J,Q==null?K.path:Q)}},Z(K,K.exports),K.exports}function getDefaultExportFromNamespaceIfPresent(Z){return Z&&Object.prototype.hasOwnProperty.call(Z,"default")?Z.default:Z}function getDefaultExportFromNamespaceIfNotNamed(Z){return Z&&Object.prototype.hasOwnProperty.call(Z,"default")&&Object.keys(Z).length===1?Z.default:Z}function getAugmentedNamespace(Z){if(Z.__esModule)return Z;var X=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(Z).forEach(function(K){var J=Object.getOwnPropertyDescriptor(Z,K);Object.defineProperty(X,K,J.get?J:{enumerable:!0,get:function(){return Z[K]}})}),X}function commonjsRequire(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var eventemitter3=createCommonjsModule(function(Z){"use strict";var X=Object.prototype.hasOwnProperty,K="~";function J(){}Object.create&&(J.prototype=Object.create(null),new J().__proto__||(K=!1));function Q(ne,ie,se){this.fn=ne,this.context=ie,this.once=se||!1}function ee(ne,ie,se,oe,ae){if(typeof se!="function")throw new TypeError("The listener must be a function");var le=new Q(se,oe||ne,ae),ce=K?K+ie:ie;return ne._events[ce]?ne._events[ce].fn?ne._events[ce]=[ne._events[ce],le]:ne._events[ce].push(le):(ne._events[ce]=le,ne._eventsCount++),ne}function te(ne,ie){--ne._eventsCount===0?ne._events=new J:delete ne._events[ie]}function re(){this._events=new J,this._eventsCount=0}re.prototype.eventNames=function(){var ie=[],se,oe;if(this._eventsCount===0)return ie;for(oe in se=this._events)X.call(se,oe)&&ie.push(K?oe.slice(1):oe);return Object.getOwnPropertySymbols?ie.concat(Object.getOwnPropertySymbols(se)):ie},re.prototype.listeners=function(ie){var se=K?K+ie:ie,oe=this._events[se];if(!oe)return[];if(oe.fn)return[oe.fn];for(var ae=0,le=oe.length,ce=new Array(le);ae<le;ae++)ce[ae]=oe[ae].fn;return ce},re.prototype.listenerCount=function(ie){var se=K?K+ie:ie,oe=this._events[se];return oe?oe.fn?1:oe.length:0},re.prototype.emit=function(ie,se,oe,ae,le,ce){var de=K?K+ie:ie;if(!this._events[de])return!1;var he=this._events[de],pe=arguments.length,fe,ge;if(he.fn){switch(he.once&&this.removeListener(ie,he.fn,void 0,!0),pe){case 1:return he.fn.call(he.context),!0;case 2:return he.fn.call(he.context,se),!0;case 3:return he.fn.call(he.context,se,oe),!0;case 4:return he.fn.call(he.context,se,oe,ae),!0;case 5:return he.fn.call(he.context,se,oe,ae,le),!0;case 6:return he.fn.call(he.context,se,oe,ae,le,ce),!0}for(ge=1,fe=new Array(pe-1);ge<pe;ge++)fe[ge-1]=arguments[ge];he.fn.apply(he.context,fe)}else{var me=he.length,ye;for(ge=0;ge<me;ge++)switch(he[ge].once&&this.removeListener(ie,he[ge].fn,void 0,!0),pe){case 1:he[ge].fn.call(he[ge].context);break;case 2:he[ge].fn.call(he[ge].context,se);break;case 3:he[ge].fn.call(he[ge].context,se,oe);break;case 4:he[ge].fn.call(he[ge].context,se,oe,ae);break;default:if(!fe)for(ye=1,fe=new Array(pe-1);ye<pe;ye++)fe[ye-1]=arguments[ye];he[ge].fn.apply(he[ge].context,fe)}}return!0},re.prototype.on=function(ie,se,oe){return ee(this,ie,se,oe,!1)},re.prototype.once=function(ie,se,oe){return ee(this,ie,se,oe,!0)},re.prototype.removeListener=function(ie,se,oe,ae){var le=K?K+ie:ie;if(!this._events[le])return this;if(!se)return te(this,le),this;var ce=this._events[le];if(ce.fn)ce.fn===se&&(!ae||ce.once)&&(!oe||ce.context===oe)&&te(this,le);else{for(var de=0,he=[],pe=ce.length;de<pe;de++)(ce[de].fn!==se||ae&&!ce[de].once||oe&&ce[de].context!==oe)&&he.push(ce[de]);he.length?this._events[le]=he.length===1?he[0]:he:te(this,le)}return this},re.prototype.removeAllListeners=function(ie){var se;return ie?(se=K?K+ie:ie,this._events[se]&&te(this,se)):(this._events=new J,this._eventsCount=0),this},re.prototype.off=re.prototype.removeListener,re.prototype.addListener=re.prototype.on,re.prefixed=K,re.EventEmitter=re,Z.exports=re}),r$c={grad:.9,turn:360,rad:360/(2*Math.PI)},t$i=function(Z){return typeof Z=="string"?Z.length>0:typeof Z=="number"},n$D=function(Z,X,K){return X===void 0&&(X=0),K===void 0&&(K=Math.pow(10,X)),Math.round(K*Z)/K+0},e$a=function(Z,X,K){return X===void 0&&(X=0),K===void 0&&(K=1),Z>K?K:Z>X?Z:X},u$y=function(Z){return(Z=isFinite(Z)?Z%360:0)>0?Z:Z+360},a$y=function(Z){return{r:e$a(Z.r,0,255),g:e$a(Z.g,0,255),b:e$a(Z.b,0,255),a:e$a(Z.a)}},o$y=function(Z){return{r:n$D(Z.r),g:n$D(Z.g),b:n$D(Z.b),a:n$D(Z.a,3)}},i$y=/^#([0-9a-f]{3,8})$/i,s$E=function(Z){var X=Z.toString(16);return X.length<2?"0"+X:X},h$v=function(Z){var X=Z.r,K=Z.g,J=Z.b,Q=Z.a,ee=Math.max(X,K,J),te=ee-Math.min(X,K,J),re=te?ee===X?(K-J)/te:ee===K?2+(J-X)/te:4+(X-K)/te:0;return{h:60*(re<0?re+6:re),s:ee?te/ee*100:0,v:ee/255*100,a:Q}},b$q=function(Z){var X=Z.h,K=Z.s,J=Z.v,Q=Z.a;X=X/360*6,K/=100,J/=100;var ee=Math.floor(X),te=J*(1-K),re=J*(1-(X-ee)*K),ne=J*(1-(1-X+ee)*K),ie=ee%6;return{r:255*[J,re,te,te,ne,J][ie],g:255*[ne,J,J,re,te,te][ie],b:255*[te,te,ne,J,J,re][ie],a:Q}},g$r=function(Z){return{h:u$y(Z.h),s:e$a(Z.s,0,100),l:e$a(Z.l,0,100),a:e$a(Z.a)}},d$w=function(Z){return{h:n$D(Z.h),s:n$D(Z.s),l:n$D(Z.l),a:n$D(Z.a,3)}},f$x=function(Z){return b$q((K=(X=Z).s,{h:X.h,s:(K*=((J=X.l)<50?J:100-J)/100)>0?2*K/(J+K)*100:0,v:J+K,a:X.a}));var X,K,J},c$A=function(Z){return{h:(X=h$v(Z)).h,s:(Q=(200-(K=X.s))*(J=X.v)/100)>0&&Q<200?K*J/100/(Q<=100?Q:200-Q)*100:0,l:Q/2,a:X.a};var X,K,J,Q},l$u=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$K=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v$7=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m$A=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y$m={string:[[function(Z){var X=i$y.exec(Z);return X?(Z=X[1]).length<=4?{r:parseInt(Z[0]+Z[0],16),g:parseInt(Z[1]+Z[1],16),b:parseInt(Z[2]+Z[2],16),a:Z.length===4?n$D(parseInt(Z[3]+Z[3],16)/255,2):1}:Z.length===6||Z.length===8?{r:parseInt(Z.substr(0,2),16),g:parseInt(Z.substr(2,2),16),b:parseInt(Z.substr(4,2),16),a:Z.length===8?n$D(parseInt(Z.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(Z){var X=v$7.exec(Z)||m$A.exec(Z);return X?X[2]!==X[4]||X[4]!==X[6]?null:a$y({r:Number(X[1])/(X[2]?100/255:1),g:Number(X[3])/(X[4]?100/255:1),b:Number(X[5])/(X[6]?100/255:1),a:X[7]===void 0?1:Number(X[7])/(X[8]?100:1)}):null},"rgb"],[function(Z){var X=l$u.exec(Z)||p$K.exec(Z);if(!X)return null;var K,J,Q=g$r({h:(K=X[1],J=X[2],J===void 0&&(J="deg"),Number(K)*(r$c[J]||1)),s:Number(X[3]),l:Number(X[4]),a:X[5]===void 0?1:Number(X[5])/(X[6]?100:1)});return f$x(Q)},"hsl"]],object:[[function(Z){var X=Z.r,K=Z.g,J=Z.b,Q=Z.a,ee=Q===void 0?1:Q;return t$i(X)&&t$i(K)&&t$i(J)?a$y({r:Number(X),g:Number(K),b:Number(J),a:Number(ee)}):null},"rgb"],[function(Z){var X=Z.h,K=Z.s,J=Z.l,Q=Z.a,ee=Q===void 0?1:Q;if(!t$i(X)||!t$i(K)||!t$i(J))return null;var te=g$r({h:Number(X),s:Number(K),l:Number(J),a:Number(ee)});return f$x(te)},"hsl"],[function(Z){var X=Z.h,K=Z.s,J=Z.v,Q=Z.a,ee=Q===void 0?1:Q;if(!t$i(X)||!t$i(K)||!t$i(J))return null;var te=function(re){return{h:u$y(re.h),s:e$a(re.s,0,100),v:e$a(re.v,0,100),a:e$a(re.a)}}({h:Number(X),s:Number(K),v:Number(J),a:Number(ee)});return b$q(te)},"hsv"]]},N$4=function(Z,X){for(var K=0;K<X.length;K++){var J=X[K][0](Z);if(J)return[J,X[K][1]]}return[null,void 0]},x$f=function(Z){return typeof Z=="string"?N$4(Z.trim(),y$m.string):typeof Z=="object"&&Z!==null?N$4(Z,y$m.object):[null,void 0]},I$8=function(Z){return x$f(Z)[1]},M$a=function(Z,X){var K=c$A(Z);return{h:K.h,s:e$a(K.s+100*X,0,100),l:K.l,a:K.a}},H$6=function(Z){return(299*Z.r+587*Z.g+114*Z.b)/1e3/255},$$2=function(Z,X){var K=c$A(Z);return{h:K.h,s:K.s,l:e$a(K.l+100*X,0,100),a:K.a}},j$2=function(){function Z(X){this.parsed=x$f(X)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return Z.prototype.isValid=function(){return this.parsed!==null},Z.prototype.brightness=function(){return n$D(H$6(this.rgba),2)},Z.prototype.isDark=function(){return H$6(this.rgba)<.5},Z.prototype.isLight=function(){return H$6(this.rgba)>=.5},Z.prototype.toHex=function(){return X=o$y(this.rgba),K=X.r,J=X.g,Q=X.b,te=(ee=X.a)<1?s$E(n$D(255*ee)):"","#"+s$E(K)+s$E(J)+s$E(Q)+te;var X,K,J,Q,ee,te},Z.prototype.toRgb=function(){return o$y(this.rgba)},Z.prototype.toRgbString=function(){return X=o$y(this.rgba),K=X.r,J=X.g,Q=X.b,(ee=X.a)<1?"rgba("+K+", "+J+", "+Q+", "+ee+")":"rgb("+K+", "+J+", "+Q+")";var X,K,J,Q,ee},Z.prototype.toHsl=function(){return d$w(c$A(this.rgba))},Z.prototype.toHslString=function(){return X=d$w(c$A(this.rgba)),K=X.h,J=X.s,Q=X.l,(ee=X.a)<1?"hsla("+K+", "+J+"%, "+Q+"%, "+ee+")":"hsl("+K+", "+J+"%, "+Q+"%)";var X,K,J,Q,ee},Z.prototype.toHsv=function(){return X=h$v(this.rgba),{h:n$D(X.h),s:n$D(X.s),v:n$D(X.v),a:n$D(X.a,3)};var X},Z.prototype.invert=function(){return w$8({r:255-(X=this.rgba).r,g:255-X.g,b:255-X.b,a:X.a});var X},Z.prototype.saturate=function(X){return X===void 0&&(X=.1),w$8(M$a(this.rgba,X))},Z.prototype.desaturate=function(X){return X===void 0&&(X=.1),w$8(M$a(this.rgba,-X))},Z.prototype.grayscale=function(){return w$8(M$a(this.rgba,-1))},Z.prototype.lighten=function(X){return X===void 0&&(X=.1),w$8($$2(this.rgba,X))},Z.prototype.darken=function(X){return X===void 0&&(X=.1),w$8($$2(this.rgba,-X))},Z.prototype.rotate=function(X){return X===void 0&&(X=15),this.hue(this.hue()+X)},Z.prototype.alpha=function(X){return typeof X=="number"?w$8({r:(K=this.rgba).r,g:K.g,b:K.b,a:X}):n$D(this.rgba.a,3);var K},Z.prototype.hue=function(X){var K=c$A(this.rgba);return typeof X=="number"?w$8({h:X,s:K.s,l:K.l,a:K.a}):n$D(K.h)},Z.prototype.isEqual=function(X){return this.toHex()===w$8(X).toHex()},Z}(),w$8=function(Z){return Z instanceof j$2?Z:new j$2(Z)},S$b=[],k$4=function(Z){Z.forEach(function(X){S$b.indexOf(X)<0&&(X(j$2,y$m),S$b.push(X))})},E$6=function(){return new j$2({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};function d$v(Z,X){var K={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},J={};for(var Q in K)J[K[Q]]=Q;var ee={};Z.prototype.toName=function(te){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var re,ne,ie=J[this.toHex()];if(ie)return ie;if(te!=null&&te.closest){var se=this.toRgb(),oe=1/0,ae="black";if(!ee.length)for(var le in K)ee[le]=new Z(K[le]).toRgb();for(var ce in K){var de=(re=se,ne=ee[ce],Math.pow(re.r-ne.r,2)+Math.pow(re.g-ne.g,2)+Math.pow(re.b-ne.b,2));de<oe&&(oe=de,ae=ce)}return ae}},X.string.push([function(te){var re=te.toLowerCase(),ne=re==="transparent"?"#0000":K[re];return ne?new Z(ne).toRgb():null},"name"])}var u$x=Object.defineProperty,c$z=Object.getOwnPropertySymbols,m$z=Object.prototype.hasOwnProperty,h$u=Object.prototype.propertyIsEnumerable,b$p=(Z,X,K)=>X in Z?u$x(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,f$w=(Z,X)=>{for(var K in X||(X={}))m$z.call(X,K)&&b$p(Z,K,X[K]);if(c$z)for(var K of c$z(X))h$u.call(X,K)&&b$p(Z,K,X[K]);return Z};k$4([d$v]);const i$x=class{constructor(Z=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=Z}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(Z){return this.value=Z,this}set value(Z){if(Z instanceof i$x)this._value=this._cloneSource(Z._value),this._int=Z._int,this._components.set(Z._components);else{if(Z===null)throw new Error("Cannot set Color#value to null");(this._value===null||!this._isSourceEqual(this._value,Z))&&(this._normalize(Z),this._value=this._cloneSource(Z))}}get value(){return this._value}_cloneSource(Z){return typeof Z=="string"||typeof Z=="number"||Z instanceof Number||Z===null?Z:Array.isArray(Z)||ArrayBuffer.isView(Z)?Z.slice(0):typeof Z=="object"&&Z!==null?f$w({},Z):Z}_isSourceEqual(Z,X){const K=typeof Z;if(K!==typeof X)return!1;if(K==="number"||K==="string"||Z instanceof Number)return Z===X;if(Array.isArray(Z)&&Array.isArray(X)||ArrayBuffer.isView(Z)&&ArrayBuffer.isView(X))return Z.length!==X.length?!1:Z.every((J,Q)=>J===X[Q]);if(Z!==null&&X!==null){const J=Object.keys(Z),Q=Object.keys(X);return J.length!==Q.length?!1:J.every(ee=>Z[ee]===X[ee])}return Z===X}toRgba(){const[Z,X,K,J]=this._components;return{r:Z,g:X,b:K,a:J}}toRgb(){const[Z,X,K]=this._components;return{r:Z,g:X,b:K}}toRgbaString(){const[Z,X,K]=this.toUint8RgbArray();return`rgba(${Z},${X},${K},${this.alpha})`}toUint8RgbArray(Z){const[X,K,J]=this._components;return this._arrayRgb||(this._arrayRgb=[]),Z=Z||this._arrayRgb,Z[0]=Math.round(X*255),Z[1]=Math.round(K*255),Z[2]=Math.round(J*255),Z}toArray(Z){this._arrayRgba||(this._arrayRgba=[]),Z=Z||this._arrayRgba;const[X,K,J,Q]=this._components;return Z[0]=X,Z[1]=K,Z[2]=J,Z[3]=Q,Z}toRgbArray(Z){this._arrayRgb||(this._arrayRgb=[]),Z=Z||this._arrayRgb;const[X,K,J]=this._components;return Z[0]=X,Z[1]=K,Z[2]=J,Z}toNumber(){return this._int}toBgrNumber(){const[Z,X,K]=this.toUint8RgbArray();return(K<<16)+(X<<8)+Z}toLittleEndianNumber(){const Z=this._int;return(Z>>16)+(Z&65280)+((Z&255)<<16)}multiply(Z){const[X,K,J,Q]=i$x._temp.setValue(Z)._components;return this._components[0]*=X,this._components[1]*=K,this._components[2]*=J,this._components[3]*=Q,this._refreshInt(),this._value=null,this}premultiply(Z,X=!0){return X&&(this._components[0]*=Z,this._components[1]*=Z,this._components[2]*=Z),this._components[3]=Z,this._refreshInt(),this._value=null,this}toPremultiplied(Z,X=!0){if(Z===1)return(255<<24)+this._int;if(Z===0)return X?0:this._int;let K=this._int>>16&255,J=this._int>>8&255,Q=this._int&255;return X&&(K=K*Z+.5|0,J=J*Z+.5|0,Q=Q*Z+.5|0),(Z*255<<24)+(K<<16)+(J<<8)+Q}toHex(){const Z=this._int.toString(16);return`#${"000000".substring(0,6-Z.length)+Z}`}toHexa(){const Z=Math.round(this._components[3]*255).toString(16);return this.toHex()+"00".substring(0,2-Z.length)+Z}setAlpha(Z){return this._components[3]=this._clamp(Z),this}_normalize(Z){let X,K,J,Q;if((typeof Z=="number"||Z instanceof Number)&&Z>=0&&Z<=16777215){const ee=Z;X=(ee>>16&255)/255,K=(ee>>8&255)/255,J=(ee&255)/255,Q=1}else if((Array.isArray(Z)||Z instanceof Float32Array)&&Z.length>=3&&Z.length<=4)Z=this._clamp(Z),[X,K,J,Q=1]=Z;else if((Z instanceof Uint8Array||Z instanceof Uint8ClampedArray)&&Z.length>=3&&Z.length<=4)Z=this._clamp(Z,0,255),[X,K,J,Q=255]=Z,X/=255,K/=255,J/=255,Q/=255;else if(typeof Z=="string"||typeof Z=="object"){if(typeof Z=="string"){const te=i$x.HEX_PATTERN.exec(Z);te&&(Z=`#${te[2]}`)}const ee=w$8(Z);ee.isValid()&&({r:X,g:K,b:J,a:Q}=ee.rgba,X/=255,K/=255,J/=255)}if(X!==void 0)this._components[0]=X,this._components[1]=K,this._components[2]=J,this._components[3]=Q,this._refreshInt();else throw new Error(`Unable to convert color ${Z}`)}_refreshInt(){this._clamp(this._components);const[Z,X,K]=this._components;this._int=(Z*255<<16)+(X*255<<8)+(K*255|0)}_clamp(Z,X=0,K=1){return typeof Z=="number"?Math.min(Math.max(Z,X),K):(Z.forEach((J,Q)=>{Z[Q]=Math.min(Math.max(J,X),K)}),Z)}static isColorLike(Z){return typeof Z=="number"||typeof Z=="string"||Z instanceof Number||Z instanceof i$x||Array.isArray(Z)||Z instanceof Uint8Array||Z instanceof Uint8ClampedArray||Z instanceof Float32Array||Z.r!==void 0&&Z.g!==void 0&&Z.b!==void 0||Z.r!==void 0&&Z.g!==void 0&&Z.b!==void 0&&Z.a!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.l!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.l!==void 0&&Z.a!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.v!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.v!==void 0&&Z.a!==void 0}};let Color=i$x;Color.shared=new i$x,Color._temp=new i$x,Color.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;const cullingMixin={cullArea:null,cullable:!1,cullableChildren:!0},PI_2=Math.PI*2,RAD_TO_DEG=180/Math.PI,DEG_TO_RAD=Math.PI/180;class Matrix{constructor(X=1,K=0,J=0,Q=1,ee=0,te=0){this.array=null,this.a=X,this.b=K,this.c=J,this.d=Q,this.tx=ee,this.ty=te}fromArray(X){this.a=X[0],this.b=X[1],this.c=X[3],this.d=X[4],this.tx=X[2],this.ty=X[5]}set(X,K,J,Q,ee,te){return this.a=X,this.b=K,this.c=J,this.d=Q,this.tx=ee,this.ty=te,this}toArray(X,K){this.array||(this.array=new Float32Array(9));const J=K||this.array;return X?(J[0]=this.a,J[1]=this.b,J[2]=0,J[3]=this.c,J[4]=this.d,J[5]=0,J[6]=this.tx,J[7]=this.ty,J[8]=1):(J[0]=this.a,J[1]=this.c,J[2]=this.tx,J[3]=this.b,J[4]=this.d,J[5]=this.ty,J[6]=0,J[7]=0,J[8]=1),J}apply(X,K){K=K||new Point;const J=X.x,Q=X.y;return K.x=this.a*J+this.c*Q+this.tx,K.y=this.b*J+this.d*Q+this.ty,K}applyInverse(X,K){K=K||new Point;const J=this.a,Q=this.b,ee=this.c,te=this.d,re=this.tx,ne=this.ty,ie=1/(J*te+ee*-Q),se=X.x,oe=X.y;return K.x=te*ie*se+-ee*ie*oe+(ne*ee-re*te)*ie,K.y=J*ie*oe+-Q*ie*se+(-ne*J+re*Q)*ie,K}translate(X,K){return this.tx+=X,this.ty+=K,this}scale(X,K){return this.a*=X,this.d*=K,this.c*=X,this.b*=K,this.tx*=X,this.ty*=K,this}rotate(X){const K=Math.cos(X),J=Math.sin(X),Q=this.a,ee=this.c,te=this.tx;return this.a=Q*K-this.b*J,this.b=Q*J+this.b*K,this.c=ee*K-this.d*J,this.d=ee*J+this.d*K,this.tx=te*K-this.ty*J,this.ty=te*J+this.ty*K,this}append(X){const K=this.a,J=this.b,Q=this.c,ee=this.d;return this.a=X.a*K+X.b*Q,this.b=X.a*J+X.b*ee,this.c=X.c*K+X.d*Q,this.d=X.c*J+X.d*ee,this.tx=X.tx*K+X.ty*Q+this.tx,this.ty=X.tx*J+X.ty*ee+this.ty,this}appendFrom(X,K){const J=X.a,Q=X.b,ee=X.c,te=X.d,re=X.tx,ne=X.ty,ie=K.a,se=K.b,oe=K.c,ae=K.d;return this.a=J*ie+Q*oe,this.b=J*se+Q*ae,this.c=ee*ie+te*oe,this.d=ee*se+te*ae,this.tx=re*ie+ne*oe+K.tx,this.ty=re*se+ne*ae+K.ty,this}setTransform(X,K,J,Q,ee,te,re,ne,ie){return this.a=Math.cos(re+ie)*ee,this.b=Math.sin(re+ie)*ee,this.c=-Math.sin(re-ne)*te,this.d=Math.cos(re-ne)*te,this.tx=X-(J*this.a+Q*this.c),this.ty=K-(J*this.b+Q*this.d),this}prepend(X){const K=this.tx;if(X.a!==1||X.b!==0||X.c!==0||X.d!==1){const J=this.a,Q=this.c;this.a=J*X.a+this.b*X.c,this.b=J*X.b+this.b*X.d,this.c=Q*X.a+this.d*X.c,this.d=Q*X.b+this.d*X.d}return this.tx=K*X.a+this.ty*X.c+X.tx,this.ty=K*X.b+this.ty*X.d+X.ty,this}decompose(X){const K=this.a,J=this.b,Q=this.c,ee=this.d,te=X.pivot,re=-Math.atan2(-Q,ee),ne=Math.atan2(J,K),ie=Math.abs(re+ne);return ie<1e-5||Math.abs(PI_2-ie)<1e-5?(X.rotation=ne,X.skew.x=X.skew.y=0):(X.rotation=0,X.skew.x=re,X.skew.y=ne),X.scale.x=Math.sqrt(K*K+J*J),X.scale.y=Math.sqrt(Q*Q+ee*ee),X.position.x=this.tx+(te.x*K+te.y*Q),X.position.y=this.ty+(te.x*J+te.y*ee),X}invert(){const X=this.a,K=this.b,J=this.c,Q=this.d,ee=this.tx,te=X*Q-K*J;return this.a=Q/te,this.b=-K/te,this.c=-J/te,this.d=X/te,this.tx=(J*this.ty-Q*ee)/te,this.ty=-(X*this.ty-K*ee)/te,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const X=new Matrix;return X.a=this.a,X.b=this.b,X.c=this.c,X.d=this.d,X.tx=this.tx,X.ty=this.ty,X}copyTo(X){return X.a=this.a,X.b=this.b,X.c=this.c,X.d=this.d,X.tx=this.tx,X.ty=this.ty,X}copyFrom(X){return this.a=X.a,this.b=X.b,this.c=X.c,this.d=X.d,this.tx=X.tx,this.ty=X.ty,this}static get IDENTITY(){return l$t.identity()}static get shared(){return p$J.identity()}}const p$J=new Matrix,l$t=new Matrix;class ObservablePoint{constructor(X,K,J){this._x=K||0,this._y=J||0,this._observer=X}clone(X){return new ObservablePoint(X!=null?X:this._observer,this._x,this._y)}set(X=0,K=X){return(this._x!==X||this._y!==K)&&(this._x=X,this._y=K,this._observer.onUpdate(this)),this}copyFrom(X){return(this._x!==X.x||this._y!==X.y)&&(this._x=X.x,this._y=X.y,this._observer.onUpdate(this)),this}copyTo(X){return X.set(this._x,this._y),X}equals(X){return X.x===this._x&&X.y===this._y}get x(){return this._x}set x(X){this._x!==X&&(this._x=X,this._observer.onUpdate(this))}get y(){return this._y}set y(X){this._y!==X&&(this._y=X,this._observer.onUpdate(this))}}const t$h={default:-1};function uid(Z="default"){return t$h[Z]===void 0&&(t$h[Z]=-1),++t$h[Z]}const r$b={},v8_0_0="8.0.0";function deprecation(Z,X,K=3){if(r$b[X])return;let J=new Error().stack;typeof J=="undefined"?console.warn("PixiJS Deprecation Warning: ",`${X}
Deprecated since v${Z}`):(J=J.split(`
`).splice(K).join(`
`),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",`${X}
Deprecated since v${Z}`),console.warn(J),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",`${X}
Deprecated since v${Z}`),console.warn(J))),r$b[X]=!0}const childrenHelperMixin={allowChildren:!0,removeChildren(Z=0,X){const K=X!=null?X:this.children.length,J=K-Z,Q=[];if(J>0&&J<=K){for(let ee=K-1;ee>=Z;ee--){const te=this.children[ee];te&&(this.renderGroup&&this.renderGroup.removeChild(te),Q.push(te),te.parent=null)}removeItems(this.children,Z,K);for(let ee=0;ee<Q.length;++ee)this.emit("childRemoved",Q[ee],this,ee),Q[ee].emit("removed",this);return Q}else if(J===0&&this.children.length===0)return Q;throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},removeChildAt(Z){const X=this.getChildAt(Z);return this.removeChild(X)},getChildAt(Z){if(Z<0||Z>=this.children.length)throw new Error(`getChildAt: Index (${Z}) does not exist.`);return this.children[Z]},setChildIndex(Z,X){if(X<0||X>=this.children.length)throw new Error(`The index ${X} supplied is out of bounds ${this.children.length}`);this.getChildIndex(Z),this.addChildAt(Z,X)},getChildIndex(Z){const X=this.children.indexOf(Z);if(X===-1)throw new Error("The supplied Container must be a child of the caller");return X},addChildAt(Z,X){this.allowChildren||deprecation(v8_0_0,"addChildAt: Only Containers will be allowed to add children in v8.0.0");const{children:K}=this;if(X<0||X>K.length)throw new Error(`${Z}addChildAt: The index ${X} supplied is out of bounds ${K.length}`);if(Z.parent){const J=Z.parent.children.indexOf(Z);if(Z.parent===this&&J===X)return Z;J!==-1&&Z.parent.children.splice(J,1)}return X===K.length?K.push(Z):K.splice(X,0,Z),Z.parent=this,Z.didChange=!0,Z.didViewUpdate=!1,Z._updateFlags=15,this.renderGroup&&this.renderGroup.addChild(Z),this.sortableChildren&&(this.sortDirty=!0),this.emit("childAdded",Z,this,X),Z.emit("added",this),Z},swapChildren(Z,X){if(Z===X)return;const K=this.getChildIndex(Z),J=this.getChildIndex(X);this.children[K]=X,this.children[J]=Z},removeFromParent(){var Z;(Z=this.parent)==null||Z.removeChild(this)}};class FilterEffect{constructor(X){this.pipe="filter",this.priority=1,this.filters=X==null?void 0:X.filters,this.filterArea=X==null?void 0:X.filterArea}destroy(){for(let X=0;X<this.filters.length;X++)this.filters[X].destroy();this.filters=null,this.filterArea=null}}const l$s=[];function getFilterEffect(Z,X){const K=l$s.pop()||new FilterEffect;return K.filters=Z,K.filterArea=X,K}function returnFilterEffect(Z){Z.filters=null,l$s.push(Z)}class Pool{constructor(X,K){this._pool=[],this._count=0,this._index=0,this._classType=X,K&&this.prepopulate(K)}prepopulate(X){for(let K=0;K<X;K++)this._pool[this._index++]=new this._classType;this._count+=X}get(X){var K;let J;return this._index>0?J=this._pool[--this._index]:J=new this._classType,(K=J.init)==null||K.call(J,X),J}return(X){var K;(K=X.reset)==null||K.call(X),this._pool[this._index++]=X}get totalSize(){return this._count}get totalFree(){return this._index}get totalUsed(){return this._count-this._index}}class PoolGroupClass{constructor(){this._poolsByClass=new Map}prepopulate(X,K){this.getPool(X).prepopulate(K)}get(X,K){return this.getPool(X).get(K)}return(X){this.getPool(X.constructor).return(X)}getPool(X){return this._poolsByClass.has(X)||this._poolsByClass.set(X,new Pool(X)),this._poolsByClass.get(X)}stats(){const X={};return this._poolsByClass.forEach(K=>{const J=X[K._classType.name]?K._classType.name+K._classType.ID:K._classType.name;X[J]={free:K.totalFree,used:K.totalUsed,size:K.totalSize}}),X}}const BigPool=new PoolGroupClass;class MaskEffectManagerClass{constructor(){this._effectClasses=[],this._tests=[],this._initialized=!1}init(){this._initialized||(this._initialized=!0,this._effectClasses.forEach(X=>{this.add({test:X.test,maskClass:X})}))}add(X){this._tests.push(X)}getMaskEffect(X){this._initialized||this.init();for(let K=0;K<this._tests.length;K++){const J=this._tests[K];if(J.test(X))return BigPool.get(J.maskClass,X)}return X}returnMaskEffect(X){BigPool.return(X)}}const MaskEffectManager=new MaskEffectManagerClass;b$r.handleByList(u$z.MaskEffect,MaskEffectManager._effectClasses);const effectsMixin={_mask:null,_filters:null,effects:[],addEffect(Z){this.effects.indexOf(Z)===-1&&(this.effects.push(Z),this.effects.sort((X,K)=>X.priority-K.priority),!this.isRenderGroupRoot&&this.renderGroup&&(this.renderGroup.structureDidChange=!0),this._updateIsSimple())},removeEffect(Z){const X=this.effects.indexOf(Z);X!==-1&&(this.effects.splice(X,1),!this.isRenderGroupRoot&&this.renderGroup&&(this.renderGroup.structureDidChange=!0),this._updateIsSimple())},set mask(Z){if(this._mask||(this._mask={mask:null,effect:null}),this._mask.mask===Z||(this._mask.effect&&(this.removeEffect(this._mask.effect),MaskEffectManager.returnMaskEffect(this._mask.effect),this._mask.effect=null),this._mask.mask=Z,Z==null))return;const X=MaskEffectManager.getMaskEffect(Z);this._mask.effect=X,this.addEffect(X)},get mask(){var Z;return(Z=this._mask)==null?void 0:Z.mask},set filters(Z){if(!Array.isArray(Z)&&Z!==null&&(Z=[Z]),this._filters||(this._filters={filters:null,effect:null,filterArea:null}),this._filters.filters===Z||(this._filters.effect&&(this.removeEffect(this._filters.effect),returnFilterEffect(this._filters.effect),this._filters.effect=null),this._filters.filters=Z,!Z))return;const X=getFilterEffect(Z,this.filterArea);this._filters.effect=X,this.addEffect(X)},get filters(){var Z;return(Z=this._filters)==null?void 0:Z.filters},set filterArea(Z){this._filters||(this._filters={filters:null,effect:null,filterArea:null}),this._filters.filterArea=Z},get filterArea(){var Z;return(Z=this._filters)==null?void 0:Z.filterArea}},findMixin={label:null,get name(){return deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label},set name(Z){deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label=Z},getChildByName(Z,X=!1){return this.getChildByLabel(Z,X)},getChildByLabel(Z,X=!1){const K=this.children;for(let J=0;J<K.length;J++){const Q=K[J];if(Q.label===Z||Z instanceof RegExp&&Z.test(Q.label))return Q}if(X)for(let J=0;J<K.length;J++){const Q=K[J].getChildByLabel(Z,!0);if(Q)return Q}return null},getChildrenByLabel(Z,X=!1,K=[]){const J=this.children;for(let Q=0;Q<J.length;Q++){const ee=J[Q];(ee.label===Z||Z instanceof RegExp&&Z.test(ee.label))&&K.push(ee)}if(X)for(let Q=0;Q<J.length;Q++)J[Q].getChildrenByLabel(Z,!0,K);return K}},f$v=[new Point,new Point,new Point,new Point];class Rectangle{constructor(X=0,K=0,J=0,Q=0){this.type="rectangle",this.x=Number(X),this.y=Number(K),this.width=Number(J),this.height=Number(Q)}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}isEmpty(){return this.left===this.right||this.top===this.bottom}static get EMPTY(){return new Rectangle(0,0,0,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}copyFromBounds(X){return this.x=X.minX,this.y=X.minY,this.width=X.maxX-X.minX,this.height=X.maxY-X.minY,this}copyFrom(X){return this.x=X.x,this.y=X.y,this.width=X.width,this.height=X.height,this}copyTo(X){return X.copyFrom(this),X}contains(X,K){return this.width<=0||this.height<=0?!1:X>=this.x&&X<this.x+this.width&&K>=this.y&&K<this.y+this.height}strokeContains(X,K,J){const{width:Q,height:ee}=this;if(Q<=0||ee<=0)return!1;const te=this.x,re=this.y,ne=te-J/2,ie=te+Q+J/2,se=re-J/2,oe=re+ee+J/2,ae=te+J/2,le=te+Q-J/2,ce=re+J/2,de=re+ee-J/2;return X>=ne&&X<=ie&&K>=se&&K<=oe&&!(X>ae&&X<le&&K>ce&&K<de)}intersects(X,K){if(!K){const ve=this.x<X.x?X.x:this.x;if((this.right>X.right?X.right:this.right)<=ve)return!1;const be=this.y<X.y?X.y:this.y;return(this.bottom>X.bottom?X.bottom:this.bottom)>be}const J=this.left,Q=this.right,ee=this.top,te=this.bottom;if(Q<=J||te<=ee)return!1;const re=f$v[0].set(X.left,X.top),ne=f$v[1].set(X.left,X.bottom),ie=f$v[2].set(X.right,X.top),se=f$v[3].set(X.right,X.bottom);if(ie.x<=re.x||ne.y<=re.y)return!1;const oe=Math.sign(K.a*K.d-K.b*K.c);if(oe===0||(K.apply(re,re),K.apply(ne,ne),K.apply(ie,ie),K.apply(se,se),Math.max(re.x,ne.x,ie.x,se.x)<=J||Math.min(re.x,ne.x,ie.x,se.x)>=Q||Math.max(re.y,ne.y,ie.y,se.y)<=ee||Math.min(re.y,ne.y,ie.y,se.y)>=te))return!1;const ae=oe*(ne.y-re.y),le=oe*(re.x-ne.x),ce=ae*J+le*ee,de=ae*Q+le*ee,he=ae*J+le*te,pe=ae*Q+le*te;if(Math.max(ce,de,he,pe)<=ae*re.x+le*re.y||Math.min(ce,de,he,pe)>=ae*se.x+le*se.y)return!1;const fe=oe*(re.y-ie.y),ge=oe*(ie.x-re.x),me=fe*J+ge*ee,ye=fe*Q+ge*ee,_e=fe*J+ge*te,Ae=fe*Q+ge*te;return!(Math.max(me,ye,_e,Ae)<=fe*re.x+ge*re.y||Math.min(me,ye,_e,Ae)>=fe*se.x+ge*se.y)}pad(X=0,K=X){return this.x-=X,this.y-=K,this.width+=X*2,this.height+=K*2,this}fit(X){const K=Math.max(this.x,X.x),J=Math.min(this.x+this.width,X.x+X.width),Q=Math.max(this.y,X.y),ee=Math.min(this.y+this.height,X.y+X.height);return this.x=K,this.width=Math.max(J-K,0),this.y=Q,this.height=Math.max(ee-Q,0),this}ceil(X=1,K=.001){const J=Math.ceil((this.x+this.width-K)*X)/X,Q=Math.ceil((this.y+this.height-K)*X)/X;return this.x=Math.floor((this.x+K)*X)/X,this.y=Math.floor((this.y+K)*X)/X,this.width=J-this.x,this.height=Q-this.y,this}enlarge(X){const K=Math.min(this.x,X.x),J=Math.max(this.x+this.width,X.x+X.width),Q=Math.min(this.y,X.y),ee=Math.max(this.y+this.height,X.y+X.height);return this.x=K,this.width=J-K,this.y=Q,this.height=ee-Q,this}getBounds(X){return X=X||new Rectangle,X.copyFrom(this),X}}class Bounds{constructor(X=1/0,K=1/0,J=-1/0,Q=-1/0){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this._matrixStack=[],this.matrix=new Matrix,this.minX=X,this.minY=K,this.maxX=J,this.maxY=Q}get rectangle(){this._rectangle||(this._rectangle=new Rectangle);const X=this._rectangle;return this.minX>this.maxX||this.minY>this.maxY?(X.x=0,X.y=0,X.width=0,X.height=0):X.copyFromBounds(this),X}clear(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this._matrixStack.length=0,this.matrix.identity()}pushMatrix(X){this._matrixStack.push(X),this._matrixStack.length>1?(this.matrix.copyFrom(this._matrixStack[this._matrixStack.length-2]),this.matrix.append(X)):this.matrix.copyFrom(X)}popMatrix(){this._matrixStack.pop(),this._matrixStack.length>1?(this.matrix.copyFrom(this._matrixStack[this._matrixStack.length-2]),this.matrix.append(this._matrixStack[this._matrixStack.length-1])):this._matrixStack.length===1?this.matrix.copyFrom(this._matrixStack[0]):this.matrix.identity()}setMatrix(X){this.matrix.copyFrom(X)}set(X,K,J,Q){this.minX=X,this.minY=K,this.maxX=J,this.maxY=Q}addFrame(X,K,J,Q){const ee=this.matrix,te=ee.a,re=ee.b,ne=ee.c,ie=ee.d,se=ee.tx,oe=ee.ty;let ae=this.minX,le=this.minY,ce=this.maxX,de=this.maxY,he=te*X+ne*K+se,pe=re*X+ie*K+oe;ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,he=te*J+ne*K+se,pe=re*J+ie*K+oe,ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,he=te*X+ne*Q+se,pe=re*X+ie*Q+oe,ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,he=te*J+ne*Q+se,pe=re*J+ie*Q+oe,ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,this.minX=ae,this.minY=le,this.maxX=ce,this.maxY=de}addRect(X){this.addFrame(X.x,X.y,X.x+X.width,X.y+X.height)}addBounds(X){this.addFrame(X.minX,X.minY,X.maxX,X.maxY)}addBoundsMask(X){this.minX=this.minX>X.minX?this.minX:X.minX,this.minY=this.minY>X.minY?this.minY:X.minY,this.maxX=this.maxX<X.maxX?this.maxX:X.maxX,this.maxY=this.maxY<X.maxY?this.maxY:X.maxY}applyMatrix(X){const K=this.minX,J=this.minY,Q=this.maxX,ee=this.maxY,{a:te,b:re,c:ne,d:ie,tx:se,ty:oe}=X;let ae=te*K+ne*J+se,le=re*K+ie*J+oe;this.minX=ae,this.minY=le,this.maxX=ae,this.maxY=le,ae=te*Q+ne*J+se,le=re*Q+ie*J+oe,this.minX=ae<this.minX?ae:this.minX,this.minY=le<this.minY?le:this.minY,this.maxX=ae>this.maxX?ae:this.maxX,this.maxY=le>this.maxY?le:this.maxY,ae=te*K+ne*ee+se,le=re*K+ie*ee+oe,this.minX=ae<this.minX?ae:this.minX,this.minY=le<this.minY?le:this.minY,this.maxX=ae>this.maxX?ae:this.maxX,this.maxY=le>this.maxY?le:this.maxY,ae=te*Q+ne*ee+se,le=re*Q+ie*ee+oe,this.minX=ae<this.minX?ae:this.minX,this.minY=le<this.minY?le:this.minY,this.maxX=ae>this.maxX?ae:this.maxX,this.maxY=le>this.maxY?le:this.maxY}fit(X){return this.minX<X.left&&(this.minX=X.left),this.maxX>X.right&&(this.maxX=X.right),this.minY<X.top&&(this.minY=X.top),this.maxY>X.bottom&&(this.maxY=X.bottom),this}pad(X,K=X){return this.minX-=X,this.maxX+=X,this.minY-=K,this.maxY+=K,this}ceil(){return this.minX=Math.floor(this.minX),this.minY=Math.floor(this.minY),this.maxX=Math.ceil(this.maxX),this.maxY=Math.ceil(this.maxY),this}clone(){return new Bounds(this.minX,this.minY,this.maxX,this.maxY)}scale(X,K=X){return this.minX*=X,this.minY*=K,this.maxX*=X,this.maxY*=K,this}get x(){return this.minX}get y(){return this.minY}get width(){return this.maxX-this.minX}get height(){return this.maxY-this.minY}get isPositive(){return this.maxX-this.minX>0&&this.maxY-this.minY>0}get isValid(){return this.minX+this.minY!==1/0}addVertexData(X,K,J){let Q=this.minX,ee=this.minY,te=this.maxX,re=this.maxY;const ne=this.matrix,ie=ne.a,se=ne.b,oe=ne.c,ae=ne.d,le=ne.tx,ce=ne.ty;for(let de=K;de<J;de+=2){const he=X[de],pe=X[de+1],fe=ie*he+oe*pe+le,ge=se*he+ae*pe+ce;Q=fe<Q?fe:Q,ee=ge<ee?ge:ee,te=fe>te?fe:te,re=ge>re?ge:re}this.minX=Q,this.minY=ee,this.maxX=te,this.maxY=re}containsPoint(X,K){return this.minX<=X&&this.minY<=K&&this.maxX>=X&&this.maxY>=K}toString(){return`[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`}}function updateLocalTransform(Z,X){const K=X._scale,J=X._pivot,Q=X._position,ee=K._x,te=K._y,re=J._x,ne=J._y;Z.a=X._cx*ee,Z.b=X._sx*ee,Z.c=X._cy*te,Z.d=X._sy*te,Z.tx=Q._x-(re*Z.a+ne*Z.c),Z.ty=Q._y-(re*Z.b+ne*Z.d)}function getGlobalBounds(Z,X,K){K.clear();let J;return Z.parent?X?J=Z.parent.worldTransform:J=updateTransformBackwards(Z,new Matrix):J=Matrix.IDENTITY,_getGlobalBounds(Z,K,J,X),K.isValid||K.set(0,0,0,0),K}function _getGlobalBounds(Z,X,K,J){var Q,ee;if(!Z.visible||!Z.measurable)return;let te;J?te=Z.worldTransform:(Z.didChange&&updateLocalTransform(Z.localTransform,Z),te=Matrix.shared.appendFrom(Z.localTransform,K).clone());const re=X,ne=!!Z.effects.length;if(ne&&(X=X.clone()),Z.boundsArea)X.setMatrix(te),X.addRect(Z.boundsArea);else{Z.view&&(X.setMatrix(te),Z.view.addBounds(X));for(let ie=0;ie<Z.children.length;ie++)_getGlobalBounds(Z.children[ie],X,te,J)}if(ne){for(let ie=0;ie<Z.effects.length;ie++)(ee=(Q=Z.effects[ie]).addBounds)==null||ee.call(Q,X);re.setMatrix(Matrix.IDENTITY),re.addBounds(X)}}function updateTransformBackwards(Z,X){const K=Z.parent;return K&&(updateTransformBackwards(K,X),K.didChange&&updateLocalTransform(K.localTransform,K),X.append(K.localTransform)),X}function getLocalBounds(Z,X,K){X.clear(),K||(K=new Matrix),Z.boundsArea?(X.setMatrix(K),X.addRect(Z.boundsArea)):Z.view&&(X.setMatrix(K),Z.view.addBounds(X));for(let J=0;J<Z.children.length;J++)p$I(Z.children[J],X,K,Z);return X.isValid||X.set(0,0,0,0),X}function p$I(Z,X,K,J){var Q,ee;if(!Z.visible||!Z.measurable)return;Z.didChange&&updateLocalTransform(Z.localTransform,Z);const te=Z.localTransform,re=Matrix.shared.appendFrom(te,K).clone(),ne=X,ie=!!Z.effects.length;if(ie&&(X=new Bounds),Z.boundsArea)X.setMatrix(re),X.addRect(Z.boundsArea);else{Z.view&&(X.setMatrix(re),Z.view.addBounds(X));for(let se=0;se<Z.children.length;se++)p$I(Z.children[se],X,re,J)}if(ie){for(let se=0;se<Z.effects.length;se++)(ee=(Q=Z.effects[se]).addLocalBounds)==null||ee.call(Q,X,J);ne.setMatrix(Matrix.IDENTITY),ne.addBounds(X)}}function getParent(Z,X,K){const J=Z.parent;J&&J!==X&&(getParent(J,X,K),updateLocalTransform(J.localTransform,J),K.append(J.localTransform))}const o$x=new Bounds,i$w=new Matrix,measureMixin={get width(){return Math.abs(this.scale.x*getLocalBounds(this,o$x,i$w).width)},set width(Z){const X=getLocalBounds(this,o$x,i$w).width,K=Math.sign(this.scale.x)||1;X!==0?this.scale.x=Z/X*K:this.scale.x=K},get height(){return Math.abs(this.scale.y*getLocalBounds(this,o$x,i$w).height)},set height(Z){const X=getLocalBounds(this,o$x,i$w).height,K=Math.sign(this.scale.y)||1;X!==0?this.scale.y=Z/X*K:this.scale.y=K},getLocalBounds(Z){const X=getLocalBounds(this,new Bounds,i$w);return Z?Z.copyFromBounds(X):X.rectangle.clone()},getBounds(Z,X){const K=getGlobalBounds(this,Z,o$x);return X?X.copyFromBounds(K):K.rectangle.clone()}},onRenderMixin={_onRender:null,set onRender(Z){const X=this.renderGroup;if(!Z){this._onRender&&(X==null||X.removeOnRender(this)),this._onRender=null;return}this._onRender||X==null||X.addOnRender(this),this._onRender=Z},get onRender(){return this._onRender}},sortMixin={_zIndex:0,sortDirty:!1,sortableChildren:!1,get zIndex(){return this._zIndex},set zIndex(Z){this._zIndex!==Z&&(this._zIndex=Z,this.depthOfChildModified())},depthOfChildModified(){this.parent&&(this.parent.sortableChildren=!0,this.parent.sortDirty=!0),this.renderGroup&&!this.isRenderGroupRoot&&(this.renderGroup.structureDidChange=!0)},sortChildren(){this.sortDirty&&(this.sortDirty=!1,this.children.sort(e$9))}};function e$9(Z,X){return Z._zIndex-X._zIndex}const toLocalGlobalMixin={getGlobalPosition(Z=new Point,X=!1){return this.parent?this.parent.toGlobal(this._position,Z,X):(Z.x=this._position.x,Z.y=this._position.y),Z},toGlobal(Z,X,K=!1){if(!K){this.didChange&&updateLocalTransform(this.localTransform,this);const J=updateTransformBackwards(this,new Matrix);return J.append(this.localTransform),J.apply(Z,X)}return this.worldTransform.apply(Z,X)},toLocal(Z,X,K,J){if(X&&(Z=X.toGlobal(Z,K,J)),!J){this.didChange&&updateLocalTransform(this.localTransform,this);const Q=updateTransformBackwards(this,new Matrix);return Q.append(this.localTransform),Q.applyInverse(Z,K)}return this.worldTransform.applyInverse(Z,K)}};class InstructionSet{constructor(){this.uid=uid("instructionSet"),this.instructions=[],this.instructionSize=0}reset(){this.instructionSize=0}add(X){this.instructions[this.instructionSize++]=X}log(){this.instructions.length=this.instructionSize,console.table(this.instructions,["type","action"])}}class RenderGroup{constructor(X){this.renderPipeId="renderGroup",this.root=null,this.canBundle=!1,this.renderGroupParent=null,this.renderGroupChildren=[],this._children=[],this.worldTransform=new Matrix,this.worldColorAlpha=4294967295,this.worldColor=16777215,this.worldAlpha=1,this.childrenToUpdate=Object.create(null),this.updateTick=0,this.childrenRenderablesToUpdate={list:[],index:0},this.structureDidChange=!0,this.instructionSet=new InstructionSet,this._onRenderContainers=[],this.root=X,this.addChild(X)}get localTransform(){return this.root.localTransform}get rgTransform(){return this.root.rgTransform}addRenderGroupChild(X){X.renderGroupParent&&X.renderGroupParent._removeRenderGroupChild(X),X.renderGroupParent=this,this.onChildUpdate(X.root),this.renderGroupChildren.push(X)}_removeRenderGroupChild(X){X.root.didChange&&this._removeChildFromUpdate(X.root);const K=this.renderGroupChildren.indexOf(X);K>-1&&this.renderGroupChildren.splice(K,1),X.renderGroupParent=null}addChild(X){if(this.structureDidChange=!0,X!==this.root&&(this._children.push(X),X.updateTick=-1,X.parent===this.root?X.relativeRenderGroupDepth=1:X.relativeRenderGroupDepth=X.parent.relativeRenderGroupDepth+1,X._onRender&&this.addOnRender(X)),X.renderGroup){if(X.renderGroup.root===X){this.addRenderGroupChild(X.renderGroup);return}}else X.renderGroup=this,X.didChange=!0;const K=X.children;X.isRenderGroupRoot||this.onChildUpdate(X);for(let J=0;J<K.length;J++)this.addChild(K[J])}removeChild(X){if(this.structureDidChange=!0,X._onRender&&this.removeOnRender(X),X.renderGroup.root!==X){const J=X.children;for(let Q=0;Q<J.length;Q++)this.removeChild(J[Q]);X.didChange&&X.renderGroup._removeChildFromUpdate(X),X.renderGroup=null}else this._removeRenderGroupChild(X.renderGroup);const K=this._children.indexOf(X);K>-1&&this._children.splice(K,1)}onChildUpdate(X){let K=this.childrenToUpdate[X.relativeRenderGroupDepth];K||(K=this.childrenToUpdate[X.relativeRenderGroupDepth]={index:0,list:[]}),K.list[K.index++]=X}updateRenderable(X){X.rgVisibleRenderable<3||(X.didViewUpdate=!1,this.instructionSet.renderPipes[X.view.renderPipeId].updateRenderable(X))}onChildViewUpdate(X){this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++]=X}_removeChildFromUpdate(X){const K=this.childrenToUpdate[X.relativeRenderGroupDepth];if(!K)return;const J=K.list.indexOf(X);J>-1&&K.list.splice(J,1),K.index--}get isRenderable(){return this.root.localVisibleRenderable===3&&this.worldAlpha>0}addOnRender(X){this._onRenderContainers.push(X)}removeOnRender(X){this._onRenderContainers.splice(this._onRenderContainers.indexOf(X),1)}runOnRender(){this._onRenderContainers.forEach(X=>{X._onRender()})}}function assignWithIgnore(Z,X,K={}){for(const J in X)!K[J]&&X[J]!==void 0&&(Z[J]=X[J])}const a$x=new ObservablePoint(null),s$D=new ObservablePoint(null),l$r=new ObservablePoint(null,1,1),UPDATE_COLOR=1,UPDATE_BLEND=2,UPDATE_VISIBLE=4,UPDATE_TRANSFORM=8;class Container extends eventemitter3{constructor(X={}){var K,J;super(),this.uid=uid("renderable"),this._updateFlags=15,this.isRenderGroupRoot=!1,this.renderGroup=null,this.didChange=!1,this.didViewUpdate=!1,this.relativeRenderGroupDepth=0,this.children=[],this.parent=null,this.includeInBuild=!0,this.measurable=!0,this.isSimple=!0,this.updateTick=-1,this.localTransform=new Matrix,this.rgTransform=new Matrix,this.destroyed=!1,this._position=new ObservablePoint(this,0,0),this._scale=l$r,this._pivot=s$D,this._skew=a$x,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._rotation=0,this.localColor=16777215,this.localAlpha=1,this.rgAlpha=1,this.rgColor=16777215,this.rgColorAlpha=4294967295,this.localBlendMode="inherit",this.rgBlendMode="normal",this.localVisibleRenderable=3,this.rgVisibleRenderable=3,X.view&&(this.view=X.view,this.view.owner=this,X.view=void 0),assignWithIgnore(this,X,{children:!0,parent:!0,effects:!0}),(K=X.children)==null||K.forEach(Q=>this.addChild(Q)),this.effects=[],(J=X.parent)==null||J.addChild(this)}static mixin(X){Object.defineProperties(Container.prototype,Object.getOwnPropertyDescriptors(X))}addChild(...X){if(this.allowChildren||deprecation(v8_0_0,"addChild: Only Containers will be allowed to add children in v8.0.0"),X.length>1){for(let J=0;J<X.length;J++)this.addChild(X[J]);return X[0]}const K=X[0];return K.parent===this?(this.children.splice(this.children.indexOf(K),1),this.children.push(K),this.renderGroup&&!this.isRenderGroupRoot&&(this.renderGroup.structureDidChange=!0),K):(K.parent&&K.parent.removeChild(K),this.children.push(K),this.sortableChildren&&(this.sortDirty=!0),K.parent=this,K.didChange=!0,K.didViewUpdate=!1,K._updateFlags=15,this.renderGroup&&this.renderGroup.addChild(K),this.emit("childAdded",K,this,this.children.length-1),K.emit("added",this),K._zIndex!==0&&K.depthOfChildModified(),K)}removeChild(...X){if(X.length>1){for(let Q=0;Q<X.length;Q++)this.removeChild(X[Q]);return X[0]}const K=X[0],J=this.children.indexOf(K);return J>-1&&(this.children.splice(J,1),this.renderGroup&&this.renderGroup.removeChild(K)),K.parent=null,this.emit("childRemoved",K,this,J),K.emit("removed",this),K}onUpdate(X){if(X&&X===this._skew&&this._updateSkew(),!this.didChange)if(this.didChange=!0,this.isRenderGroupRoot){const K=this.renderGroup.renderGroupParent;K&&K.onChildUpdate(this)}else this.renderGroup&&this.renderGroup.onChildUpdate(this)}onViewUpdate(){this.didViewUpdate||(this.didViewUpdate=!0,this.renderGroup&&this.renderGroup.onChildViewUpdate(this))}set isRenderGroup(X){if(this.isRenderGroupRoot&&X===!1)throw new Error("[Pixi] cannot undo a render group just yet");X&&this.enableRenderGroup()}get isRenderGroup(){return this.isRenderGroupRoot}enableRenderGroup(){if(this.renderGroup&&this.renderGroup.root===this)return;this.isRenderGroupRoot=!0;const X=this.renderGroup;if(X&&X.removeChild(this),this.renderGroup=new RenderGroup(this),X){for(let K=0;K<X.renderGroupChildren.length;K++){const J=X.renderGroupChildren[K];let Q=J.root;for(;Q;){if(Q===this){this.renderGroup.addRenderGroupChild(J);break}Q=Q.parent}}X.addRenderGroupChild(this.renderGroup)}this._updateIsSimple()}_updateIsSimple(){this.isSimple=!this.isRenderGroupRoot&&this.effects.length===0}get worldTransform(){return this._worldTransform||(this._worldTransform=new Matrix),this.renderGroup&&(this.isRenderGroupRoot?this._worldTransform.copyFrom(this.renderGroup.worldTransform):this._worldTransform.appendFrom(this.rgTransform,this.renderGroup.worldTransform)),this._worldTransform}get x(){return this._position.x}set x(X){this._position.x=X}get y(){return this._position.y}set y(X){this._position.y=X}get position(){return this._position}set position(X){this._position.copyFrom(X)}get rotation(){return this._rotation}set rotation(X){this._rotation!==X&&(this._rotation=X,this.onUpdate(this._skew))}get angle(){return this.rotation*RAD_TO_DEG}set angle(X){this.rotation=X*DEG_TO_RAD}get pivot(){return this._pivot===s$D&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot}set pivot(X){this._pivot===s$D&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot.copyFrom(X)}get skew(){return this._skew===a$x&&(this._skew=new ObservablePoint(this,0,0)),this._skew}get scale(){return this._scale===l$r&&(this._scale=new ObservablePoint(this,1,1)),this._scale}set scale(X){this._scale===l$r&&(this._scale=new ObservablePoint(this,0,0)),this._scale.copyFrom(X)}_updateSkew(){const X=this._rotation,K=this._skew;this._cx=Math.cos(X+K._y),this._sx=Math.sin(X+K._y),this._cy=-Math.sin(X-K._x),this._sy=Math.cos(X-K._x)}updateTransform(X){return this.position.set(typeof X.x=="number"?X.x:this.position.x,typeof X.y=="number"?X.y:this.position.y),this.scale.set(typeof X.scaleX=="number"?X.scaleX||1:this.scale.x,typeof X.scaleY=="number"?X.scaleY||1:this.scale.y),this.rotation=typeof X.rotation=="number"?X.rotation:this.rotation,this.skew.set(typeof X.skewX=="number"?X.skewX:this.skew.x,typeof X.skewY=="number"?X.skewY:this.skew.y),this.pivot.set(typeof X.pivotX=="number"?X.pivotX:this.pivot.x,typeof X.pivotY=="number"?X.pivotY:this.pivot.y),this}set alpha(X){X!==this.localAlpha&&(this.localAlpha=X,this._updateFlags|=UPDATE_COLOR,this.onUpdate())}get alpha(){return this.localAlpha}set tint(X){const K=Color.shared.setValue(X!=null?X:16777215).toBgrNumber();K!==this.localColor&&(this.localColor=K,this._updateFlags|=UPDATE_COLOR,this.onUpdate())}get tint(){const X=this.localColor;return((X&255)<<16)+(X&65280)+(X>>16&255)}set blendMode(X){this.localBlendMode!==X&&(this.renderGroup&&!this.isRenderGroupRoot&&(this.renderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_BLEND,this.localBlendMode=X,this.onUpdate())}get blendMode(){return this.localBlendMode}get visible(){return!!(this.localVisibleRenderable&2)}set visible(X){const K=X?1:0;(this.localVisibleRenderable&2)>>1!==K&&(this.renderGroup&&!this.isRenderGroupRoot&&(this.renderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localVisibleRenderable=this.localVisibleRenderable&1|K<<1,this.onUpdate())}get renderable(){return!!(this.localVisibleRenderable&1)}set renderable(X){const K=X?1:0;(this.localVisibleRenderable&1)!==K&&(this.localVisibleRenderable=this.localVisibleRenderable&2|K,this._updateFlags|=UPDATE_VISIBLE,this.renderGroup&&!this.isRenderGroupRoot&&(this.renderGroup.structureDidChange=!0),this.onUpdate())}get isRenderable(){return this.localVisibleRenderable===3&&this.rgAlpha>0}destroy(X=!1){if(this.destroyed)return;this.destroyed=!0,this.removeFromParent(),this.parent=null,this._mask=null,this._filters=null,this.effects=null,this._position=null,this._scale=null,this._pivot=null,this._skew=null,this.isRenderGroupRoot&&(this.renderGroup.proxyRenderable=null),this.emit("destroyed"),this.removeAllListeners();const K=typeof X=="boolean"?X:X==null?void 0:X.children,J=this.removeChildren(0,this.children.length);if(K)for(let Q=0;Q<J.length;++Q)J[Q].destroy(X);this.view&&(this.view.destroy(X),this.view.owner=null)}}Container.mixin(childrenHelperMixin),Container.mixin(toLocalGlobalMixin),Container.mixin(onRenderMixin),Container.mixin(measureMixin),Container.mixin(effectsMixin),Container.mixin(findMixin),Container.mixin(sortMixin),Container.mixin(cullingMixin),b$r.add(AccessibilitySystem),Container.mixin(accessibilityTarget);const browserExt={extension:{type:u$z.Environment,name:"browser",priority:-1},test:()=>!0,load:async()=>{await Promise.resolve().then(function(){return browserAll})}},webworkerExt={extension:{type:u$z.Environment,name:"webworker",priority:0},test:()=>typeof self!="undefined"&&self.WorkerGlobalScope!==void 0,load:async()=>{await Promise.resolve().then(function(){return webworkerAll})}},o$w=[];b$r.handleByNamedList(u$z.Environment,o$w),b$r.add(browserExt,webworkerExt);async function autoDetectEnvironment(Z){if(Z)for(let X=0;X<o$w.length;X++){const K=o$w[X];if(K.value.test()){await K.value.load();return}}}const BrowserAdapter={createCanvas:(Z,X)=>{const K=document.createElement("canvas");return K.width=Z,K.height=X,K},getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>{var Z;return(Z=document.baseURI)!=null?Z:window.location.href},getFontFaceSet:()=>document.fonts,fetch:(Z,X)=>fetch(Z,X),parseXML:Z=>new DOMParser().parseFromString(Z,"text/xml")};let e$8=BrowserAdapter;const DOMAdapter={get(){return e$8},set(Z){e$8=Z}};class SystemRunner{constructor(X){this.items=[],this._name=X}emit(X,K,J,Q,ee,te,re,ne){const{name:ie,items:se}=this;for(let oe=0,ae=se.length;oe<ae;oe++)se[oe][ie](X,K,J,Q,ee,te,re,ne);return this}add(X){return X[this._name]&&(this.remove(X),this.items.push(X)),this}remove(X){const K=this.items.indexOf(X);return K!==-1&&this.items.splice(K,1),this}contains(X){return this.items.indexOf(X)!==-1}removeAll(){return this.items.length=0,this}destroy(){this.removeAll(),this.items=null,this._name=null}get empty(){return this.items.length===0}get name(){return this._name}}var p$H=Object.defineProperty,l$q=Object.getOwnPropertySymbols,c$y=Object.prototype.hasOwnProperty,y$l=Object.prototype.propertyIsEnumerable,m$y=(Z,X,K)=>X in Z?p$H(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,i$v=(Z,X)=>{for(var K in X||(X={}))c$y.call(X,K)&&m$y(Z,K,X[K]);if(l$q)for(var K of l$q(X))y$l.call(X,K)&&m$y(Z,K,X[K]);return Z};const S$a=["init","destroy","contextChange","resolutionChange","reset","renderEnd","renderStart","render","update","postrender","prerender"],o$v=class{constructor(Z){this.runners=Object.create(null),this.renderPipes=Object.create(null),this._initOptions={},this._systemsHash=Object.create(null);var X;this.type=Z.type,this.name=Z.name;const K=[...S$a,...(X=Z.runners)!=null?X:[]];this._addRunners(...K),this._addSystems(Z.systems),this._addPipes(Z.renderPipes,Z.renderPipeAdaptors)}async init(Z={}){for(const X in this._systemsHash){const K=this._systemsHash[X].constructor.defaultOptions;Z=i$v(i$v({},K),Z)}Z=i$v(i$v({},o$v.defaultOptions),Z),this._roundPixels=Z.roundPixels?1:0;for(let X=0;X<this.runners.init.items.length;X++)await this.runners.init.items[X].init(Z);this._initOptions=Z}render(Z,X){let K=Z;if(K instanceof Container&&(K={container:K},X&&(deprecation(v8_0_0,"passing a second argument is deprecated, please use render options instead"),K.target=X.renderTexture)),K.target||(K.target=this.view.texture),K.target===this.view.texture&&(this._lastObjectRendered=K.container),K.clearColor){const J=Array.isArray(K.clearColor)&&K.clearColor.length===4;K.clearColor=J?K.clearColor:Color.shared.setValue(K.clearColor).toArray()}this.runners.prerender.emit(K),this.runners.renderStart.emit(K),this.runners.render.emit(K),this.runners.renderEnd.emit(K),this.runners.postrender.emit(K)}resize(Z,X,K){this.view.resize(Z,X,K)}get resolution(){return this.view.resolution}set resolution(Z){this.view.resolution=Z,this.runners.resolutionChange.emit(Z)}get width(){return this.view.texture.frame.width}get height(){return this.view.texture.frame.height}get canvas(){return this.view.canvas}get lastObjectRendered(){return this._lastObjectRendered}get renderingToScreen(){return this.renderTarget.renderingToScreen}get screen(){return this.view.screen}_addRunners(...Z){Z.forEach(X=>{this.runners[X]=new SystemRunner(X)})}_addSystems(Z){let X;for(X in Z){const K=Z[X];this._addSystem(K.value,K.name)}}_addSystem(Z,X){const K=new Z(this);if(this[X])throw new Error(`Whoops! The name "${X}" is already in use`);this[X]=K,this._systemsHash[X]=K;for(const J in this.runners)this.runners[J].add(K);return this}_addPipes(Z,X){const K=X.reduce((J,Q)=>(J[Q.name]=Q.value,J),{});Z.forEach(J=>{const Q=J.value,ee=J.name,te=K[ee];this.renderPipes[ee]=new Q(this,te?new te:null)})}destroy(Z=!1){this.runners.destroy.items.reverse(),this.runners.destroy.emit(Z),Object.values(this.runners).forEach(X=>{X.destroy()}),this._systemsHash=null,this.renderPipes=null}generateTexture(Z){return this.textureGenerator.generateTexture(Z)}get roundPixels(){return!!this._roundPixels}};let AbstractRenderer=o$v;AbstractRenderer.defaultOptions={resolution:1,failIfMajorPerformanceCaveat:!1,roundPixels:!1};let e$7;function isWebGLSupported(Z){return e$7!==void 0||(e$7=(()=>{var X;const K={stencil:!0,failIfMajorPerformanceCaveat:Z!=null?Z:AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat};try{if(!DOMAdapter.get().getWebGLRenderingContext())return!1;let J=DOMAdapter.get().createCanvas().getContext("webgl2",K);const Q=!!((X=J==null?void 0:J.getContextAttributes())!=null&&X.stencil);if(J){const ee=J.getExtension("WEBGL_lose_context");ee&&ee.loseContext()}return J=null,Q}catch(J){return!1}})()),e$7}let e$6;async function isWebGPUSupported(Z={}){return e$6!==void 0||(e$6=await(async()=>{if(!DOMAdapter.get().getNavigator().gpu)return!1;try{return await(await navigator.gpu.requestAdapter(Z)).requestDevice(),!0}catch(X){return!1}})()),e$6}var d$u=Object.defineProperty,s$C=Object.getOwnPropertySymbols,u$w=Object.prototype.hasOwnProperty,w$7=Object.prototype.propertyIsEnumerable,c$x=(Z,X,K)=>X in Z?d$u(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,i$u=(Z,X)=>{for(var K in X||(X={}))u$w.call(X,K)&&c$x(Z,K,X[K]);if(s$C)for(var K of s$C(X))w$7.call(X,K)&&c$x(Z,K,X[K]);return Z};const m$x=["webgpu","webgl","canvas"];async function autoDetectRenderer(Z){var X,K;let J=[];Z.preference?(J.push(Z.preference),m$x.forEach(re=>{re!==Z.preference&&J.push(re)})):J=m$x.slice();let Q;await autoDetectEnvironment((X=Z.manageImports)!=null?X:!0);let ee={};for(let re=0;re<J.length;re++){const ne=J[re];if(ne==="webgpu"&&await isWebGPUSupported()){const{WebGPURenderer:ie}=await Promise.resolve().then(function(){return WebGPURenderer$1});Q=ie,ee=i$u(i$u({},Z),Z.webgpu);break}else if(ne==="webgl"&&isWebGLSupported((K=Z.failIfMajorPerformanceCaveat)!=null?K:AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)){const{WebGLRenderer:ie}=await Promise.resolve().then(function(){return WebGLRenderer$1});Q=ie,ee=i$u(i$u({},Z),Z.webgl);break}else if(ne==="canvas"){ee=i$u({},Z);break}}delete ee.webgpu,delete ee.webgl;const te=new Q;return await te.init(ee),te}var p$G=Object.defineProperty,n$C=Object.getOwnPropertySymbols,c$w=Object.prototype.hasOwnProperty,l$p=Object.prototype.propertyIsEnumerable,s$B=(Z,X,K)=>X in Z?p$G(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$u=(Z,X)=>{for(var K in X||(X={}))c$w.call(X,K)&&s$B(Z,K,X[K]);if(n$C)for(var K of n$C(X))l$p.call(X,K)&&s$B(Z,K,X[K]);return Z};const i$t=class{constructor(){this.stage=new Container}async init(Z){Z=o$u({},Z),this.renderer=await autoDetectRenderer(Z),i$t._plugins.forEach(X=>{X.init.call(this,Z)})}render(){this.renderer.render({container:this.stage})}get canvas(){return this.renderer.canvas}get screen(){return this.renderer.screen}destroy(Z=!1){const X=i$t._plugins.slice(0);X.reverse(),X.forEach(K=>{K.destroy.call(this)}),this.stage.destroy(Z),this.stage=null,this.renderer.destroy(Z),this.renderer=null}};let Application=i$t;Application._plugins=[],b$r.handleByList(u$z.Application,Application._plugins);class ResizePlugin{static init(X){Object.defineProperty(this,"resizeTo",{set(K){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=K,K&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let K,J;if(this._resizeTo===globalThis.window)K=globalThis.innerWidth,J=globalThis.innerHeight;else{const{clientWidth:Q,clientHeight:ee}=this._resizeTo;K=Q,J=ee}this.renderer.resize(K,J),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=X.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=u$z.Application;var UPDATE_PRIORITY=(Z=>(Z[Z.INTERACTION=50]="INTERACTION",Z[Z.HIGH=25]="HIGH",Z[Z.NORMAL=0]="NORMAL",Z[Z.LOW=-25]="LOW",Z[Z.UTILITY=-50]="UTILITY",Z))(UPDATE_PRIORITY||{});class TickerListener{constructor(X,K=null,J=0,Q=!1){this.next=null,this.previous=null,this._destroyed=!1,this._fn=X,this._context=K,this.priority=J,this._once=Q}match(X,K=null){return this._fn===X&&this._context===K}emit(X){this._fn&&(this._context?this._fn.call(this._context,X):this._fn(X));const K=this.next;return this._once&&this.destroy(!0),this._destroyed&&(this.next=null),K}connect(X){this.previous=X,X.next&&(X.next.previous=this),this.next=X.next,X.next=this}destroy(X=!1){this._destroyed=!0,this._fn=null,this._context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const K=this.next;return this.next=X?null:K,this.previous=null,K}}const s$A=class{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new TickerListener(null,null,1/0),this.deltaMS=1/s$A.targetFPMS,this.elapsedMS=1/s$A.targetFPMS,this._tick=Z=>{this._requestId=null,this.started&&(this.update(Z),this.started&&this._requestId===null&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){this._requestId===null&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){this._requestId!==null&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(Z,X,K=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(Z,X,K))}addOnce(Z,X,K=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(Z,X,K,!0))}_addListener(Z){let X=this._head.next,K=this._head;if(!X)Z.connect(K);else{for(;X;){if(Z.priority>X.priority){Z.connect(K);break}K=X,X=X.next}Z.previous||Z.connect(K)}return this._startIfPossible(),this}remove(Z,X){let K=this._head.next;for(;K;)K.match(Z,X)?K=K.destroy():K=K.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let Z=0,X=this._head;for(;X=X.next;)Z++;return Z}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let Z=this._head.next;for(;Z;)Z=Z.destroy(!0);this._head.destroy(),this._head=null}}update(Z=performance.now()){let X;if(Z>this.lastTime){if(X=this.elapsedMS=Z-this.lastTime,X>this._maxElapsedMS&&(X=this._maxElapsedMS),X*=this.speed,this._minElapsedMS){const Q=Z-this._lastFrame|0;if(Q<this._minElapsedMS)return;this._lastFrame=Z-Q%this._minElapsedMS}this.deltaMS=X,this.deltaTime=this.deltaMS*s$A.targetFPMS;const K=this._head;let J=K.next;for(;J;)J=J.emit(this);K.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=Z}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(Z){const X=Math.min(this.maxFPS,Z),K=Math.min(Math.max(0,X)/1e3,s$A.targetFPMS);this._maxElapsedMS=1/K}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(Z){if(Z===0)this._minElapsedMS=0;else{const X=Math.max(this.minFPS,Z);this._minElapsedMS=1/(X/1e3)}}static get shared(){if(!s$A._shared){const Z=s$A._shared=new s$A;Z.autoStart=!0,Z._protected=!0}return s$A._shared}static get system(){if(!s$A._system){const Z=s$A._system=new s$A;Z.autoStart=!0,Z._protected=!0}return s$A._system}};let Ticker=s$A;Ticker.targetFPMS=.06;class TickerPlugin{static init(X){X=Object.assign({autoStart:!0,sharedTicker:!1},X),Object.defineProperty(this,"ticker",{set(K){this._ticker&&this._ticker.remove(this.render,this),this._ticker=K,K&&K.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=X.sharedTicker?Ticker.shared:new Ticker,X.autoStart&&this.start()}static destroy(){if(this._ticker){const X=this._ticker;this.ticker=null,X.destroy()}}}TickerPlugin.extension=u$z.Application,b$r.add(ResizePlugin),b$r.add(TickerPlugin);class BackgroundLoader{constructor(X,K=!1){this._loader=X,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=K}add(X){X.forEach(K=>{this._assetList.push(K)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const X=[],K=Math.min(this._assetList.length,this._maxConcurrent);for(let J=0;J<K;J++)X.push(this._assetList.pop());await this._loader.load(X),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(X){this._isActive!==X&&(this._isActive=X,X&&!this._isLoading&&this._next())}}const convertToList=(Z,X,K=!1)=>(Array.isArray(Z)||(Z=[Z]),X?Z.map(J=>typeof J=="string"||K?X(J):J):Z);class p$F{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(X){return this._cache.has(X)}get(X){return this._cache.get(X)}set(X,K){const J=convertToList(X);let Q;for(let ne=0;ne<this.parsers.length;ne++){const ie=this.parsers[ne];if(ie.test(K)){Q=ie.getCacheableAssets(J,K);break}}const ee=new Map(Object.entries(Q||{}));Q||J.forEach(ne=>{ee.set(ne,K)});const te=[...ee.keys()],re={cacheKeys:te,keys:J};J.forEach(ne=>{this._cacheMap.set(ne,re)}),te.forEach(ne=>{const ie=Q?Q[ne]:K;this._cache.has(ne)&&this._cache.get(ne),this._cache.set(ne,ee.get(ne))})}remove(X){if(!this._cacheMap.has(X))return;const K=this._cacheMap.get(X);K.cacheKeys.forEach(J=>{this._cache.delete(J)}),K.keys.forEach(J=>{this._cacheMap.delete(J)})}get parsers(){return this._parsers}}const Cache=new p$F;function f$u(Z){if(typeof Z!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(Z)}`)}function d$t(Z){return Z.split("?")[0].split("#")[0]}function b$o(Z){return Z.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function P$e(Z,X,K){return Z.replace(new RegExp(b$o(X),"g"),K)}function m$w(Z,X){let K="",J=0,Q=-1,ee=0,te=-1;for(let re=0;re<=Z.length;++re){if(re<Z.length)te=Z.charCodeAt(re);else{if(te===47)break;te=47}if(te===47){if(!(Q===re-1||ee===1))if(Q!==re-1&&ee===2){if(K.length<2||J!==2||K.charCodeAt(K.length-1)!==46||K.charCodeAt(K.length-2)!==46){if(K.length>2){const ne=K.lastIndexOf("/");if(ne!==K.length-1){ne===-1?(K="",J=0):(K=K.slice(0,ne),J=K.length-1-K.lastIndexOf("/")),Q=re,ee=0;continue}}else if(K.length===2||K.length===1){K="",J=0,Q=re,ee=0;continue}}X&&(K.length>0?K+="/..":K="..",J=2)}else K.length>0?K+=`/${Z.slice(Q+1,re)}`:K=Z.slice(Q+1,re),J=re-Q-1;Q=re,ee=0}else te===46&&ee!==-1?++ee:ee=-1}return K}const path={toPosix(Z){return P$e(Z,"\\","/")},isUrl(Z){return/^https?:/.test(this.toPosix(Z))},isDataUrl(Z){return/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(Z)},isBlobUrl(Z){return Z.startsWith("blob:")},hasProtocol(Z){return/^[^/:]+:/.test(this.toPosix(Z))},getProtocol(Z){f$u(Z),Z=this.toPosix(Z);const X=/^file:\/\/\//.exec(Z);if(X)return X[0];const K=/^[^/:]+:\/{0,2}/.exec(Z);return K?K[0]:""},toAbsolute(Z,X,K){if(f$u(Z),this.isDataUrl(Z)||this.isBlobUrl(Z))return Z;const J=d$t(this.toPosix(X!=null?X:DOMAdapter.get().getBaseUrl())),Q=d$t(this.toPosix(K!=null?K:this.rootname(J)));return Z=this.toPosix(Z),Z.startsWith("/")?path.join(Q,Z.slice(1)):this.isAbsolute(Z)?Z:this.join(J,Z)},normalize(Z){if(f$u(Z),Z.length===0)return".";if(this.isDataUrl(Z)||this.isBlobUrl(Z))return Z;Z=this.toPosix(Z);let X="";const K=Z.startsWith("/");this.hasProtocol(Z)&&(X=this.rootname(Z),Z=Z.slice(X.length));const J=Z.endsWith("/");return Z=m$w(Z,!1),Z.length>0&&J&&(Z+="/"),K?`/${Z}`:X+Z},isAbsolute(Z){return f$u(Z),Z=this.toPosix(Z),this.hasProtocol(Z)?!0:Z.startsWith("/")},join(...Z){var X;if(Z.length===0)return".";let K;for(let J=0;J<Z.length;++J){const Q=Z[J];if(f$u(Q),Q.length>0)if(K===void 0)K=Q;else{const ee=(X=Z[J-1])!=null?X:"";this.extname(ee)?K+=`/../${Q}`:K+=`/${Q}`}}return K===void 0?".":this.normalize(K)},dirname(Z){if(f$u(Z),Z.length===0)return".";Z=this.toPosix(Z);let X=Z.charCodeAt(0);const K=X===47;let J=-1,Q=!0;const ee=this.getProtocol(Z),te=Z;Z=Z.slice(ee.length);for(let re=Z.length-1;re>=1;--re)if(X=Z.charCodeAt(re),X===47){if(!Q){J=re;break}}else Q=!1;return J===-1?K?"/":this.isUrl(te)?ee+Z:ee:K&&J===1?"//":ee+Z.slice(0,J)},rootname(Z){f$u(Z),Z=this.toPosix(Z);let X="";if(Z.startsWith("/")?X="/":X=this.getProtocol(Z),this.isUrl(Z)){const K=Z.indexOf("/",X.length);K!==-1?X=Z.slice(0,K):X=Z,X.endsWith("/")||(X+="/")}return X},basename(Z,X){f$u(Z),X&&f$u(X),Z=d$t(this.toPosix(Z));let K=0,J=-1,Q=!0,ee;if(X!==void 0&&X.length>0&&X.length<=Z.length){if(X.length===Z.length&&X===Z)return"";let te=X.length-1,re=-1;for(ee=Z.length-1;ee>=0;--ee){const ne=Z.charCodeAt(ee);if(ne===47){if(!Q){K=ee+1;break}}else re===-1&&(Q=!1,re=ee+1),te>=0&&(ne===X.charCodeAt(te)?--te===-1&&(J=ee):(te=-1,J=re))}return K===J?J=re:J===-1&&(J=Z.length),Z.slice(K,J)}for(ee=Z.length-1;ee>=0;--ee)if(Z.charCodeAt(ee)===47){if(!Q){K=ee+1;break}}else J===-1&&(Q=!1,J=ee+1);return J===-1?"":Z.slice(K,J)},extname(Z){f$u(Z),Z=d$t(this.toPosix(Z));let X=-1,K=0,J=-1,Q=!0,ee=0;for(let te=Z.length-1;te>=0;--te){const re=Z.charCodeAt(te);if(re===47){if(!Q){K=te+1;break}continue}J===-1&&(Q=!1,J=te+1),re===46?X===-1?X=te:ee!==1&&(ee=1):X!==-1&&(ee=-1)}return X===-1||J===-1||ee===0||ee===1&&X===J-1&&X===K+1?"":Z.slice(X,J)},parse(Z){f$u(Z);const X={root:"",dir:"",base:"",ext:"",name:""};if(Z.length===0)return X;Z=d$t(this.toPosix(Z));let K=Z.charCodeAt(0);const J=this.isAbsolute(Z);let Q;const ee="";X.root=this.rootname(Z),J||this.hasProtocol(Z)?Q=1:Q=0;let te=-1,re=0,ne=-1,ie=!0,se=Z.length-1,oe=0;for(;se>=Q;--se){if(K=Z.charCodeAt(se),K===47){if(!ie){re=se+1;break}continue}ne===-1&&(ie=!1,ne=se+1),K===46?te===-1?te=se:oe!==1&&(oe=1):te!==-1&&(oe=-1)}return te===-1||ne===-1||oe===0||oe===1&&te===ne-1&&te===re+1?ne!==-1&&(re===0&&J?X.base=X.name=Z.slice(1,ne):X.base=X.name=Z.slice(re,ne)):(re===0&&J?(X.name=Z.slice(1,te),X.base=Z.slice(1,ne)):(X.name=Z.slice(re,te),X.base=Z.slice(re,ne)),X.ext=Z.slice(te,ne)),X.dir=this.dirname(Z),ee&&(X.dir=ee+X.dir),X},sep:"/",delimiter:":"},isSingleItem=Z=>!Array.isArray(Z);var g$q=Object.defineProperty,A$7=Object.defineProperties,y$k=Object.getOwnPropertyDescriptors,c$v=Object.getOwnPropertySymbols,R$3=Object.prototype.hasOwnProperty,_$9=Object.prototype.propertyIsEnumerable,m$v=(Z,X,K)=>X in Z?g$q(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$t=(Z,X)=>{for(var K in X||(X={}))R$3.call(X,K)&&m$v(Z,K,X[K]);if(c$v)for(var K of c$v(X))_$9.call(X,K)&&m$v(Z,K,X[K]);return Z},P$d=(Z,X)=>A$7(Z,y$k(X));class Loader{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(X,K,J)=>(this._parsersValidated=!1,X[K]=J,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(X,K){const J={promise:null,parser:null};return J.promise=(async()=>{var Q,ee;let te=null,re=null;if(K.loadParser&&(re=this._parserHash[K.loadParser]),!re){for(let ne=0;ne<this.parsers.length;ne++){const ie=this.parsers[ne];if(ie.load&&(Q=ie.test)!=null&&Q.call(ie,X,K,this)){re=ie;break}}if(!re)return null}te=await re.load(X,K,this),J.parser=re;for(let ne=0;ne<this.parsers.length;ne++){const ie=this.parsers[ne];ie.parse&&ie.parse&&await((ee=ie.testParse)==null?void 0:ee.call(ie,te,K,this))&&(te=await ie.parse(te,K,this)||te,J.parser=ie)}return te})(),J}async load(X,K){this._parsersValidated||this._validateParsers();let J=0;const Q={},ee=isSingleItem(X),te=convertToList(X,ie=>({alias:[ie],src:ie})),re=te.length,ne=te.map(async ie=>{const se=path.toAbsolute(ie.src);if(!Q[ie.src])try{this.promiseCache[se]||(this.promiseCache[se]=this._getLoadPromiseAndParser(se,ie)),Q[ie.src]=await this.promiseCache[se].promise,K&&K(++J/re)}catch(oe){throw delete this.promiseCache[se],delete Q[ie.src],new Error(`[Loader.load] Failed to load ${se}.
${oe}`)}});return await Promise.all(ne),ee?Q[te[0].src]:Q}async unload(X){const K=convertToList(X,J=>({alias:[J],src:J})).map(async J=>{var Q,ee;const te=path.toAbsolute(J.src),re=this.promiseCache[te];if(re){const ne=await re.promise;delete this.promiseCache[te],(ee=(Q=re.parser)==null?void 0:Q.unload)==null||ee.call(Q,ne,J,this)}});await Promise.all(K)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(X=>X.name).reduce((X,K)=>(K.name&&X[K.name],P$d(h$t({},X),{[K.name]:K})),{})}}function g$p(Z,X,K,J,Q){const ee=X[K];for(let te=0;te<ee.length;te++){const re=ee[te];K<X.length-1?g$p(Z.replace(J[K],re),X,K+1,J,Q):Q.push(Z.replace(J[K],re))}}function createStringVariations(Z){const X=/\{(.*?)\}/g,K=Z.match(X),J=[];if(K){const Q=[];K.forEach(ee=>{const te=ee.substring(1,ee.length-1).split(",");Q.push(te)}),g$p(Z,Q,0,K,J)}else J.push(Z);return J}var S$9=Object.defineProperty,U$6=Object.defineProperties,E$5=Object.getOwnPropertyDescriptors,B$6=Object.getOwnPropertySymbols,x$e=Object.prototype.hasOwnProperty,$$1=Object.prototype.propertyIsEnumerable,P$c=(Z,X,K)=>X in Z?S$9(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$E=(Z,X)=>{for(var K in X||(X={}))x$e.call(X,K)&&P$c(Z,K,X[K]);if(B$6)for(var K of B$6(X))$$1.call(X,K)&&P$c(Z,K,X[K]);return Z},O$8=(Z,X)=>U$6(Z,E$5(X));class Resolver{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(X,K)=>`${X}${this._bundleIdConnector}${K}`,extractAssetIdFromBundle:(X,K)=>K.replace(`${X}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(X){var K,J,Q;if(this._bundleIdConnector=(K=X.connector)!=null?K:this._bundleIdConnector,this._createBundleAssetId=(J=X.createBundleAssetId)!=null?J:this._createBundleAssetId,this._extractAssetIdFromBundle=(Q=X.extractAssetIdFromBundle)!=null?Q:this._extractAssetIdFromBundle,this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar"))!=="bar")throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...X){X.forEach(K=>{this._preferredOrder.push(K),K.priority||(K.priority=Object.keys(K.params))}),this._resolverHash={}}set basePath(X){this._basePath=X}get basePath(){return this._basePath}set rootPath(X){this._rootPath=X}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(X){if(typeof X=="string")this._defaultSearchParams=X;else{const K=X;this._defaultSearchParams=Object.keys(K).map(J=>`${encodeURIComponent(J)}=${encodeURIComponent(K[J])}`).join("&")}}getAlias(X){const{alias:K,src:J}=X;return convertToList(K||J,Q=>typeof Q=="string"?Q:Array.isArray(Q)?Q.map(ee=>{var te;return(te=ee==null?void 0:ee.src)!=null?te:ee}):Q!=null&&Q.src?Q.src:Q,!0)}addManifest(X){this._manifest,this._manifest=X,X.bundles.forEach(K=>{this.addBundle(K.name,K.assets)})}addBundle(X,K){const J=[];K.forEach(Q=>{const ee=Q.src,te=Q.alias;let re;if(typeof te=="string"){const ne=this._createBundleAssetId(X,te);J.push(ne),re=[te,ne]}else{const ne=te.map(ie=>this._createBundleAssetId(X,ie));J.push(...ne),re=[...te,...ne]}this.add(O$8(p$E({},Q),{alias:re,src:ee}))}),this._bundles[X]=J}add(X){const K=[];Array.isArray(X)?K.push(...X):K.push(X);let J;convertToList(K).forEach(Q=>{const{src:ee}=Q;let{data:te,format:re,loadParser:ne}=Q;const ie=convertToList(ee).map(ae=>typeof ae=="string"?createStringVariations(ae):Array.isArray(ae)?ae:[ae]),se=this.getAlias(Q),oe=[];ie.forEach(ae=>{ae.forEach(le=>{var ce,de,he;let pe={};if(typeof le!="object"){pe.src=le;for(let fe=0;fe<this._parsers.length;fe++){const ge=this._parsers[fe];if(ge.test(le)){pe=ge.parse(le);break}}}else te=(ce=le.data)!=null?ce:te,re=(de=le.format)!=null?de:re,ne=(he=le.loadParser)!=null?he:ne,pe=p$E(p$E({},pe),le);if(!se)throw new Error(`[Resolver] alias is undefined for this asset: ${pe.src}`);pe=this._buildResolvedAsset(pe,{aliases:se,data:te,format:re,loadParser:ne}),oe.push(pe)})}),se.forEach(ae=>{this._assetMap[ae]=oe})})}resolveBundle(X){const K=isSingleItem(X);X=convertToList(X);const J={};return X.forEach(Q=>{const ee=this._bundles[Q];if(ee){const te=this.resolve(ee),re={};for(const ne in te){const ie=te[ne];re[this._extractAssetIdFromBundle(Q,ne)]=ie}J[Q]=re}}),K?J[X[0]]:J}resolveUrl(X){const K=this.resolve(X);if(typeof X!="string"){const J={};for(const Q in K)J[Q]=K[Q].src;return J}return K.src}resolve(X){const K=isSingleItem(X);X=convertToList(X);const J={};return X.forEach(Q=>{if(!this._resolverHash[Q])if(this._assetMap[Q]){let ee=this._assetMap[Q];const te=this._getPreferredOrder(ee);te==null||te.priority.forEach(re=>{te.params[re].forEach(ne=>{const ie=ee.filter(se=>se[re]?se[re]===ne:!1);ie.length&&(ee=ie)})}),this._resolverHash[Q]=ee[0]}else this._resolverHash[Q]=this._buildResolvedAsset({alias:[Q],src:Q},{});J[Q]=this._resolverHash[Q]}),K?J[X[0]]:J}hasKey(X){return!!this._assetMap[X]}hasBundle(X){return!!this._bundles[X]}_getPreferredOrder(X){for(let K=0;K<X.length;K++){const J=X[0],Q=this._preferredOrder.find(ee=>ee.params.format.includes(J.format));if(Q)return Q}return this._preferredOrder[0]}_appendDefaultSearchParams(X){if(!this._defaultSearchParams)return X;const K=/\?/.test(X)?"&":"?";return`${X}${K}${this._defaultSearchParams}`}_buildResolvedAsset(X,K){var J,Q;const{aliases:ee,data:te,loadParser:re,format:ne}=K;return(this._basePath||this._rootPath)&&(X.src=path.toAbsolute(X.src,this._basePath,this._rootPath)),X.alias=(J=ee!=null?ee:X.alias)!=null?J:[X.src],X.src=this._appendDefaultSearchParams(X.src),X.data=p$E(p$E({},te||{}),X.data),X.loadParser=re!=null?re:X.loadParser,X.format=(Q=ne!=null?ne:X.format)!=null?Q:getUrlExtension(X.src),X}}Resolver.RETINA_PREFIX=/@([0-9\.]+)x/;function getUrlExtension(Z){return Z.split(".").pop().split("?").shift().split("#").shift()}class AssetsClass{constructor(){this._detections=[],this._initialized=!1,this.resolver=new Resolver,this.loader=new Loader,this.cache=Cache,this._backgroundLoader=new BackgroundLoader(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(X={}){var K,J,Q;if(this._initialized)return;if(this._initialized=!0,X.defaultSearchParams&&this.resolver.setDefaultSearchParams(X.defaultSearchParams),X.basePath&&(this.resolver.basePath=X.basePath),X.bundleIdentifier&&this.resolver.setBundleIdentifier(X.bundleIdentifier),X.manifest){let ne=X.manifest;typeof ne=="string"&&(ne=await this.load(ne)),this.resolver.addManifest(ne)}const ee=(J=(K=X.texturePreference)==null?void 0:K.resolution)!=null?J:1,te=typeof ee=="number"?[ee]:ee,re=await this._detectFormats({preferredFormats:(Q=X.texturePreference)==null?void 0:Q.format,skipDetections:X.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:re,resolution:te}}),X.preferences&&this.setPreferences(X.preferences)}add(X){this.resolver.add(X)}async load(X,K){this._initialized||await this.init();const J=isSingleItem(X),Q=convertToList(X).map(re=>{if(typeof re!="string"){const ne=this.resolver.getAlias(re);return ne.some(ie=>!this.resolver.hasKey(ie))&&this.add(re),Array.isArray(ne)?ne[0]:ne}return this.resolver.hasKey(re)||this.add({alias:re,src:re}),re}),ee=this.resolver.resolve(Q),te=await this._mapLoadToResolve(ee,K);return J?te[Q[0]]:te}addBundle(X,K){this.resolver.addBundle(X,K)}async loadBundle(X,K){this._initialized||await this.init();let J=!1;typeof X=="string"&&(J=!0,X=[X]);const Q=this.resolver.resolveBundle(X),ee={},te=Object.keys(Q);let re=0,ne=0;const ie=()=>{K==null||K(++re/ne)},se=te.map(oe=>{const ae=Q[oe];return ne+=Object.keys(ae).length,this._mapLoadToResolve(ae,ie).then(le=>{ee[oe]=le})});return await Promise.all(se),J?ee[X[0]]:ee}async backgroundLoad(X){this._initialized||await this.init(),typeof X=="string"&&(X=[X]);const K=this.resolver.resolve(X);this._backgroundLoader.add(Object.values(K))}async backgroundLoadBundle(X){this._initialized||await this.init(),typeof X=="string"&&(X=[X]);const K=this.resolver.resolveBundle(X);Object.values(K).forEach(J=>{this._backgroundLoader.add(Object.values(J))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(X){if(typeof X=="string")return Cache.get(X);const K={};for(let J=0;J<X.length;J++)K[J]=Cache.get(X[J]);return K}async _mapLoadToResolve(X,K){const J=[...new Set(Object.values(X))];this._backgroundLoader.active=!1;const Q=await this.loader.load(J,K);this._backgroundLoader.active=!0;const ee={};return J.forEach(te=>{const re=Q[te.src],ne=[te.src];te.alias&&ne.push(...te.alias),ne.forEach(ie=>{ee[ie]=re}),Cache.set(ne,re)}),ee}async unload(X){this._initialized||await this.init();const K=convertToList(X).map(Q=>typeof Q!="string"?Q.src:Q),J=this.resolver.resolve(K);await this._unloadFromResolved(J)}async unloadBundle(X){this._initialized||await this.init(),X=convertToList(X);const K=this.resolver.resolveBundle(X),J=Object.keys(K).map(Q=>this._unloadFromResolved(K[Q]));await Promise.all(J)}async _unloadFromResolved(X){const K=Object.values(X);K.forEach(J=>{Cache.remove(J.src)}),await this.loader.unload(K)}async _detectFormats(X){let K=[];X.preferredFormats&&(K=Array.isArray(X.preferredFormats)?X.preferredFormats:[X.preferredFormats]);for(const J of X.detections)X.skipDetections||await J.test()?K=await J.add(K):X.skipDetections||(K=await J.remove(K));return K=K.filter((J,Q)=>K.indexOf(J)===Q),K}get detections(){return this._detections}setPreferences(X){this.loader.parsers.forEach(K=>{K.config&&Object.keys(K.config).filter(J=>J in X).forEach(J=>{K.config[J]=X[J]})})}}const Assets=new AssetsClass;b$r.handleByList(u$z.LoadParser,Assets.loader.parsers).handleByList(u$z.ResolveParser,Assets.resolver.parsers).handleByList(u$z.CacheParser,Assets.cache.parsers).handleByList(u$z.DetectionParser,Assets.detections);const n$B=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],y$j=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],i$s=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],o$t=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],a$w=[],D$1=[],u$v=Math.sign;function f$t(){for(let Z=0;Z<16;Z++){const X=[];a$w.push(X);for(let K=0;K<16;K++){const J=u$v(n$B[Z]*n$B[K]+i$s[Z]*y$j[K]),Q=u$v(y$j[Z]*n$B[K]+o$t[Z]*y$j[K]),ee=u$v(n$B[Z]*i$s[K]+i$s[Z]*o$t[K]),te=u$v(y$j[Z]*i$s[K]+o$t[Z]*o$t[K]);for(let re=0;re<16;re++)if(n$B[re]===J&&y$j[re]===Q&&i$s[re]===ee&&o$t[re]===te){X.push(re);break}}}for(let Z=0;Z<16;Z++){const X=new Matrix;X.set(n$B[Z],y$j[Z],i$s[Z],o$t[Z],0,0),D$1.push(X)}}f$t();const groupD8={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:Z=>n$B[Z],uY:Z=>y$j[Z],vX:Z=>i$s[Z],vY:Z=>o$t[Z],inv:Z=>Z&8?Z&15:-Z&7,add:(Z,X)=>a$w[Z][X],sub:(Z,X)=>a$w[Z][groupD8.inv(X)],rotate180:Z=>Z^4,isVertical:Z=>(Z&3)===2,byDirection:(Z,X)=>Math.abs(Z)*2<=Math.abs(X)?X>=0?groupD8.S:groupD8.N:Math.abs(X)*2<=Math.abs(Z)?Z>0?groupD8.E:groupD8.W:X>0?Z>0?groupD8.SE:groupD8.SW:Z>0?groupD8.NE:groupD8.NW,matrixAppendRotationInv:(Z,X,K=0,J=0)=>{const Q=D$1[groupD8.inv(X)];Q.tx=K,Q.ty=J,Z.append(Q)}},NOOP=()=>{};let n$A=0;const o$s=500;function warn(...Z){n$A!==o$s&&(n$A++,n$A===o$s?console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."):console.warn("PixiJS Warning: ",...Z))}const t$g=Object.create(null),i$r=Object.create(null);function createIdFromString(Z,X){let K=i$r[Z];return K===void 0&&(t$g[X]===void 0&&(t$g[X]=1),i$r[Z]=K=t$g[X]++),K}var u$u=Object.defineProperty,h$s=Object.getOwnPropertySymbols,c$u=Object.prototype.hasOwnProperty,_$8=Object.prototype.propertyIsEnumerable,n$z=(Z,X,K)=>X in Z?u$u(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,t$f=(Z,X)=>{for(var K in X||(X={}))c$u.call(X,K)&&n$z(Z,K,X[K]);if(h$s)for(var K of h$s(X))_$8.call(X,K)&&n$z(Z,K,X[K]);return Z};const d$s=class extends eventemitter3{constructor(Z={}){var X,K,J,Q,ee,te,re;super(),this._resourceType="textureSampler",this._touched=0,this._maxAnisotropy=1,Z=t$f(t$f({},d$s.defaultOptions),Z),this.addressMode=Z.addressMode,this.addressModeU=(X=Z.addressModeU)!=null?X:this.addressModeU,this.addressModeV=(K=Z.addressModeV)!=null?K:this.addressModeV,this.addressModeW=(J=Z.addressModeW)!=null?J:this.addressModeW,this.scaleMode=Z.scaleMode,this.magFilter=(Q=Z.magFilter)!=null?Q:this.magFilter,this.minFilter=(ee=Z.minFilter)!=null?ee:this.minFilter,this.mipmapFilter=(te=Z.mipmapFilter)!=null?te:this.mipmapFilter,this.lodMinClamp=Z.lodMinClamp,this.lodMaxClamp=Z.lodMaxClamp,this.compare=Z.compare,this.maxAnisotropy=(re=Z.maxAnisotropy)!=null?re:1}set addressMode(Z){this.addressModeU=Z,this.addressModeV=Z,this.addressModeW=Z}get addressMode(){return this.addressModeU}set wrapMode(Z){deprecation("8","TextureStyle.wrapMode is now TextureStyle.addressMode"),this.addressMode=Z}get wrapMode(){return this.addressMode}set scaleMode(Z){this.magFilter=Z,this.minFilter=Z,this.mipmapFilter=Z}get scaleMode(){return this.magFilter}set maxAnisotropy(Z){this._maxAnisotropy=Math.min(Z,16),this._maxAnisotropy>1&&(this.scaleMode="linear")}get maxAnisotropy(){return this._maxAnisotropy}get _resourceId(){return this._sharedResourceId||this._generateResourceId()}update(){this.emit("change",this),this._sharedResourceId=null}_generateResourceId(){const Z=`${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;return this._sharedResourceId=createIdFromString(Z,"sampler"),this._resourceId}destroy(){this.emit("destroy",this),this.removeAllListeners()}};let TextureStyle=d$s;TextureStyle.defaultOptions={addressMode:"clamp-to-edge",scaleMode:"linear"};var M$9=Object.defineProperty,p$D=Object.getOwnPropertySymbols,_$7=Object.prototype.hasOwnProperty,b$n=Object.prototype.propertyIsEnumerable,c$t=(Z,X,K)=>X in Z?M$9(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$r=(Z,X)=>{for(var K in X||(X={}))_$7.call(X,K)&&c$t(Z,K,X[K]);if(p$D)for(var K of p$D(X))b$n.call(X,K)&&c$t(Z,K,X[K]);return Z};const n$y=class extends eventemitter3{constructor(Z={}){var X,K,J,Q;super(),this.options=Z,this.uid=uid("textureSource"),this.label="",this._resourceType="textureSource",this._resourceId=uid("textureResource"),this.uploadMethodId="unknown",this._resolution=1,this.pixelWidth=1,this.pixelHeight=1,this.width=1,this.height=1,this.sampleCount=1,this.mipLevelCount=1,this.autoGenerateMipmaps=!1,this.format="rgba8unorm",this.dimension="2d",this.antialias=!1,this.depthStencil=!0,this._touched=0,this._batchTick=-1,this._textureBindLocation=-1,Z=o$r(o$r({},n$y.defaultOptions),Z),(X=this.label)!=null||(this.label=Z.label),this.resource=Z.resource,this._resolution=Z.resolution,Z.width?this.pixelWidth=Z.width*this._resolution:this.pixelWidth=this.resource&&(K=this.resourceWidth)!=null?K:1,Z.height?this.pixelHeight=Z.height*this._resolution:this.pixelHeight=this.resource&&(J=this.resourceHeight)!=null?J:1,this.width=this.pixelWidth/this._resolution,this.height=this.pixelHeight/this._resolution,this.format=Z.format,this.dimension=Z.dimensions,this.mipLevelCount=Z.mipLevelCount,this.autoGenerateMipmaps=Z.autoGenerateMipmaps,this.sampleCount=Z.sampleCount,this.antialias=Z.antialias,this.alphaMode=Z.alphaMode;const ee=(Q=Z.style)!=null?Q:{};this.style=ee instanceof TextureStyle?ee:new TextureStyle(ee),this.destroyed=!1}get source(){return this}get style(){return this._style}set style(Z){var X,K;this.style!==Z&&((X=this._style)==null||X.off("change",this._onStyleChange,this),this._style=Z,(K=this._style)==null||K.on("change",this._onStyleChange,this),this._onStyleChange())}get addressMode(){return this._style.addressMode}set addressMode(Z){this._style.addressMode=Z}get repeatMode(){return this._style.addressMode}set repeatMode(Z){this._style.addressMode=Z}get magFilter(){return this._style.magFilter}set magFilter(Z){this._style.magFilter=Z}get minFilter(){return this._style.minFilter}set minFilter(Z){this._style.minFilter=Z}get mipmapFilter(){return this._style.mipmapFilter}set mipmapFilter(Z){this._style.mipmapFilter=Z}get lodMinClamp(){return this._style.lodMinClamp}set lodMinClamp(Z){this._style.lodMinClamp=Z}get lodMaxClamp(){return this._style.lodMaxClamp}set lodMaxClamp(Z){this._style.lodMaxClamp=Z}_onStyleChange(){this.emit("styleChange",this)}update(){this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this._style&&(this._style.destroy(),this._style=null),this.uploadMethodId=null,this.resource=null,this.removeAllListeners()}unload(){this._resourceId++,this.emit("change",this),this.emit("unload",this)}get resourceWidth(){const{resource:Z}=this;return Z.naturalWidth||Z.videoWidth||Z.displayWidth||Z.width}get resourceHeight(){const{resource:Z}=this;return Z.naturalHeight||Z.videoHeight||Z.displayHeight||Z.height}get resolution(){return this._resolution}set resolution(Z){this._resolution!==Z&&(this._resolution=Z,this.width=this.pixelWidth/Z,this.height=this.pixelHeight/Z)}resize(Z,X,K){K=K||this._resolution,Z=Z||this.width,X=X||this.height;const J=Math.round(Z*K),Q=Math.round(X*K);this.width=J/K,this.height=Q/K,this._resolution=K,!(this.pixelWidth===J&&this.pixelHeight===Q)&&(this.pixelWidth=J,this.pixelHeight=Q,this.emit("resize",this),this._resourceId++,this.emit("change",this))}updateMipmaps(){this.autoGenerateMipmaps&&this.mipLevelCount>1&&this.emit("updateMipmaps",this)}set wrapMode(Z){deprecation(v8_0_0,"TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead."),this._style.wrapMode=Z}get wrapMode(){return deprecation(v8_0_0,"TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead."),this._style.wrapMode}set scaleMode(Z){deprecation(v8_0_0,"TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead."),this._style.scaleMode=Z}get scaleMode(){return deprecation(v8_0_0,"TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead."),this._style.scaleMode}static test(Z){throw new Error("Unimplemented")}};let TextureSource=n$y;TextureSource.defaultOptions={resolution:1,format:"bgra8unorm",alphaMode:"premultiply-alpha-on-upload",dimensions:"2d",mipLevelCount:1,autoGenerateMipmaps:!1,sampleCount:1,antialias:!1,style:{}};class ImageSource extends TextureSource{constructor(X){if(X.resource&&X.resource instanceof HTMLImageElement){const K=DOMAdapter.get().createCanvas(X.resource.width,X.resource.height);K.getContext("2d").drawImage(X.resource,0,0),X.resource=K,warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.")}super(X),this.uploadMethodId="image"}static test(X){return typeof HTMLImageElement!="undefined"&&X instanceof HTMLImageElement||typeof ImageBitmap!="undefined"&&X instanceof ImageBitmap}}ImageSource.extension=u$z.TextureSource;const c$s=[];b$r.handleByList(u$z.TextureSource,c$s);function autoDetectSource(Z={}){for(let X=0;X<c$s.length;X++){const K=c$s[X];if(K.test(Z.resource))return new K(Z)}throw new Error(`Could not find a source type for resource: ${Z.resource}`)}function resourceToTexture(Z={},X=!1){const{resource:K}=Z;if(!X&&Cache.has(K))return Cache.get(K);const J=new Texture({source:autoDetectSource(Z)});return J.on("destroy",()=>{Cache.has(K)&&Cache.remove(K)}),X||Cache.set(K,J),J}const o$q=new Matrix;class TextureMatrix{constructor(X,K){this.mapCoord=new Matrix,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,typeof K=="undefined"?this.clampMargin=X.width<10?0:.5:this.clampMargin=K,this.isSimple=!1,this.texture=X}get texture(){return this._texture}set texture(X){var K;this.texture!==X&&((K=this._texture)==null||K.removeListener("update",this.update,this),this._texture=X,this._texture.addListener("update",this.update,this),this.update())}multiplyUvs(X,K){K===void 0&&(K=X);const J=this.mapCoord;for(let Q=0;Q<X.length;Q+=2){const ee=X[Q],te=X[Q+1];K[Q]=ee*J.a+te*J.c+J.tx,K[Q+1]=ee*J.b+te*J.d+J.ty}return K}update(){const X=this._texture;this._updateID++;const K=X.uvs;this.mapCoord.set(K.x1-K.x0,K.y1-K.y0,K.x3-K.x0,K.y3-K.y0,K.x0,K.y0);const J=X.orig,Q=X.trim;Q&&(o$q.set(J.width/Q.width,0,0,J.height/Q.height,-Q.x/Q.width,-Q.y/Q.height),this.mapCoord.append(o$q));const ee=X.source,te=this.uClampFrame,re=this.clampMargin/ee._resolution,ne=this.clampOffset;return te[0]=(X.frame.x+re+ne)/ee.width,te[1]=(X.frame.y+re+ne)/ee.height,te[2]=(X.frame.x+X.frame.width-re+ne)/ee.width,te[3]=(X.frame.y+X.frame.height-re+ne)/ee.height,this.uClampOffset[0]=ne/ee.pixelWidth,this.uClampOffset[1]=ne/ee.pixelHeight,this.isSimple=X.frame.width===ee.width&&X.frame.height===ee.height&&X.rotate===0,!0}}class Texture extends eventemitter3{constructor({source:X,label:K,frame:J,orig:Q,trim:ee,defaultAnchor:te,defaultBorders:re,rotate:ne}={}){var ie;if(super(),this.uid=uid("texture"),this.uvs={x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},this.frame=new Rectangle,this.noFrame=!1,this.label=K,this.source=(ie=X==null?void 0:X.source)!=null?ie:new TextureSource,this.noFrame=!J,J)this.frame.copyFrom(J);else{const{width:se,height:oe}=this._source;this.frame.width=se,this.frame.height=oe}this.orig=Q||this.frame,this.trim=ee,this.rotate=ne!=null?ne:0,this.defaultAnchor=te,this.defaultBorders=re,this.destroyed=!1,this.updateUvs()}static from(X,K=!1){return typeof X=="string"?Cache.get(X):X instanceof TextureSource?new Texture({source:X}):resourceToTexture(X,K)}set source(X){this._source&&this._source.off("resize",this.onUpdate,this),this._source=X,X.on("resize",this.onUpdate,this),this.emit("update",this)}get source(){return this._source}get textureMatrix(){return this._textureMatrix||(this._textureMatrix=new TextureMatrix(this)),this._textureMatrix}get width(){return this.orig.width}get height(){return this.orig.height}updateUvs(){const{uvs:X,frame:K}=this,{width:J,height:Q}=this._source,ee=K.x/J,te=K.y/Q,re=K.width/J,ne=K.height/Q;let ie=this.rotate;if(ie){const se=re/2,oe=ne/2,ae=ee+se,le=te+oe;ie=groupD8.add(ie,groupD8.NW),X.x0=ae+se*groupD8.uX(ie),X.y0=le+oe*groupD8.uY(ie),ie=groupD8.add(ie,2),X.x1=ae+se*groupD8.uX(ie),X.y1=le+oe*groupD8.uY(ie),ie=groupD8.add(ie,2),X.x2=ae+se*groupD8.uX(ie),X.y2=le+oe*groupD8.uY(ie),ie=groupD8.add(ie,2),X.x3=ae+se*groupD8.uX(ie),X.y3=le+oe*groupD8.uY(ie)}else X.x0=ee,X.y0=te,X.x1=ee+re,X.y1=te,X.x2=ee+re,X.y2=te+ne,X.x3=ee,X.y3=te+ne}destroy(X=!1){this._source&&X&&(this._source.destroy(),this._source=null),this._textureMatrix=null,this.destroyed=!0,this.emit("destroy",this),this.removeAllListeners()}onUpdate(){this.noFrame&&(this.frame.width=this._source.width,this.frame.height=this._source.height),this.updateUvs(),this.emit("update",this)}get baseTexture(){return deprecation(v8_0_0,"Texture.baseTexture is now Texture.source"),this._source}}Texture.EMPTY=new Texture({}),Texture.EMPTY.label="EMPTY",Texture.EMPTY.destroy=NOOP;const d$r=DOMAdapter.get().createCanvas(),h$r=1;d$r.width=h$r,d$r.height=h$r;const i$q=d$r.getContext("2d");i$q.fillStyle="#ffffff",i$q.fillRect(0,0,h$r,h$r),i$q.beginPath(),i$q.moveTo(0,0),i$q.lineTo(h$r,0),i$q.lineTo(h$r,h$r),i$q.closePath(),i$q.fillStyle="#ffffff",i$q.fill(),Texture.WHITE=new Texture({source:new ImageSource({resource:d$r,alphaMode:"premultiply-alpha-on-upload"})}),Texture.WHITE.label="WHITE",Texture.WHITE.destroy=NOOP;const cacheTextureArray={extension:u$z.CacheParser,test:Z=>Array.isArray(Z)&&Z.every(X=>X instanceof Texture),getCacheableAssets:(Z,X)=>{const K={};return Z.forEach(J=>{X.forEach((Q,ee)=>{K[J+(ee===0?"":ee+1)]=Q})}),K}};async function testImageFormat(Z){if("Image"in globalThis)return new Promise(X=>{const K=new Image;K.onload=()=>{X(!0)},K.onerror=()=>{X(!1)},K.src=Z});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const X=await(await fetch(Z)).blob();await createImageBitmap(X)}catch(X){return!1}return!0}return!1}const detectAvif={extension:{type:u$z.DetectionParser,priority:1},test:async()=>testImageFormat("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async Z=>[...Z,"avif"],remove:async Z=>Z.filter(X=>X!=="avif")},t$e=["png","jpg","jpeg"],detectDefaults={extension:{type:u$z.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async Z=>[...Z,...t$e],remove:async Z=>Z.filter(X=>!t$e.includes(X))},e$5="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function testVideoFormat(Z){return e$5?!1:document.createElement("video").canPlayType(Z)!==""}const detectMp4={extension:{type:u$z.DetectionParser,priority:0},test:async()=>testVideoFormat("video/mp4"),add:async Z=>[...Z,"mp4","m4v"],remove:async Z=>Z.filter(X=>X!=="mp4"&&X!=="m4v")},detectOgv={extension:{type:u$z.DetectionParser,priority:0},test:async()=>testVideoFormat("video/ogg"),add:async Z=>[...Z,"ogv"],remove:async Z=>Z.filter(X=>X!=="ogv")},detectWebm={extension:{type:u$z.DetectionParser,priority:0},test:async()=>testVideoFormat("video/webm"),add:async Z=>[...Z,"webm"],remove:async Z=>Z.filter(X=>X!=="webm")},detectWebp={extension:{type:u$z.DetectionParser,priority:0},test:async()=>testImageFormat("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async Z=>[...Z,"webp"],remove:async Z=>Z.filter(X=>X!=="webp")};var LoaderParserPriority=(Z=>(Z[Z.Low=0]="Low",Z[Z.Normal=1]="Normal",Z[Z.High=2]="High",Z))(LoaderParserPriority||{});const copySearchParams=(Z,X)=>{const K=X.split("?")[1];return K&&(Z+=`?${K}`),Z};class AbstractBitmapFont extends eventemitter3{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return deprecation(v8_0_0,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return deprecation(v8_0_0,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return deprecation(v8_0_0,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return deprecation(v8_0_0,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(){this.emit("destroy",this),this.removeAllListeners();for(const X in this.chars)this.chars[X].texture.destroy();this.chars=null}}class BitmapFont extends AbstractBitmapFont{constructor(X,K){var J;super();const{textures:Q,data:ee}=X;Object.keys(ee.pages).forEach(te=>{const re=ee.pages[parseInt(te,10)],ne=Q[re.id];this.pages.push({texture:ne})}),Object.keys(ee.chars).forEach(te=>{var re;const ne=ee.chars[te],ie=Q[ne.page].source,se=new Rectangle(ne.x,ne.y,ne.width,ne.height),oe=new Texture({source:ie,frame:se});this.chars[te]={id:te.codePointAt(0),xOffset:ne.xOffset,yOffset:ne.yOffset,xAdvance:ne.xAdvance,kerning:(re=ne.kerning)!=null?re:{},texture:oe}}),this.baseRenderedFontSize=ee.fontSize,this.baseMeasurementFontSize=ee.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:ee.fontSize},this.baseLineOffset=ee.baseLineOffset,this.lineHeight=ee.lineHeight,this.fontFamily=ee.fontFamily,this.distanceField=(J=ee.distanceField)!=null?J:{type:"none",range:0},this.url=K}destroy(){super.destroy();for(let X=0;X<this.pages.length;X++){const{texture:K}=this.pages[X];K.destroy(!0)}this.pages=null}}const bitmapFontTextParser={test(Z){return typeof Z=="string"&&Z.startsWith("info face=")},parse(Z){var X,K,J;const Q=Z.match(/^[a-z]+\s+.+$/gm),ee={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const ce in Q){const de=Q[ce].match(/^[a-z]+/gm)[0],he=Q[ce].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),pe={};for(const fe in he){const ge=he[fe].split("="),me=ge[0],ye=ge[1].replace(/"/gm,""),_e=parseFloat(ye),Ae=isNaN(_e)?ye:_e;pe[me]=Ae}ee[de].push(pe)}const te={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[re]=ee.info,[ne]=ee.common,[ie]=(X=ee.distanceField)!=null?X:[];ie&&(te.distanceField={range:parseInt(ie.distanceRange,10),type:ie.fieldType}),te.fontSize=parseInt(re.size,10),te.fontFamily=re.face,te.lineHeight=parseInt(ne.lineHeight,10);const se=ee.page;for(let ce=0;ce<se.length;ce++)te.pages.push({id:parseInt(se[ce].id,10)||0,file:se[ce].file});const oe={};te.baseLineOffset=te.lineHeight-parseInt(ne.base,10);const ae=ee.char;for(let ce=0;ce<ae.length;ce++){const de=ae[ce],he=parseInt(de.id,10);let pe=(J=(K=de.letter)!=null?K:de.char)!=null?J:String.fromCharCode(he);pe==="space"&&(pe=" "),oe[he]=pe,te.chars[pe]={id:he,page:parseInt(de.page,10)||0,x:parseInt(de.x,10),y:parseInt(de.y,10),width:parseInt(de.width,10),height:parseInt(de.height,10),xOffset:parseInt(de.xoffset,10),yOffset:parseInt(de.yoffset,10),xAdvance:parseInt(de.xadvance,10),kerning:{}}}const le=ee.kerning||[];for(let ce=0;ce<le.length;ce++){const de=parseInt(le[ce].first,10),he=parseInt(le[ce].second,10),pe=parseInt(le[ce].amount,10);te.chars[oe[he]].kerning[oe[de]]=pe}return te}},bitmapFontXMLParser={test(Z){const X=Z;return typeof X!="string"&&"getElementsByTagName"in X&&X.getElementsByTagName("page").length&&X.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(Z){var X,K;const J={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},Q=Z.getElementsByTagName("info")[0],ee=Z.getElementsByTagName("common")[0],te=Z.getElementsByTagName("distanceField")[0];te&&(J.distanceField={type:te.getAttribute("fieldType"),range:parseInt(te.getAttribute("distanceRange"),10)});const re=Z.getElementsByTagName("page"),ne=Z.getElementsByTagName("char"),ie=Z.getElementsByTagName("kerning");J.fontSize=parseInt(Q.getAttribute("size"),10),J.fontFamily=Q.getAttribute("face"),J.lineHeight=parseInt(ee.getAttribute("lineHeight"),10);for(let oe=0;oe<re.length;oe++)J.pages.push({id:parseInt(re[oe].getAttribute("id"),10)||0,file:re[oe].getAttribute("file")});const se={};J.baseLineOffset=J.lineHeight-parseInt(ee.getAttribute("base"),10);for(let oe=0;oe<ne.length;oe++){const ae=ne[oe],le=parseInt(ae.getAttribute("id"),10);let ce=(K=(X=ae.getAttribute("letter"))!=null?X:ae.getAttribute("char"))!=null?K:String.fromCharCode(le);ce==="space"&&(ce=" "),se[le]=ce,J.chars[ce]={id:le,page:parseInt(ae.getAttribute("page"),10)||0,x:parseInt(ae.getAttribute("x"),10),y:parseInt(ae.getAttribute("y"),10),width:parseInt(ae.getAttribute("width"),10),height:parseInt(ae.getAttribute("height"),10),xOffset:parseInt(ae.getAttribute("xoffset"),10),yOffset:parseInt(ae.getAttribute("yoffset"),10),xAdvance:parseInt(ae.getAttribute("xadvance"),10),kerning:{}}}for(let oe=0;oe<ie.length;oe++){const ae=parseInt(ie[oe].getAttribute("first"),10),le=parseInt(ie[oe].getAttribute("second"),10),ce=parseInt(ie[oe].getAttribute("amount"),10);J.chars[se[le]].kerning[se[ae]]=ce}return J}},bitmapFontXMLStringParser={test(Z){return typeof Z=="string"&&Z.includes("<font>")?bitmapFontXMLParser.test(DOMAdapter.get().parseXML(Z)):!1},parse(Z){return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(Z))}},h$q=[".xml",".fnt"],bitmapFontCachePlugin={extension:u$z.CacheParser,test:Z=>Z instanceof BitmapFont,getCacheableAssets(Z,X){const K={};return Z.forEach(J=>{K[J]=X}),K[`${X.fontFamily}-bitmap`]=X,K}},loadBitmapFont={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.Normal},test(Z){return h$q.includes(path.extname(Z).toLowerCase())},async testParse(Z){return bitmapFontTextParser.test(Z)||bitmapFontXMLStringParser.test(Z)},async parse(Z,X,K){const J=bitmapFontTextParser.test(Z)?bitmapFontTextParser.parse(Z):bitmapFontXMLStringParser.parse(Z),{src:Q}=X,{pages:ee}=J,te=[];for(let ie=0;ie<ee.length;++ie){const se=ee[ie].file;let oe=path.join(path.dirname(Q),se);oe=copySearchParams(oe,Q),te.push(oe)}const re=await K.load(te),ne=te.map(ie=>re[ie]);return new BitmapFont({data:J,textures:ne},Q)},async load(Z,X){return await(await DOMAdapter.get().fetch(Z)).text()},unload(Z){Z.destroy()}};function checkDataUrl(Z,X){if(Array.isArray(X)){for(const K of X)if(Z.startsWith(`data:${K}`))return!0;return!1}return Z.startsWith(`data:${X}`)}function checkExtension(Z,X){const K=Z.split("?")[0],J=path.extname(K).toLowerCase();return Array.isArray(X)?X.includes(J):J===X}const a$v=".json",i$p="application/json",loadJson={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.Low},name:"loadJson",test(Z){return checkDataUrl(Z,i$p)||checkExtension(Z,a$v)},async load(Z){return await(await DOMAdapter.get().fetch(Z)).json()}},n$x=".txt",i$o="text/plain",loadTxt={name:"loadTxt",extension:{type:u$z.LoadParser,priority:LoaderParserPriority.Low},test(Z){return checkDataUrl(Z,i$o)||checkExtension(Z,n$x)},async load(Z){return await(await DOMAdapter.get().fetch(Z)).text()}};var E$4=Object.defineProperty,L$6=Object.defineProperties,R$2=Object.getOwnPropertyDescriptors,p$C=Object.getOwnPropertySymbols,P$b=Object.prototype.hasOwnProperty,S$8=Object.prototype.propertyIsEnumerable,F$5=(Z,X,K)=>X in Z?E$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$p=(Z,X)=>{for(var K in X||(X={}))P$b.call(X,K)&&F$5(Z,K,X[K]);if(p$C)for(var K of p$C(X))S$8.call(X,K)&&F$5(Z,K,X[K]);return Z},y$i=(Z,X)=>L$6(Z,R$2(X));const k$3=["normal","bold","100","200","300","400","500","600","700","800","900"],C$5=[".ttf",".otf",".woff",".woff2"],D=["font/ttf","font/otf","font/woff","font/woff2"],I$7=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function getFontFamilyName(Z){const X=path.extname(Z),K=path.basename(Z,X).replace(/(-|_)/g," ").toLowerCase().split(" ").map(ee=>ee.charAt(0).toUpperCase()+ee.slice(1));let J=K.length>0;for(const ee of K)if(!ee.match(I$7)){J=!1;break}let Q=K.join(" ");return J||(Q=`"${Q.replace(/[\\"]/g,"\\$&")}"`),Q}const N$3=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function U$5(Z){return N$3.test(Z)?Z:encodeURI(Z)}const loadWebFont={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.Low},name:"loadWebFont",test(Z){return checkDataUrl(Z,D)||checkExtension(Z,C$5)},async load(Z,X){var K,J,Q,ee,te,re;const ne=DOMAdapter.get().getFontFaceSet();if(ne){const ie=[],se=(J=(K=X.data)==null?void 0:K.family)!=null?J:getFontFamilyName(Z),oe=(te=(ee=(Q=X.data)==null?void 0:Q.weights)==null?void 0:ee.filter(le=>k$3.includes(le)))!=null?te:["normal"],ae=(re=X.data)!=null?re:{};for(let le=0;le<oe.length;le++){const ce=oe[le],de=new FontFace(se,`url(${U$5(Z)})`,y$i(h$p({},ae),{weight:ce}));await de.load(),ne.add(de),ie.push(de)}return Cache.set(se,{url:Z,fontFaces:ie}),ie.length===1?ie[0]:ie}return null},unload(Z){(Array.isArray(Z)?Z:[Z]).forEach(X=>{Cache.remove(X.family),DOMAdapter.get().getFontFaceSet().delete(X)})}};var parseSvgPath=parse$1,length={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},segment=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function parse$1(Z){var X=[];return Z.replace(segment,function(K,J,Q){var ee=J.toLowerCase();for(Q=parseValues(Q),ee=="m"&&Q.length>2&&(X.push([J].concat(Q.splice(0,2))),ee="l",J=J=="m"?"l":"L");;){if(Q.length==length[ee])return Q.unshift(J),X.push(Q);if(Q.length<length[ee])throw new Error("malformed path data");X.push([J].concat(Q.splice(0,length[ee])))}}),X}var number=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function parseValues(Z){var X=Z.match(number);return X?X.map(Number):[]}function SVGToGraphicsPath(Z,X){const K=parseSvgPath(Z),J=[];let Q=null,ee=0,te=0;for(let re=0;re<K.length;re++){const ne=K[re],ie=ne[0],se=ne;switch(ie){case"M":ee=se[1],te=se[2],X.moveTo(ee,te);break;case"m":ee+=se[1],te+=se[2],X.moveTo(ee,te);break;case"H":ee=se[1],X.lineTo(ee,te);break;case"h":ee+=se[1],X.lineTo(ee,te);break;case"V":te=se[1],X.lineTo(ee,te);break;case"v":te+=se[1],X.lineTo(ee,te);break;case"L":ee=se[1],te=se[2],X.lineTo(ee,te);break;case"l":ee+=se[1],te+=se[2],X.lineTo(ee,te);break;case"C":ee=se[5],te=se[6],X.bezierCurveTo(se[1],se[2],se[3],se[4],ee,te);break;case"c":X.bezierCurveTo(ee+se[1],te+se[2],ee+se[3],te+se[4],ee+se[5],te+se[6]),ee+=se[5],te+=se[6];break;case"S":ee=se[3],te=se[4],X.bezierCurveToShort(se[1],se[2],ee,te);break;case"s":X.bezierCurveToShort(ee+se[1],te+se[2],ee+se[3],te+se[4]),ee+=se[3],te+=se[4];break;case"Q":ee=se[3],te=se[4],X.quadraticCurveTo(se[1],se[2],ee,te);break;case"q":X.quadraticCurveTo(ee+se[1],te+se[2],ee+se[3],te+se[4]),ee+=se[3],te+=se[4];break;case"T":ee=se[1],te=se[2],X.quadraticCurveToShort(ee,te);break;case"t":ee+=se[1],te+=se[2],X.quadraticCurveToShort(ee,te);break;case"A":ee=se[6],te=se[7],X.arcToSvg(se[1],se[2],se[3],se[4],se[5],ee,te);break;case"a":ee+=se[6],te+=se[7],X.arcToSvg(se[1],se[2],se[3],se[4],se[5],ee,te);break;case"Z":case"z":X.closePath(),J.length>0&&(Q=J.pop(),Q?(ee=Q.startX,te=Q.startY):(ee=0,te=0)),Q=null;break;default:}ie!=="Z"&&ie!=="z"&&Q===null&&(Q={startX:ee,startY:te},J.push(Q))}return X}class Circle{constructor(X=0,K=0,J=0){this.type="circle",this.x=X,this.y=K,this.radius=J}clone(){return new Circle(this.x,this.y,this.radius)}contains(X,K){if(this.radius<=0)return!1;const J=this.radius*this.radius;let Q=this.x-X,ee=this.y-K;return Q*=Q,ee*=ee,Q+ee<=J}strokeContains(X,K,J){if(this.radius===0)return!1;const Q=this.x-X,ee=this.y-K,te=this.radius,re=J/2,ne=Math.sqrt(Q*Q+ee*ee);return ne<te+re&&ne>te-re}getBounds(X){return X=X||new Rectangle,X.x=this.x-this.radius,X.y=this.y-this.radius,X.width=this.radius*2,X.height=this.radius*2,X}copyFrom(X){return this.x=X.x,this.y=X.y,this.radius=X.radius,this}copyTo(X){return X.copyFrom(this),X}}class Ellipse{constructor(X=0,K=0,J=0,Q=0){this.type="ellipse",this.x=X,this.y=K,this.halfWidth=J,this.halfHeight=Q}clone(){return new Ellipse(this.x,this.y,this.halfWidth,this.halfHeight)}contains(X,K){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let J=(X-this.x)/this.halfWidth,Q=(K-this.y)/this.halfHeight;return J*=J,Q*=Q,J+Q<=1}strokeContains(X,K,J){const{halfWidth:Q,halfHeight:ee}=this;if(Q<=0||ee<=0)return!1;const te=J/2,re=Q-te,ne=ee-te,ie=Q+te,se=ee+te,oe=X-this.x,ae=K-this.y,le=oe*oe/(re*re)+ae*ae/(ne*ne),ce=oe*oe/(ie*ie)+ae*ae/(se*se);return le>1&&ce<=1}getBounds(){return new Rectangle(this.x-this.halfWidth,this.y-this.halfHeight,this.halfWidth*2,this.halfHeight*2)}copyFrom(X){return this.x=X.x,this.y=X.y,this.halfWidth=X.halfWidth,this.halfHeight=X.halfHeight,this}copyTo(X){return X.copyFrom(this),X}}function squaredDistanceToLineSegment(Z,X,K,J,Q,ee){const te=Z-K,re=X-J,ne=Q-K,ie=ee-J,se=te*ne+re*ie,oe=ne*ne+ie*ie;let ae=-1;oe!==0&&(ae=se/oe);let le,ce;ae<0?(le=K,ce=J):ae>1?(le=Q,ce=ee):(le=K+ae*ne,ce=J+ae*ie);const de=Z-le,he=X-ce;return de*de+he*he}class Polygon{constructor(...X){this.type="polygon";let K=Array.isArray(X[0])?X[0]:X;if(typeof K[0]!="number"){const J=[];for(let Q=0,ee=K.length;Q<ee;Q++)J.push(K[Q].x,K[Q].y);K=J}this.points=K,this.closePath=!0}clone(){const X=this.points.slice(),K=new Polygon(X);return K.closePath=this.closePath,K}contains(X,K){let J=!1;const Q=this.points.length/2;for(let ee=0,te=Q-1;ee<Q;te=ee++){const re=this.points[ee*2],ne=this.points[ee*2+1],ie=this.points[te*2],se=this.points[te*2+1];ne>K!=se>K&&X<(ie-re)*((K-ne)/(se-ne))+re&&(J=!J)}return J}strokeContains(X,K,J){const Q=J/2,ee=Q*Q,{points:te}=this;for(let re=0;re<te.length;re+=2){const ne=te[re],ie=te[re+1],se=te[(re+2)%te.length],oe=te[(re+3)%te.length];if(squaredDistanceToLineSegment(X,K,ne,ie,se,oe)<=ee)return!0}return!1}getBounds(X){X=X||new Rectangle;const K=this.points;let J=1/0,Q=-1/0,ee=1/0,te=-1/0;for(let re=0,ne=K.length;re<ne;re+=2){const ie=K[re],se=K[re+1];J=ie<J?ie:J,Q=ie>Q?ie:Q,ee=se<ee?se:ee,te=se>te?se:te}return X.x=J,X.width=Q-J,X.y=ee,X.height=te-ee,X}copyFrom(X){return this.points=X.points.slice(),this.closePath=X.closePath,this}copyTo(X){return X.copyFrom(this),X}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const a$u=(Z,X,K,J,Q,ee)=>{const te=Z-K,re=X-J,ne=Math.sqrt(te*te+re*re);return ne>=Q-ee&&ne<=Q+ee};class RoundedRectangle{constructor(X=0,K=0,J=0,Q=0,ee=20){this.type="roundedRectangle",this.x=X,this.y=K,this.width=J,this.height=Q,this.radius=ee}getBounds(X){return X=X||new Rectangle,X.x=this.x,X.y=this.y,X.width=this.width,X.height=this.height,X}clone(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)}copyFrom(X){return this.x=X.x,this.y=X.y,this.width=X.width,this.height=X.height,this}copyTo(X){return X.copyFrom(this),X}contains(X,K){if(this.width<=0||this.height<=0)return!1;if(X>=this.x&&X<=this.x+this.width&&K>=this.y&&K<=this.y+this.height){const J=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(K>=this.y+J&&K<=this.y+this.height-J||X>=this.x+J&&X<=this.x+this.width-J)return!0;let Q=X-(this.x+J),ee=K-(this.y+J);const te=J*J;if(Q*Q+ee*ee<=te||(Q=X-(this.x+this.width-J),Q*Q+ee*ee<=te)||(ee=K-(this.y+this.height-J),Q*Q+ee*ee<=te)||(Q=X-(this.x+J),Q*Q+ee*ee<=te))return!0}return!1}strokeContains(X,K,J){const{x:Q,y:ee,width:te,height:re,radius:ne}=this,ie=J/2,se=Q+ne,oe=ee+ne,ae=te-ne*2,le=re-ne*2,ce=Q+te,de=ee+re;return(X>=Q-ie&&X<=Q+ie||X>=ce-ie&&X<=ce+ie)&&K>=oe&&K<=oe+le||(K>=ee-ie&&K<=ee+ie||K>=de-ie&&K<=de+ie)&&X>=se&&X<=se+ae?!0:X<se&&K<oe&&a$u(X,K,se,oe,ne,ie)||X>ce-ne&&K<oe&&a$u(X,K,ce-ne,oe,ne,ie)||X>ce-ne&&K>de-ne&&a$u(X,K,ce-ne,de-ne,ne,ie)||X<se&&K>de-ne&&a$u(X,K,se,de-ne,ne,ie)}}var BufferUsage=(Z=>(Z[Z.MAP_READ=1]="MAP_READ",Z[Z.MAP_WRITE=2]="MAP_WRITE",Z[Z.COPY_SRC=4]="COPY_SRC",Z[Z.COPY_DST=8]="COPY_DST",Z[Z.INDEX=16]="INDEX",Z[Z.VERTEX=32]="VERTEX",Z[Z.UNIFORM=64]="UNIFORM",Z[Z.STORAGE=128]="STORAGE",Z[Z.INDIRECT=256]="INDIRECT",Z[Z.QUERY_RESOLVE=512]="QUERY_RESOLVE",Z[Z.STATIC=1024]="STATIC",Z))(BufferUsage||{});class Buffer extends eventemitter3{constructor(X){let{data:K,size:J}=X;const{usage:Q,label:ee,shrinkToFit:te}=X;super(),this.uid=uid("buffer"),this._resourceType="buffer",this._resourceId=uid("bufferResource"),this._touched=0,this._updateID=1,this.shrinkToFit=!0,K instanceof Array&&(K=new Float32Array(K)),this._data=K,J=J!=null?J:K==null?void 0:K.byteLength;const re=!!K;this.descriptor={size:J,usage:Q,mappedAtCreation:re,label:ee},this.shrinkToFit=te!=null?te:!0}get data(){return this._data}set data(X){this.setDataWithSize(X,X.length,!0)}get static(){return!!(this.descriptor.usage&BufferUsage.STATIC)}set static(X){X?this.descriptor.usage|=BufferUsage.STATIC:this.descriptor.usage&=~BufferUsage.STATIC}setDataWithSize(X,K,J){if(this._updateID++,this._updateSize=K*X.BYTES_PER_ELEMENT,this._data===X){J&&this.emit("update",this);return}const Q=this._data;if(this._data=X,Q.length!==X.length){!this.shrinkToFit&&X.byteLength<Q.byteLength?J&&this.emit("update",this):(this.descriptor.size=X.byteLength,this._resourceId=uid("bufferResource"),this.emit("change",this));return}J&&this.emit("update",this)}update(X){this._updateSize=X!=null?X:this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.emit("destroy",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function ensureIsBuffer(Z,X){if(!(Z instanceof Buffer)){let K=X?BufferUsage.INDEX:BufferUsage.VERTEX;Z instanceof Array&&(X?(Z=new Uint32Array(Z),K=BufferUsage.INDEX|BufferUsage.COPY_DST):(Z=new Float32Array(Z),K=BufferUsage.VERTEX|BufferUsage.COPY_DST)),Z=new Buffer({data:Z,label:X?"index-mesh-buffer":"vertex-mesh-buffer",usage:K})}return Z}class Geometry extends eventemitter3{constructor(X){const{attributes:K,indexBuffer:J,topology:Q}=X;super(),this.uid=uid("geometry"),this._layoutKey=0,this.attributes=K,this.buffers=[];for(const ee in K){const te=K[ee];te.buffer=ensureIsBuffer(te.buffer,!1),this.buffers.indexOf(te.buffer)===-1&&(this.buffers.push(te.buffer),te.buffer.on("update",this.onBufferUpdate,this))}J&&(this.indexBuffer=ensureIsBuffer(J,!0),this.buffers.push(this.indexBuffer)),this.topology=Q||"triangle-list"}onBufferUpdate(){this.emit("update",this)}getAttribute(X){return this.attributes[X]}getIndex(){return this.indexBuffer}getBuffer(X){return this.getAttribute(X).buffer}getSize(){for(const X in this.attributes){const K=this.attributes[X];return this.getBuffer(X).data.length/(K.stride/4||K.size)}return 0}destroy(X=!1){this.emit("destroy",this),this.removeAllListeners(),X&&this.buffers.forEach(K=>K.destroy()),this.attributes=null,this.buffers=null}}const s$z=new Float32Array(1),n$w=new Uint32Array(1);class BatchGeometry extends Geometry{constructor(){const X=new Buffer({data:s$z,label:"attribute-batch-buffer",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST,shrinkToFit:!1}),K=new Buffer({data:n$w,label:"index-batch-buffer",usage:BufferUsage.INDEX|BufferUsage.COPY_DST,shrinkToFit:!1}),J=6*4;super({attributes:{aPosition:{buffer:X,shaderLocation:0,format:"float32x2",stride:J,offset:0},aUV:{buffer:X,shaderLocation:1,format:"float32x2",stride:J,offset:8},aColor:{buffer:X,shaderLocation:2,format:"unorm8x4",stride:J,offset:16},aTextureIdAndRound:{buffer:X,shaderLocation:3,format:"uint16x2",stride:J,offset:20}},indexBuffer:K})}}class BindGroup{constructor(X){this.resources=Object.create(null),this._dirty=!0;let K=0;for(const J in X){const Q=X[J];this.setResource(Q,K++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const X=[];let K=0;for(const J in this.resources)X[K++]=this.resources[J]._resourceId;this._key=X.join("|")}setResource(X,K){var J,Q;const ee=this.resources[K];X!==ee&&(ee&&((J=X.off)==null||J.call(X,"change",this.onResourceChange,this)),(Q=X.on)==null||Q.call(X,"change",this.onResourceChange,this),this.resources[K]=X,this._dirty=!0)}getResource(X){return this.resources[X]}_touch(X){const K=this.resources;for(const J in K)K[J]._touched=X}destroy(){var X;const K=this.resources;for(const J in K){const Q=K[J];(X=Q.off)==null||X.call(Q,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(){this._dirty=!0,this._updateKey()}}const MAX_TEXTURES=16,i$n={};function getTextureBatchBindGroup(Z,X){let K=0;for(let J=0;J<X;J++)K=K*31+Z[J].uid>>>0;return i$n[K]||m$u(Z,K)}function m$u(Z,X){const K={};let J=0;for(let ee=0;ee<MAX_TEXTURES;ee++){const te=ee<Z.length?Z[ee]:Texture.EMPTY.source;K[J++]=te.source,K[J++]=te.style}const Q=new BindGroup(K);return i$n[X]=Q,Q}class ViewableBuffer{constructor(X){typeof X=="number"?this.rawBinaryData=new ArrayBuffer(X):X instanceof Uint8Array?this.rawBinaryData=X.buffer:this.rawBinaryData=X,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(X){return this[`${X}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(X){switch(X){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${X} isn't a valid view type`)}}}function fastCopy(Z,X){const K=Z.byteLength/8|0,J=new Float64Array(Z,0,K);new Float64Array(X,0,K).set(J);const Q=Z.byteLength-K*8;if(Q>0){const ee=new Uint8Array(Z,K*8,Q);new Uint8Array(X,K*8,Q).set(ee)}}const BLEND_TO_NPM={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};var STENCIL_MODES=(Z=>(Z[Z.DISABLED=0]="DISABLED",Z[Z.RENDERING_MASK_ADD=1]="RENDERING_MASK_ADD",Z[Z.MASK_ACTIVE=2]="MASK_ACTIVE",Z[Z.RENDERING_MASK_REMOVE=3]="RENDERING_MASK_REMOVE",Z[Z.NONE=4]="NONE",Z))(STENCIL_MODES||{});function getAdjustedBlendModeBlend(Z,X){return X.alphaMode==="no-premultiply-alpha"&&BLEND_TO_NPM[Z]||Z}class BatchTextureArray{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let X=0;X<this.count;X++){const K=this.textures[X];this.textures[X]=null,this.ids[K.uid]=null}this.count=0}}var P$a=Object.defineProperty,z$2=Object.getOwnPropertySymbols,M$8=Object.prototype.hasOwnProperty,T$b=Object.prototype.propertyIsEnumerable,I$6=(Z,X,K)=>X in Z?P$a(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,B$5=(Z,X)=>{for(var K in X||(X={}))M$8.call(X,K)&&I$6(Z,K,X[K]);if(z$2)for(var K of z$2(X))T$b.call(X,K)&&I$6(Z,K,X[K]);return Z};class Batch{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.blendMode="normal",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}let d$q=0;const p$B=class{constructor(Z={}){this.uid=uid("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._vertexSize=6,this._elements=[],this._batchPool=[],this._batchPoolIndex=0,this._textureBatchPool=[],this._textureBatchPoolIndex=0,Z=B$5(B$5({},p$B.defaultOptions),Z);const{vertexSize:X,indexSize:K}=Z;this.attributeBuffer=new ViewableBuffer(X*this._vertexSize*4),this.indexBuffer=new Uint32Array(K)}begin(){this.batchIndex=0,this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0,this._batchPoolIndex=0,this._textureBatchPoolIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(Z){this._elements[this.elementSize++]=Z,Z.indexStart=this.indexSize,Z.location=this.attributeSize,Z.batcher=this,this.indexSize+=Z.indexSize,this.attributeSize+=Z.vertexSize*this._vertexSize}checkAndUpdateTexture(Z,X){const K=Z.batch.textures.ids[X._source.uid];return!K&&K!==0?!1:(Z.textureId=K,Z.texture=X,!0)}updateElement(Z){this.dirty=!0,Z.packAttributes(this.attributeBuffer.float32View,this.attributeBuffer.uint32View,Z.location,Z.textureId)}break(Z){const X=this._elements;let K=this._textureBatchPool[this._textureBatchPoolIndex++]||new BatchTextureArray;if(K.clear(),!X[this.elementStart])return;const J=X[this.elementStart];let Q=getAdjustedBlendModeBlend(J.blendMode,J.texture._source);this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const ee=this.attributeBuffer.float32View,te=this.attributeBuffer.uint32View,re=this.indexBuffer;let ne=this._batchIndexSize,ie=this._batchIndexStart,se="startBatch",oe=this._batchPool[this._batchPoolIndex++]||new Batch;for(let ae=this.elementStart;ae<this.elementSize;++ae){const le=X[ae];X[ae]=null;const ce=le.texture._source,de=getAdjustedBlendModeBlend(le.blendMode,ce),he=Q!==de;if(ce._batchTick===d$q&&!he){le.textureId=ce._textureBindLocation,ne+=le.indexSize,le.packAttributes(ee,te,le.location,le.textureId),le.packIndex(re,le.indexStart,le.location/this._vertexSize),le.batch=oe;continue}ce._batchTick=d$q,(K.count>=MAX_TEXTURES||he)&&(this._finishBatch(oe,ie,ne-ie,K,Q,Z,se),se="renderBatch",ie=ne,Q=de,K=this._textureBatchPool[this._textureBatchPoolIndex++]||new BatchTextureArray,K.clear(),oe=this._batchPool[this._batchPoolIndex++]||new Batch,++d$q),le.textureId=ce._textureBindLocation=K.count,K.ids[ce.uid]=K.count,K.textures[K.count++]=ce,le.batch=oe,ne+=le.indexSize,le.packAttributes(ee,te,le.location,le.textureId),le.packIndex(re,le.indexStart,le.location/this._vertexSize)}K.count>0&&(this._finishBatch(oe,ie,ne-ie,K,Q,Z,se),ie=ne,++d$q),this.elementStart=this.elementSize,this._batchIndexStart=ie,this._batchIndexSize=ne}_finishBatch(Z,X,K,J,Q,ee,te){Z.gpuBindGroup=null,Z.action=te,Z.batcher=this,Z.textures=J,Z.blendMode=Q,Z.start=X,Z.size=K,++d$q,ee.add(Z)}finish(Z){this.break(Z)}ensureAttributeBuffer(Z){Z*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(Z*4)}ensureIndexBuffer(Z){Z<=this.indexBuffer.length||this._resizeIndexBuffer(Z)}_resizeAttributeBuffer(Z){const X=Math.max(Z,this.attributeBuffer.size*2),K=new ViewableBuffer(X);fastCopy(this.attributeBuffer.rawBinaryData,K.rawBinaryData),this.attributeBuffer=K}_resizeIndexBuffer(Z){const X=this.indexBuffer,K=Math.max(Z,X.length*2),J=new Uint32Array(K);fastCopy(X.buffer,J.buffer),this.indexBuffer=J}destroy(){for(let Z=0;Z<this.batches.length;Z++)this.batches[Z].destroy();this.batches=null;for(let Z=0;Z<this._elements.length;Z++)this._elements[Z].batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};let Batcher=p$B;Batcher.defaultOptions={vertexSize:4,indexSize:6};function buildUvs(Z,X,K,J,Q,ee,te,re=null){let ne=0;K*=X,Q*=ee;const ie=re.a,se=re.b,oe=re.c,ae=re.d,le=re.tx,ce=re.ty;for(;ne<te;){const de=Z[K],he=Z[K+1];J[Q]=ie*de+oe*he+le,J[Q+1]=se*de+ae*he+ce,Q+=ee,K+=X,ne++}}function buildSimpleUvs(Z,X,K,J){let Q=0;for(X*=K;Q<J;)Z[X]=0,Z[X+1]=0,X+=K,Q++}function transformVertices(Z,X,K,J,Q){const ee=X.a,te=X.b,re=X.c,ne=X.d,ie=X.tx,se=X.ty;K=K||0,J=J||2,Q=Q||Z.length/J-K;let oe=K*J;for(let ae=0;ae<Q;ae++){const le=Z[oe],ce=Z[oe+1];Z[oe]=ee*le+re*ce+ie,Z[oe+1]=te*le+ne*ce+se,oe+=J}}function mixHexColors(Z,X,K){const J=Z>>16&255,Q=Z>>8&255,ee=Z&255,te=X>>16&255,re=X>>8&255,ne=X&255,ie=J+(te-J)*K,se=Q+(re-Q)*K,oe=ee+(ne-ee)*K;return(ie<<16)+(se<<8)+oe}const s$y=16777215+16777215;function mixColors(Z,X){return Z+(X<<32)!==s$y?Z===16777215?X:X===16777215?Z:mixHexColors(Z,X,.5):16777215}function mixStandardAnd32BitColors(Z,X,K){const J=(K>>24&255)/255,Q=X*J*255,ee=((Z&255)<<16)+(Z&65280)+(Z>>16&255),te=K&16777215;let re=16777215;return ee+(te<<32)!==s$y&&(ee===16777215?re=te:te===16777215?re=ee:re=mixHexColors(ee,te,.5)),re+(Q<<24)}class BatchableGraphics{constructor(){this.batcher=null,this.batch=null,this.applyTransform=!0,this.roundPixels=0}get blendMode(){return this.applyTransform?this.renderable.rgBlendMode:"normal"}packIndex(X,K,J){const Q=this.geometryData.indices;for(let ee=0;ee<this.indexSize;ee++)X[K++]=Q[ee+this.indexOffset]+J-this.vertexOffset}packAttributes(X,K,J,Q){const ee=this.geometryData,te=this.renderable,re=ee.vertices,ne=ee.uvs,ie=this.vertexOffset*2,se=(this.vertexOffset+this.vertexSize)*2,oe=this.color,ae=oe>>16|oe&65280|(oe&255)<<16;if(this.applyTransform){const le=mixColors(ae,te.rgColor)+(this.alpha*te.rgAlpha*255<<24),ce=te.rgTransform,de=Q<<16|this.roundPixels&65535,he=ce.a,pe=ce.b,fe=ce.c,ge=ce.d,me=ce.tx,ye=ce.ty;for(let _e=ie;_e<se;_e+=2){const Ae=re[_e],ve=re[_e+1];X[J]=he*Ae+fe*ve+me,X[J+1]=pe*Ae+ge*ve+ye,X[J+2]=ne[_e],X[J+3]=ne[_e+1],K[J+4]=le,K[J+5]=de,J+=6}}else{const le=ae+(this.alpha*255<<24);for(let ce=ie;ce<se;ce+=2)X[J]=re[ce],X[J+1]=re[ce+1],X[J+2]=ne[ce],X[J+3]=ne[ce+1],K[J+4]=le,K[J+5]=Q,J+=6}}get vertSize(){return this.vertexSize}copyTo(X){X.indexOffset=this.indexOffset,X.indexSize=this.indexSize,X.vertexOffset=this.vertexOffset,X.vertexSize=this.vertexSize,X.color=this.color,X.alpha=this.alpha,X.texture=this.texture,X.geometryData=this.geometryData}reset(){this.applyTransform=!0}}const buildCircle={build(Z,X){let K,J,Q,ee,te,re;if(Z.type==="circle"){const me=Z;K=me.x,J=me.y,te=re=me.radius,Q=ee=0}else if(Z.type==="ellipse"){const me=Z;K=me.x,J=me.y,te=me.halfWidth,re=me.halfHeight,Q=ee=0}else{const me=Z,ye=me.width/2,_e=me.height/2;K=me.x+ye,J=me.y+_e,te=re=Math.max(0,Math.min(me.radius,Math.min(ye,_e))),Q=ye-te,ee=_e-re}if(!(te>=0&&re>=0&&Q>=0&&ee>=0))return X;const ne=Math.ceil(2.3*Math.sqrt(te+re)),ie=ne*8+(Q?4:0)+(ee?4:0);if(ie===0)return X;if(ne===0)return X[0]=X[6]=K+Q,X[1]=X[3]=J+ee,X[2]=X[4]=K-Q,X[5]=X[7]=J-ee,X;let se=0,oe=ne*4+(Q?2:0)+2,ae=oe,le=ie,ce=Q+te,de=ee,he=K+ce,pe=K-ce,fe=J+de;if(X[se++]=he,X[se++]=fe,X[--oe]=fe,X[--oe]=pe,ee){const me=J-de;X[ae++]=pe,X[ae++]=me,X[--le]=me,X[--le]=he}for(let me=1;me<ne;me++){const ye=Math.PI/2*(me/ne),_e=Q+Math.cos(ye)*te,Ae=ee+Math.sin(ye)*re,ve=K+_e,be=K-_e,xe=J+Ae,Se=J-Ae;X[se++]=ve,X[se++]=xe,X[--oe]=xe,X[--oe]=be,X[ae++]=be,X[ae++]=Se,X[--le]=Se,X[--le]=ve}ce=Q,de=ee+re,he=K+ce,pe=K-ce,fe=J+de;const ge=J-de;return X[se++]=he,X[se++]=fe,X[--le]=ge,X[--le]=he,Q&&(X[se++]=pe,X[se++]=fe,X[--le]=ge,X[--le]=pe),X},triangulate(Z,X,K,J,Q,ee){if(Z.length===0)return;let te=0,re=0;for(let se=0;se<Z.length;se+=2)te+=Z[se],re+=Z[se+1];te/=Z.length/2,re/=Z.length/2;let ne=J;X[ne*K]=te,X[ne*K+1]=re;const ie=ne++;for(let se=0;se<Z.length;se+=2)X[ne*K]=Z[se],X[ne*K+1]=Z[se+1],se>0&&(Q[ee++]=ne,Q[ee++]=ie,Q[ee++]=ne-1),ne++;Q[ee++]=ie+1,Q[ee++]=ie,Q[ee++]=ne-1}},closePointEps=1e-4,curveEps=1e-4;function getOrientationOfPoints(Z){const X=Z.length;if(X<6)return 1;let K=0;for(let J=0,Q=Z[X-2],ee=Z[X-1];J<X;J+=2){const te=Z[J],re=Z[J+1];K+=(te-Q)*(re+ee),Q=te,ee=re}return K<0?-1:1}function ue(Z,X,K,J,Q,ee,te,re){const ne=Z-K*Q,ie=X-J*Q,se=Z+K*ee,oe=X+J*ee;let ae,le;te?(ae=J,le=-K):(ae=-J,le=K);const ce=ne+ae,de=ie+le,he=se+ae,pe=oe+le;return re.push(ce,de),re.push(he,pe),2}function W$4(Z,X,K,J,Q,ee,te,re){const ne=K-Z,ie=J-X;let se=Math.atan2(ne,ie),oe=Math.atan2(Q-Z,ee-X);re&&se<oe?se+=Math.PI*2:!re&&se>oe&&(oe+=Math.PI*2);let ae=se;const le=oe-se,ce=Math.abs(le),de=Math.sqrt(ne*ne+ie*ie),he=(15*ce*Math.sqrt(de)/Math.PI>>0)+1,pe=le/he;if(ae+=pe,re){te.push(Z,X),te.push(K,J);for(let fe=1,ge=ae;fe<he;fe++,ge+=pe)te.push(Z,X),te.push(Z+Math.sin(ge)*de,X+Math.cos(ge)*de);te.push(Z,X),te.push(Q,ee)}else{te.push(K,J),te.push(Z,X);for(let fe=1,ge=ae;fe<he;fe++,ge+=pe)te.push(Z+Math.sin(ge)*de,X+Math.cos(ge)*de),te.push(Z,X);te.push(Q,ee),te.push(Z,X)}return he*2}function buildLine(Z,X,K,J,Q,ee,te,re,ne){const ie=closePointEps;if(Z.length===0)return;const se=X;let oe=se.alignment;if(X.alignment!==.5){let Me=getOrientationOfPoints(Z);K&&(Me*=-1),oe=(oe-.5)*Me+.5}const ae=new Point(Z[0],Z[1]),le=new Point(Z[Z.length-2],Z[Z.length-1]),ce=J,de=Math.abs(ae.x-le.x)<ie&&Math.abs(ae.y-le.y)<ie;if(ce){Z=Z.slice(),de&&(Z.pop(),Z.pop(),le.set(Z[Z.length-2],Z[Z.length-1]));const Me=(ae.x+le.x)*.5,Re=(le.y+ae.y)*.5;Z.unshift(Me,Re),Z.push(Me,Re)}const he=Q,pe=Z.length/2;let fe=Z.length;const ge=he.length/2,me=se.width/2,ye=me*me,_e=se.miterLimit*se.miterLimit;let Ae=Z[0],ve=Z[1],be=Z[2],xe=Z[3],Se=0,$e=0,Ce=-(ve-xe),Te=Ae-be,Ie=0,we=0,Be=Math.sqrt(Ce*Ce+Te*Te);Ce/=Be,Te/=Be,Ce*=me,Te*=me;const De=oe,Ee=(1-De)*2,Pe=De*2;ce||(se.cap==="round"?fe+=W$4(Ae-Ce*(Ee-Pe)*.5,ve-Te*(Ee-Pe)*.5,Ae-Ce*Ee,ve-Te*Ee,Ae+Ce*Pe,ve+Te*Pe,he,!0)+2:se.cap==="square"&&(fe+=ue(Ae,ve,Ce,Te,Ee,Pe,!0,he))),he.push(Ae-Ce*Ee,ve-Te*Ee),he.push(Ae+Ce*Pe,ve+Te*Pe);for(let Me=1;Me<pe-1;++Me){Ae=Z[(Me-1)*2],ve=Z[(Me-1)*2+1],be=Z[Me*2],xe=Z[Me*2+1],Se=Z[(Me+1)*2],$e=Z[(Me+1)*2+1],Ce=-(ve-xe),Te=Ae-be,Be=Math.sqrt(Ce*Ce+Te*Te),Ce/=Be,Te/=Be,Ce*=me,Te*=me,Ie=-(xe-$e),we=be-Se,Be=Math.sqrt(Ie*Ie+we*we),Ie/=Be,we/=Be,Ie*=me,we*=me;const Re=be-Ae,Le=ve-xe,ke=be-Se,Ne=$e-xe,je=Re*ke+Le*Ne,Ve=Le*ke-Ne*Re,ze=Ve<0;if(Math.abs(Ve)<.001*Math.abs(je)){he.push(be-Ce*Ee,xe-Te*Ee),he.push(be+Ce*Pe,xe+Te*Pe),je>=0&&(se.join==="round"?fe+=W$4(be,xe,be-Ce*Ee,xe-Te*Ee,be-Ie*Ee,xe-we*Ee,he,!1)+4:fe+=2,he.push(be-Ie*Pe,xe-we*Pe),he.push(be+Ie*Ee,xe+we*Ee));continue}const Ye=(-Ce+Ae)*(-Te+xe)-(-Ce+be)*(-Te+ve),Ze=(-Ie+Se)*(-we+xe)-(-Ie+be)*(-we+$e),He=(Re*Ze-ke*Ye)/Ve,We=(Ne*Ye-Le*Ze)/Ve,Xe=(He-be)*(He-be)+(We-xe)*(We-xe),Ge=be+(He-be)*Ee,Fe=xe+(We-xe)*Ee,Oe=be-(He-be)*Pe,Ue=xe-(We-xe)*Pe,Je=Math.min(Re*Re+Le*Le,ke*ke+Ne*Ne),qe=ze?Ee:Pe,Qe=Je+qe*qe*ye;Xe<=Qe?se.join==="bevel"||Xe/ye>_e?(ze?(he.push(Ge,Fe),he.push(be+Ce*Pe,xe+Te*Pe),he.push(Ge,Fe),he.push(be+Ie*Pe,xe+we*Pe)):(he.push(be-Ce*Ee,xe-Te*Ee),he.push(Oe,Ue),he.push(be-Ie*Ee,xe-we*Ee),he.push(Oe,Ue)),fe+=2):se.join==="round"?ze?(he.push(Ge,Fe),he.push(be+Ce*Pe,xe+Te*Pe),fe+=W$4(be,xe,be+Ce*Pe,xe+Te*Pe,be+Ie*Pe,xe+we*Pe,he,!0)+4,he.push(Ge,Fe),he.push(be+Ie*Pe,xe+we*Pe)):(he.push(be-Ce*Ee,xe-Te*Ee),he.push(Oe,Ue),fe+=W$4(be,xe,be-Ce*Ee,xe-Te*Ee,be-Ie*Ee,xe-we*Ee,he,!1)+4,he.push(be-Ie*Ee,xe-we*Ee),he.push(Oe,Ue)):(he.push(Ge,Fe),he.push(Oe,Ue)):(he.push(be-Ce*Ee,xe-Te*Ee),he.push(be+Ce*Pe,xe+Te*Pe),se.join==="round"?ze?fe+=W$4(be,xe,be+Ce*Pe,xe+Te*Pe,be+Ie*Pe,xe+we*Pe,he,!0)+2:fe+=W$4(be,xe,be-Ce*Ee,xe-Te*Ee,be-Ie*Ee,xe-we*Ee,he,!1)+2:se.join==="miter"&&Xe/ye<=_e&&(ze?(he.push(Oe,Ue),he.push(Oe,Ue)):(he.push(Ge,Fe),he.push(Ge,Fe)),fe+=2),he.push(be-Ie*Ee,xe-we*Ee),he.push(be+Ie*Pe,xe+we*Pe),fe+=2)}Ae=Z[(pe-2)*2],ve=Z[(pe-2)*2+1],be=Z[(pe-1)*2],xe=Z[(pe-1)*2+1],Ce=-(ve-xe),Te=Ae-be,Be=Math.sqrt(Ce*Ce+Te*Te),Ce/=Be,Te/=Be,Ce*=me,Te*=me,he.push(be-Ce*Ee,xe-Te*Ee),he.push(be+Ce*Pe,xe+Te*Pe),ce||(se.cap==="round"?fe+=W$4(be-Ce*(Ee-Pe)*.5,xe-Te*(Ee-Pe)*.5,be-Ce*Ee,xe-Te*Ee,be+Ce*Pe,xe+Te*Pe,he,!1)+2:se.cap==="square"&&(fe+=ue(be,xe,Ce,Te,Ee,Pe,!1,he)));const Ke=curveEps*curveEps;for(let Me=ge;Me<fe+ge-2;++Me)Ae=he[Me*2],ve=he[Me*2+1],be=he[(Me+1)*2],xe=he[(Me+1)*2+1],Se=he[(Me+2)*2],$e=he[(Me+2)*2+1],!(Math.abs(Ae*(xe-$e)+be*($e-ve)+Se*(ve-xe))<Ke)&&re.push(Me,Me+1,Me+2)}var earcut_1=earcut,_default=earcut;function earcut(Z,X,K){K=K||2;var J=X&&X.length,Q=J?X[0]*K:Z.length,ee=linkedList(Z,0,Q,K,!0),te=[];if(!ee||ee.next===ee.prev)return te;var re,ne,ie,se,oe,ae,le;if(J&&(ee=eliminateHoles(Z,X,ee,K)),Z.length>80*K){re=ie=Z[0],ne=se=Z[1];for(var ce=K;ce<Q;ce+=K)oe=Z[ce],ae=Z[ce+1],oe<re&&(re=oe),ae<ne&&(ne=ae),oe>ie&&(ie=oe),ae>se&&(se=ae);le=Math.max(ie-re,se-ne),le=le!==0?32767/le:0}return earcutLinked(ee,te,K,re,ne,le,0),te}function linkedList(Z,X,K,J,Q){var ee,te;if(Q===signedArea(Z,X,K,J)>0)for(ee=X;ee<K;ee+=J)te=insertNode(ee,Z[ee],Z[ee+1],te);else for(ee=K-J;ee>=X;ee-=J)te=insertNode(ee,Z[ee],Z[ee+1],te);return te&&equals(te,te.next)&&(removeNode(te),te=te.next),te}function filterPoints(Z,X){if(!Z)return Z;X||(X=Z);var K=Z,J;do if(J=!1,!K.steiner&&(equals(K,K.next)||area(K.prev,K,K.next)===0)){if(removeNode(K),K=X=K.prev,K===K.next)break;J=!0}else K=K.next;while(J||K!==X);return X}function earcutLinked(Z,X,K,J,Q,ee,te){if(Z){!te&&ee&&indexCurve(Z,J,Q,ee);for(var re=Z,ne,ie;Z.prev!==Z.next;){if(ne=Z.prev,ie=Z.next,ee?isEarHashed(Z,J,Q,ee):isEar(Z)){X.push(ne.i/K|0),X.push(Z.i/K|0),X.push(ie.i/K|0),removeNode(Z),Z=ie.next,re=ie.next;continue}if(Z=ie,Z===re){te?te===1?(Z=cureLocalIntersections(filterPoints(Z),X,K),earcutLinked(Z,X,K,J,Q,ee,2)):te===2&&splitEarcut(Z,X,K,J,Q,ee):earcutLinked(filterPoints(Z),X,K,J,Q,ee,1);break}}}}function isEar(Z){var X=Z.prev,K=Z,J=Z.next;if(area(X,K,J)>=0)return!1;for(var Q=X.x,ee=K.x,te=J.x,re=X.y,ne=K.y,ie=J.y,se=Q<ee?Q<te?Q:te:ee<te?ee:te,oe=re<ne?re<ie?re:ie:ne<ie?ne:ie,ae=Q>ee?Q>te?Q:te:ee>te?ee:te,le=re>ne?re>ie?re:ie:ne>ie?ne:ie,ce=J.next;ce!==X;){if(ce.x>=se&&ce.x<=ae&&ce.y>=oe&&ce.y<=le&&pointInTriangle(Q,re,ee,ne,te,ie,ce.x,ce.y)&&area(ce.prev,ce,ce.next)>=0)return!1;ce=ce.next}return!0}function isEarHashed(Z,X,K,J){var Q=Z.prev,ee=Z,te=Z.next;if(area(Q,ee,te)>=0)return!1;for(var re=Q.x,ne=ee.x,ie=te.x,se=Q.y,oe=ee.y,ae=te.y,le=re<ne?re<ie?re:ie:ne<ie?ne:ie,ce=se<oe?se<ae?se:ae:oe<ae?oe:ae,de=re>ne?re>ie?re:ie:ne>ie?ne:ie,he=se>oe?se>ae?se:ae:oe>ae?oe:ae,pe=zOrder(le,ce,X,K,J),fe=zOrder(de,he,X,K,J),ge=Z.prevZ,me=Z.nextZ;ge&&ge.z>=pe&&me&&me.z<=fe;){if(ge.x>=le&&ge.x<=de&&ge.y>=ce&&ge.y<=he&&ge!==Q&&ge!==te&&pointInTriangle(re,se,ne,oe,ie,ae,ge.x,ge.y)&&area(ge.prev,ge,ge.next)>=0||(ge=ge.prevZ,me.x>=le&&me.x<=de&&me.y>=ce&&me.y<=he&&me!==Q&&me!==te&&pointInTriangle(re,se,ne,oe,ie,ae,me.x,me.y)&&area(me.prev,me,me.next)>=0))return!1;me=me.nextZ}for(;ge&&ge.z>=pe;){if(ge.x>=le&&ge.x<=de&&ge.y>=ce&&ge.y<=he&&ge!==Q&&ge!==te&&pointInTriangle(re,se,ne,oe,ie,ae,ge.x,ge.y)&&area(ge.prev,ge,ge.next)>=0)return!1;ge=ge.prevZ}for(;me&&me.z<=fe;){if(me.x>=le&&me.x<=de&&me.y>=ce&&me.y<=he&&me!==Q&&me!==te&&pointInTriangle(re,se,ne,oe,ie,ae,me.x,me.y)&&area(me.prev,me,me.next)>=0)return!1;me=me.nextZ}return!0}function cureLocalIntersections(Z,X,K){var J=Z;do{var Q=J.prev,ee=J.next.next;!equals(Q,ee)&&intersects(Q,J,J.next,ee)&&locallyInside(Q,ee)&&locallyInside(ee,Q)&&(X.push(Q.i/K|0),X.push(J.i/K|0),X.push(ee.i/K|0),removeNode(J),removeNode(J.next),J=Z=ee),J=J.next}while(J!==Z);return filterPoints(J)}function splitEarcut(Z,X,K,J,Q,ee){var te=Z;do{for(var re=te.next.next;re!==te.prev;){if(te.i!==re.i&&isValidDiagonal(te,re)){var ne=splitPolygon(te,re);te=filterPoints(te,te.next),ne=filterPoints(ne,ne.next),earcutLinked(te,X,K,J,Q,ee,0),earcutLinked(ne,X,K,J,Q,ee,0);return}re=re.next}te=te.next}while(te!==Z)}function eliminateHoles(Z,X,K,J){var Q=[],ee,te,re,ne,ie;for(ee=0,te=X.length;ee<te;ee++)re=X[ee]*J,ne=ee<te-1?X[ee+1]*J:Z.length,ie=linkedList(Z,re,ne,J,!1),ie===ie.next&&(ie.steiner=!0),Q.push(getLeftmost(ie));for(Q.sort(compareX),ee=0;ee<Q.length;ee++)K=eliminateHole(Q[ee],K);return K}function compareX(Z,X){return Z.x-X.x}function eliminateHole(Z,X){var K=findHoleBridge(Z,X);if(!K)return X;var J=splitPolygon(K,Z);return filterPoints(J,J.next),filterPoints(K,K.next)}function findHoleBridge(Z,X){var K=X,J=Z.x,Q=Z.y,ee=-1/0,te;do{if(Q<=K.y&&Q>=K.next.y&&K.next.y!==K.y){var re=K.x+(Q-K.y)*(K.next.x-K.x)/(K.next.y-K.y);if(re<=J&&re>ee&&(ee=re,te=K.x<K.next.x?K:K.next,re===J))return te}K=K.next}while(K!==X);if(!te)return null;var ne=te,ie=te.x,se=te.y,oe=1/0,ae;K=te;do J>=K.x&&K.x>=ie&&J!==K.x&&pointInTriangle(Q<se?J:ee,Q,ie,se,Q<se?ee:J,Q,K.x,K.y)&&(ae=Math.abs(Q-K.y)/(J-K.x),locallyInside(K,Z)&&(ae<oe||ae===oe&&(K.x>te.x||K.x===te.x&&sectorContainsSector(te,K)))&&(te=K,oe=ae)),K=K.next;while(K!==ne);return te}function sectorContainsSector(Z,X){return area(Z.prev,Z,X.prev)<0&&area(X.next,Z,Z.next)<0}function indexCurve(Z,X,K,J){var Q=Z;do Q.z===0&&(Q.z=zOrder(Q.x,Q.y,X,K,J)),Q.prevZ=Q.prev,Q.nextZ=Q.next,Q=Q.next;while(Q!==Z);Q.prevZ.nextZ=null,Q.prevZ=null,sortLinked(Q)}function sortLinked(Z){var X,K,J,Q,ee,te,re,ne,ie=1;do{for(K=Z,Z=null,ee=null,te=0;K;){for(te++,J=K,re=0,X=0;X<ie&&(re++,J=J.nextZ,!!J);X++);for(ne=ie;re>0||ne>0&&J;)re!==0&&(ne===0||!J||K.z<=J.z)?(Q=K,K=K.nextZ,re--):(Q=J,J=J.nextZ,ne--),ee?ee.nextZ=Q:Z=Q,Q.prevZ=ee,ee=Q;K=J}ee.nextZ=null,ie*=2}while(te>1);return Z}function zOrder(Z,X,K,J,Q){return Z=(Z-K)*Q|0,X=(X-J)*Q|0,Z=(Z|Z<<8)&16711935,Z=(Z|Z<<4)&252645135,Z=(Z|Z<<2)&858993459,Z=(Z|Z<<1)&1431655765,X=(X|X<<8)&16711935,X=(X|X<<4)&252645135,X=(X|X<<2)&858993459,X=(X|X<<1)&1431655765,Z|X<<1}function getLeftmost(Z){var X=Z,K=Z;do(X.x<K.x||X.x===K.x&&X.y<K.y)&&(K=X),X=X.next;while(X!==Z);return K}function pointInTriangle(Z,X,K,J,Q,ee,te,re){return(Q-te)*(X-re)>=(Z-te)*(ee-re)&&(Z-te)*(J-re)>=(K-te)*(X-re)&&(K-te)*(ee-re)>=(Q-te)*(J-re)}function isValidDiagonal(Z,X){return Z.next.i!==X.i&&Z.prev.i!==X.i&&!intersectsPolygon(Z,X)&&(locallyInside(Z,X)&&locallyInside(X,Z)&&middleInside(Z,X)&&(area(Z.prev,Z,X.prev)||area(Z,X.prev,X))||equals(Z,X)&&area(Z.prev,Z,Z.next)>0&&area(X.prev,X,X.next)>0)}function area(Z,X,K){return(X.y-Z.y)*(K.x-X.x)-(X.x-Z.x)*(K.y-X.y)}function equals(Z,X){return Z.x===X.x&&Z.y===X.y}function intersects(Z,X,K,J){var Q=sign(area(Z,X,K)),ee=sign(area(Z,X,J)),te=sign(area(K,J,Z)),re=sign(area(K,J,X));return!!(Q!==ee&&te!==re||Q===0&&onSegment(Z,K,X)||ee===0&&onSegment(Z,J,X)||te===0&&onSegment(K,Z,J)||re===0&&onSegment(K,X,J))}function onSegment(Z,X,K){return X.x<=Math.max(Z.x,K.x)&&X.x>=Math.min(Z.x,K.x)&&X.y<=Math.max(Z.y,K.y)&&X.y>=Math.min(Z.y,K.y)}function sign(Z){return Z>0?1:Z<0?-1:0}function intersectsPolygon(Z,X){var K=Z;do{if(K.i!==Z.i&&K.next.i!==Z.i&&K.i!==X.i&&K.next.i!==X.i&&intersects(K,K.next,Z,X))return!0;K=K.next}while(K!==Z);return!1}function locallyInside(Z,X){return area(Z.prev,Z,Z.next)<0?area(Z,X,Z.next)>=0&&area(Z,Z.prev,X)>=0:area(Z,X,Z.prev)<0||area(Z,Z.next,X)<0}function middleInside(Z,X){var K=Z,J=!1,Q=(Z.x+X.x)/2,ee=(Z.y+X.y)/2;do K.y>ee!=K.next.y>ee&&K.next.y!==K.y&&Q<(K.next.x-K.x)*(ee-K.y)/(K.next.y-K.y)+K.x&&(J=!J),K=K.next;while(K!==Z);return J}function splitPolygon(Z,X){var K=new Node$1(Z.i,Z.x,Z.y),J=new Node$1(X.i,X.x,X.y),Q=Z.next,ee=X.prev;return Z.next=X,X.prev=Z,K.next=Q,Q.prev=K,J.next=K,K.prev=J,ee.next=J,J.prev=ee,J}function insertNode(Z,X,K,J){var Q=new Node$1(Z,X,K);return J?(Q.next=J.next,Q.prev=J,J.next.prev=Q,J.next=Q):(Q.prev=Q,Q.next=Q),Q}function removeNode(Z){Z.next.prev=Z.prev,Z.prev.next=Z.next,Z.prevZ&&(Z.prevZ.nextZ=Z.nextZ),Z.nextZ&&(Z.nextZ.prevZ=Z.prevZ)}function Node$1(Z,X,K){this.i=Z,this.x=X,this.y=K,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}earcut.deviation=function(Z,X,K,J){var Q=X&&X.length,ee=Q?X[0]*K:Z.length,te=Math.abs(signedArea(Z,0,ee,K));if(Q)for(var re=0,ne=X.length;re<ne;re++){var ie=X[re]*K,se=re<ne-1?X[re+1]*K:Z.length;te-=Math.abs(signedArea(Z,ie,se,K))}var oe=0;for(re=0;re<J.length;re+=3){var ae=J[re]*K,le=J[re+1]*K,ce=J[re+2]*K;oe+=Math.abs((Z[ae]-Z[ce])*(Z[le+1]-Z[ae+1])-(Z[ae]-Z[le])*(Z[ce+1]-Z[ae+1]))}return te===0&&oe===0?0:Math.abs((oe-te)/te)};function signedArea(Z,X,K,J){for(var Q=0,ee=X,te=K-J;ee<K;ee+=J)Q+=(Z[te]-Z[ee])*(Z[ee+1]+Z[te+1]),te=ee;return Q}earcut.flatten=function(Z){for(var X=Z[0][0].length,K={vertices:[],holes:[],dimensions:X},J=0,Q=0;Q<Z.length;Q++){for(var ee=0;ee<Z[Q].length;ee++)for(var te=0;te<X;te++)K.vertices.push(Z[Q][ee][te]);Q>0&&(J+=Z[Q-1].length,K.holes.push(J))}return K},earcut_1.default=_default;function triangulateWithHoles(Z,X,K,J,Q,ee,te){const re=earcut_1(Z,X,2);if(!re)return;for(let ie=0;ie<re.length;ie+=3)ee[te++]=re[ie]+Q,ee[te++]=re[ie+1]+Q,ee[te++]=re[ie+2]+Q;let ne=Q*J;for(let ie=0;ie<Z.length;ie+=2)K[ne]=Z[ie],K[ne+1]=Z[ie+1],ne+=J}const l$o=[],buildPolygon={build(Z,X){for(let K=0;K<Z.points.length;K++)X[K]=Z.points[K];return X},triangulate(Z,X,K,J,Q,ee){triangulateWithHoles(Z,l$o,X,K,J,Q,ee)}},buildRectangle={build(Z,X){const K=Z,J=K.x,Q=K.y,ee=K.width,te=K.height;return ee>=0&&te>=0&&(X[0]=J,X[1]=Q,X[2]=J+ee,X[3]=Q,X[4]=J+ee,X[5]=Q+te,X[6]=J,X[7]=Q+te),X},triangulate(Z,X,K,J,Q,ee){let te=0;J*=K,X[J+te]=Z[0],X[J+te+1]=Z[1],te+=K,X[J+te]=Z[2],X[J+te+1]=Z[3],te+=K,X[J+te]=Z[6],X[J+te+1]=Z[7],te+=K,X[J+te]=Z[4],X[J+te+1]=Z[5],te+=K;const re=J/K;Q[ee++]=re,Q[ee++]=re+1,Q[ee++]=re+2,Q[ee++]=re+1,Q[ee++]=re+3,Q[ee++]=re+2}},buildTriangle={build(Z,X){return X[0]=Z.x,X[1]=Z.y,X[2]=Z.x2,X[3]=Z.y2,X[4]=Z.x3,X[5]=Z.y3,X},triangulate(Z,X,K,J,Q,ee){let te=0;J*=K,X[J+te]=Z[0],X[J+te+1]=Z[1],te+=K,X[J+te]=Z[2],X[J+te+1]=Z[3],te+=K,X[J+te]=Z[4],X[J+te+1]=Z[5];const re=J/K;Q[ee++]=re,Q[ee++]=re+1,Q[ee++]=re+2}},y$h={rectangle:buildRectangle,polygon:buildPolygon,triangle:buildTriangle,circle:buildCircle,ellipse:buildCircle,roundedRectangle:buildCircle},M$7=new Rectangle;function buildContextBatches(Z){const X={vertices:[],uvs:[],indices:[]},K=[];for(let J=0;J<Z.instructions.length;J++){const Q=Z.instructions[J];if(Q.action==="texture")W$3(Q.data,K,X);else if(Q.action==="fill"||Q.action==="stroke"){const ee=Q.action==="stroke",te=Q.data.path.shapePath,re=Q.data.style,ne=Q.data.hole;ee&&ne&&I$5(ne.shapePath,re,null,!0,K,X),I$5(te,re,ne,ee,K,X)}}return K}function W$3(Z,X,K){const{vertices:J,uvs:Q,indices:ee}=K,te=ee.length,re=J.length/2,ne=[],ie=y$h.rectangle,se=M$7,oe=Z.image;se.x=Z.dx,se.y=Z.dy,se.width=Z.dw,se.height=Z.dh;const ae=Z.transform;ie.build(se,ne),ae&&transformVertices(ne,ae),ie.triangulate(ne,J,2,re,ee,te);const le=oe.uvs;Q.push(le.x0,le.y0,le.x1,le.y1,le.x3,le.y3,le.x2,le.y2);const ce=BigPool.get(BatchableGraphics);ce.indexOffset=te,ce.indexSize=ee.length-te,ce.vertexOffset=re,ce.vertexSize=J.length/2-re,ce.color=Z.style,ce.alpha=Z.alpha,ce.texture=oe,ce.geometryData=K,X.push(ce)}function I$5(Z,X,K,J,Q,ee){const{vertices:te,uvs:re,indices:ne}=ee,ie=Z.shapePrimitives.length-1;Z.shapePrimitives.forEach(({shape:se,transform:oe},ae)=>{var le;const ce=ne.length,de=te.length/2,he=[],pe=y$h[se.type];if(pe.build(se,he),oe&&transformVertices(he,oe),J){const ye=(le=se.closePath)!=null?le:!0;buildLine(he,X,!1,ye,te,2,de,ne,ce)}else if(K&&ie===ae){ie!==0&&console.warn("[Pixi Graphics] only the last shape have be cut out");const ye=[],_e=he.slice();L$5(K.shapePath).forEach(Ae=>{ye.push(_e.length/2),_e.push(...Ae)}),triangulateWithHoles(_e,ye,te,2,de,ne,ce)}else pe.triangulate(he,te,2,de,ne,ce);const fe=re.length/2,ge=X.texture;if(ge!==Texture.WHITE){const ye=X.matrix;oe&&ye.append(oe.clone().invert()),buildUvs(te,2,de,re,fe,2,te.length/2-de,ye)}else buildSimpleUvs(re,fe,2,te.length/2-de);const me=BigPool.get(BatchableGraphics);me.indexOffset=ce,me.indexSize=ne.length-ce,me.vertexOffset=de,me.vertexSize=te.length/2-de,me.color=X.color,me.alpha=X.alpha,me.texture=ge,me.geometryData=ee,Q.push(me)})}function L$5(Z){if(!Z)return[];const X=Z.shapePrimitives,K=[];for(let J=0;J<X.length;J++){const Q=X[J].shape,ee=[];y$h[Q.type].build(Q,ee),K.push(ee)}return K}class GpuGraphicsContext{}class GraphicsContextRenderData{constructor(){this.geometry=new BatchGeometry,this.instructions=new InstructionSet}init(){this.instructions.reset()}}const c$r=class{constructor(){this._activeBatchers=[],this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),this._needsContextNeedsRebuild=[]}init(Z){var X;c$r.defaultOptions.bezierSmoothness=(X=Z==null?void 0:Z.bezierSmoothness)!=null?X:c$r.defaultOptions.bezierSmoothness}prerender(){this._returnActiveBatchers()}getContextRenderData(Z){return this._graphicsDataContextHash[Z.uid]||this._initContextRenderData(Z)}updateGpuContext(Z){let X=this._gpuContextHash[Z.uid]||this._initContext(Z);if(Z.dirty){X?this._cleanGraphicsContextData(Z):X=this._initContext(Z);const K=buildContextBatches(Z);let J=0;const Q=Z.batchMode;let ee=!0;if(Z.customShader||Q==="no-batch")ee=!1;else if(Q==="auto"){for(let te=0;te<K.length;te++)if(J+=K[te].vertexSize,J>400){ee=!1;break}}X=this._gpuContextHash[Z.uid]={isBatchable:ee,batches:K},Z.dirty=!1}return X}getGpuContext(Z){return this._gpuContextHash[Z.uid]||this._initContext(Z)}_returnActiveBatchers(){for(let Z=0;Z<this._activeBatchers.length;Z++)BigPool.return(this._activeBatchers[Z]);this._activeBatchers.length=0}_initContextRenderData(Z){const X=BigPool.get(GraphicsContextRenderData),K=this._gpuContextHash[Z.uid].batches;let J=0,Q=0;K.forEach(ne=>{ne.applyTransform=!1,J+=ne.geometryData.vertices.length,Q+=ne.geometryData.indices.length});const ee=BigPool.get(Batcher);this._activeBatchers.push(ee),ee.ensureAttributeBuffer(J),ee.ensureIndexBuffer(Q),ee.begin();for(let ne=0;ne<K.length;ne++){const ie=K[ne];ee.add(ie)}ee.finish(X.instructions);const te=X.geometry;te.indexBuffer.setDataWithSize(ee.indexBuffer,ee.indexSize,!0),te.buffers[0].setDataWithSize(ee.attributeBuffer.float32View,ee.attributeSize,!0);const re=ee.batches;for(let ne=0;ne<re.length;ne++){const ie=re[ne];ie.bindGroup=getTextureBatchBindGroup(ie.textures.textures,ie.textures.count)}return this._graphicsDataContextHash[Z.uid]=X,X}_initContext(Z){const X=new GpuGraphicsContext;return this._gpuContextHash[Z.uid]=X,Z.on("update",this.onGraphicsContextUpdate,this),Z.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[Z.uid]}onGraphicsContextUpdate(Z){this._needsContextNeedsRebuild.push(Z)}onGraphicsContextDestroy(Z){this._cleanGraphicsContextData(Z),this._gpuContextHash[Z.uid]=null}_cleanGraphicsContextData(Z){const X=this._gpuContextHash[Z.uid];X.isBatchable||this._graphicsDataContextHash[Z.uid]&&(BigPool.return(this.getContextRenderData(Z)),this._graphicsDataContextHash[Z.uid]=null),X.batches&&X.batches.forEach(K=>{BigPool.return(K)})}destroy(){for(const Z of this._needsContextNeedsRebuild)this._cleanGraphicsContextData(Z),this._gpuContextHash[Z.uid]=null;this._needsContextNeedsRebuild.length=0}};let GraphicsContextSystem=c$r;GraphicsContextSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"graphicsContext"},GraphicsContextSystem.defaultOptions={bezierSmoothness:.5};const U$4=8,g$o=11920929e-14,j$1=1,C$4=.01,E$3=0,I$4=0;function buildAdaptiveBezier(Z,X,K,J,Q,ee,te,re,ne,ie){const se=Math.min(.99,Math.max(0,ie!=null?ie:GraphicsContextSystem.defaultOptions.bezierSmoothness));let oe=(j$1-se)/1;return oe*=oe,k$2(X,K,J,Q,ee,te,re,ne,Z,oe),Z}function k$2(Z,X,K,J,Q,ee,te,re,ne,ie){N$2(Z,X,K,J,Q,ee,te,re,ne,ie,0),ne.push(te,re)}function N$2(Z,X,K,J,Q,ee,te,re,ne,ie,se){if(se>U$4)return;const oe=Math.PI,ae=(Z+K)/2,le=(X+J)/2,ce=(K+Q)/2,de=(J+ee)/2,he=(Q+te)/2,pe=(ee+re)/2,fe=(ae+ce)/2,ge=(le+de)/2,me=(ce+he)/2,ye=(de+pe)/2,_e=(fe+me)/2,Ae=(ge+ye)/2;if(se>0){let ve=te-Z,be=re-X;const xe=Math.abs((K-te)*be-(J-re)*ve),Se=Math.abs((Q-te)*be-(ee-re)*ve);let $e,Ce;if(xe>g$o&&Se>g$o){if((xe+Se)*(xe+Se)<=ie*(ve*ve+be*be)){if(E$3<C$4){ne.push(_e,Ae);return}const Te=Math.atan2(ee-J,Q-K);if($e=Math.abs(Te-Math.atan2(J-X,K-Z)),Ce=Math.abs(Math.atan2(re-ee,te-Q)-Te),$e>=oe&&($e=2*oe-$e),Ce>=oe&&(Ce=2*oe-Ce),$e+Ce<E$3){ne.push(_e,Ae);return}if(I$4!==0){if($e>I$4){ne.push(K,J);return}if(Ce>I$4){ne.push(Q,ee);return}}}}else if(xe>g$o){if(xe*xe<=ie*(ve*ve+be*be)){if(E$3<C$4){ne.push(_e,Ae);return}if($e=Math.abs(Math.atan2(ee-J,Q-K)-Math.atan2(J-X,K-Z)),$e>=oe&&($e=2*oe-$e),$e<E$3){ne.push(K,J),ne.push(Q,ee);return}if(I$4!==0&&$e>I$4){ne.push(K,J);return}}}else if(Se>g$o){if(Se*Se<=ie*(ve*ve+be*be)){if(E$3<C$4){ne.push(_e,Ae);return}if($e=Math.abs(Math.atan2(re-ee,te-Q)-Math.atan2(ee-J,Q-K)),$e>=oe&&($e=2*oe-$e),$e<E$3){ne.push(K,J),ne.push(Q,ee);return}if(I$4!==0&&$e>I$4){ne.push(Q,ee);return}}}else if(ve=_e-(Z+te)/2,be=Ae-(X+re)/2,ve*ve+be*be<=ie){ne.push(_e,Ae);return}}N$2(Z,X,ae,le,fe,ge,_e,Ae,ne,ie,se+1),N$2(_e,Ae,me,ye,he,pe,te,re,ne,ie,se+1)}const L$4=8,N$1=11920929e-14,O$7=1,P$9=.01,E$2=0;function buildAdaptiveQuadratic(Z,X,K,J,Q,ee,te,re){const ne=Math.min(.99,Math.max(0,re!=null?re:GraphicsContextSystem.defaultOptions.bezierSmoothness));let ie=(O$7-ne)/1;return ie*=ie,T$a(X,K,J,Q,ee,te,Z,ie),Z}function T$a(Z,X,K,J,Q,ee,te,re){d$p(te,Z,X,K,J,Q,ee,re,0),te.push(Q,ee)}function d$p(Z,X,K,J,Q,ee,te,re,ne){if(ne>L$4)return;const ie=Math.PI,se=(X+J)/2,oe=(K+Q)/2,ae=(J+ee)/2,le=(Q+te)/2,ce=(se+ae)/2,de=(oe+le)/2;let he=ee-X,pe=te-K;const fe=Math.abs((J-ee)*pe-(Q-te)*he);if(fe>N$1){if(fe*fe<=re*(he*he+pe*pe)){if(E$2<P$9){Z.push(ce,de);return}let ge=Math.abs(Math.atan2(te-Q,ee-J)-Math.atan2(Q-K,J-X));if(ge>=ie&&(ge=2*ie-ge),ge<E$2){Z.push(ce,de);return}}}else if(he=ce-(X+ee)/2,pe=de-(K+te)/2,he*he+pe*pe<=re){Z.push(ce,de);return}d$p(Z,X,K,se,oe,ce,de,re,ne+1),d$p(Z,ce,de,ae,le,ee,te,re,ne+1)}function buildArc(Z,X,K,J,Q,ee,te,re){let ne=Math.abs(Q-ee);(!te&&Q>ee||te&&ee>Q)&&(ne=2*Math.PI-ne),re=re||Math.max(6,Math.floor(6*Math.pow(J,.3333333333333333)*(ne/Math.PI))),re=Math.max(re,3);let ie=ne/re,se=Q;ie*=te?-1:1;for(let oe=0;oe<re+1;oe++){const ae=Math.cos(se),le=Math.sin(se),ce=X+ae*J,de=K+le*J;Z.push(ce,de),se+=ie}}function buildArcTo(Z,X,K,J,Q,ee){const te=Z[Z.length-2],re=Z[Z.length-1]-K,ne=te-X,ie=Q-K,se=J-X,oe=Math.abs(re*se-ne*ie);if(oe<1e-8||ee===0){(Z[Z.length-2]!==X||Z[Z.length-1]!==K)&&Z.push(X,K);return}const ae=re*re+ne*ne,le=ie*ie+se*se,ce=re*ie+ne*se,de=ee*Math.sqrt(ae)/oe,he=ee*Math.sqrt(le)/oe,pe=de*ce/ae,fe=he*ce/le,ge=de*se+he*ne,me=de*ie+he*re,ye=ne*(he+pe),_e=re*(he+pe),Ae=se*(de+fe),ve=ie*(de+fe),be=Math.atan2(_e-me,ye-ge),xe=Math.atan2(ve-me,Ae-ge);buildArc(Z,ge+X,me+K,ee,be,xe,ne*ie>se*re)}const A$6=Math.PI*2,z$1={centerX:0,centerY:0,ang1:0,ang2:0},B$4=({x:Z,y:X},K,J,Q,ee,te,re,ne)=>{Z*=K,X*=J;const ie=Q*Z-ee*X,se=ee*Z+Q*X;return ne.x=ie+te,ne.y=se+re,ne};function G$2(Z,X){const K=X===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(X/4),J=X===1.5707963267948966?.551915024494:K,Q=Math.cos(Z),ee=Math.sin(Z),te=Math.cos(Z+X),re=Math.sin(Z+X);return[{x:Q-ee*J,y:ee+Q*J},{x:te+re*J,y:re-te*J},{x:te,y:re}]}const j=(Z,X,K,J)=>{const Q=Z*J-X*K<0?-1:1;let ee=Z*K+X*J;return ee>1&&(ee=1),ee<-1&&(ee=-1),Q*Math.acos(ee)},H$5=(Z,X,K,J,Q,ee,te,re,ne,ie,se,oe,ae)=>{const le=Math.pow(Q,2),ce=Math.pow(ee,2),de=Math.pow(se,2),he=Math.pow(oe,2);let pe=le*ce-le*he-ce*de;pe<0&&(pe=0),pe/=le*he+ce*de,pe=Math.sqrt(pe)*(te===re?-1:1);const fe=pe*Q/ee*oe,ge=pe*-ee/Q*se,me=ie*fe-ne*ge+(Z+K)/2,ye=ne*fe+ie*ge+(X+J)/2,_e=(se-fe)/Q,Ae=(oe-ge)/ee,ve=(-se-fe)/Q,be=(-oe-ge)/ee,xe=j(1,0,_e,Ae);let Se=j(_e,Ae,ve,be);re===0&&Se>0&&(Se-=A$6),re===1&&Se<0&&(Se+=A$6),ae.centerX=me,ae.centerY=ye,ae.ang1=xe,ae.ang2=Se};function buildArcToSvg(Z,X,K,J,Q,ee,te,re=0,ne=0,ie=0){if(ee===0||te===0)return;const se=Math.sin(re*A$6/360),oe=Math.cos(re*A$6/360),ae=oe*(X-J)/2+se*(K-Q)/2,le=-se*(X-J)/2+oe*(K-Q)/2;if(ae===0&&le===0)return;ee=Math.abs(ee),te=Math.abs(te);const ce=Math.pow(ae,2)/Math.pow(ee,2)+Math.pow(le,2)/Math.pow(te,2);ce>1&&(ee*=Math.sqrt(ce),te*=Math.sqrt(ce)),H$5(X,K,J,Q,ee,te,ne,ie,se,oe,ae,le,z$1);let{ang1:de,ang2:he}=z$1;const{centerX:pe,centerY:fe}=z$1;let ge=Math.abs(he)/(A$6/4);Math.abs(1-ge)<1e-7&&(ge=1);const me=Math.max(Math.ceil(ge),1);he/=me;let ye=Z[Z.length-2],_e=Z[Z.length-1];const Ae={x:0,y:0};for(let ve=0;ve<me;ve++){const be=G$2(de,he),{x:xe,y:Se}=B$4(be[0],ee,te,oe,se,pe,fe,Ae),{x:$e,y:Ce}=B$4(be[1],ee,te,oe,se,pe,fe,Ae),{x:Te,y:Ie}=B$4(be[2],ee,te,oe,se,pe,fe,Ae);buildAdaptiveBezier(Z,ye,_e,xe,Se,$e,Ce,Te,Ie),ye=Te,_e=Ie,de+=he}}function roundedShapeArc(Z,X,K){var J;const Q=(re,ne)=>{const ie=ne.x-re.x,se=ne.y-re.y,oe=Math.sqrt(ie*ie+se*se),ae=ie/oe,le=se/oe;return{len:oe,nx:ae,ny:le}},ee=(re,ne)=>{re===0?Z.moveTo(ne.x,ne.y):Z.lineTo(ne.x,ne.y)};let te=X[X.length-1];for(let re=0;re<X.length;re++){const ne=X[re%X.length],ie=(J=ne.radius)!=null?J:K;if(ie<=0){ee(re,ne),te=ne;continue}const se=X[(re+1)%X.length],oe=Q(ne,te),ae=Q(ne,se);if(oe.len<1e-4||ae.len<1e-4){ee(re,ne),te=ne;continue}let le=Math.asin(oe.nx*ae.ny-oe.ny*ae.nx),ce=1,de=!1;oe.nx*ae.nx-oe.ny*-ae.ny<0?le<0?le=Math.PI+le:(le=Math.PI-le,ce=-1,de=!0):le>0&&(ce=-1,de=!0);const he=le/2;let pe,fe=Math.abs(Math.cos(he)*ie/Math.sin(he));fe>Math.min(oe.len/2,ae.len/2)?(fe=Math.min(oe.len/2,ae.len/2),pe=Math.abs(fe*Math.sin(he)/Math.cos(he))):pe=ie;const ge=ne.x+ae.nx*fe+-ae.ny*pe*ce,me=ne.y+ae.ny*fe+ae.nx*pe*ce,ye=Math.atan2(oe.ny,oe.nx)+Math.PI/2*ce,_e=Math.atan2(ae.ny,ae.nx)-Math.PI/2*ce;re===0&&Z.moveTo(ge+Math.cos(ye)*pe,me+Math.sin(ye)*pe),Z.arc(ge,me,pe,ye,_e,de),te=ne}}function roundedShapeQuadraticCurve(Z,X,K,J){var Q;const ee=(ne,ie)=>Math.sqrt((ne.x-ie.x)**2+(ne.y-ie.y)**2),te=(ne,ie,se)=>({x:ne.x+(ie.x-ne.x)*se,y:ne.y+(ie.y-ne.y)*se}),re=X.length;for(let ne=0;ne<re;ne++){const ie=X[(ne+1)%re],se=(Q=ie.radius)!=null?Q:K;if(se<=0){ne===0?Z.moveTo(ie.x,ie.y):Z.lineTo(ie.x,ie.y);continue}const oe=X[ne],ae=X[(ne+2)%re],le=ee(oe,ie);let ce;if(le<1e-4)ce=ie;else{const pe=Math.min(le/2,se);ce=te(ie,oe,pe/le)}const de=ee(ae,ie);let he;if(de<1e-4)he=ie;else{const pe=Math.min(de/2,se);he=te(ie,ae,pe/de)}ne===0?Z.moveTo(ce.x,ce.y):Z.lineTo(ce.x,ce.y),Z.quadraticCurveTo(ie.x,ie.y,he.x,he.y,J)}}const Y$1=new Rectangle;class ShapePath{constructor(X){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Bounds,this._graphicsPath2D=X}moveTo(X,K){return this.startPoly(X,K),this}lineTo(X,K){this._ensurePoly();const J=this._currentPoly.points,Q=J[J.length-2],ee=J[J.length-1];return(Q!==X||ee!==K)&&J.push(X,K),this}arc(X,K,J,Q,ee,te){this._ensurePoly(!1);const re=this._currentPoly.points;return buildArc(re,X,K,J,Q,ee,te),this}arcTo(X,K,J,Q,ee){this._ensurePoly();const te=this._currentPoly.points;return buildArcTo(te,X,K,J,Q,ee),this}arcToSvg(X,K,J,Q,ee,te,re){const ne=this._currentPoly.points;return buildArcToSvg(ne,this._currentPoly.lastX,this._currentPoly.lastY,te,re,X,K,J,Q,ee),this}bezierCurveTo(X,K,J,Q,ee,te,re){this._ensurePoly();const ne=this._currentPoly;return buildAdaptiveBezier(this._currentPoly.points,ne.lastX,ne.lastY,X,K,J,Q,ee,te,re),this}quadraticCurveTo(X,K,J,Q,ee){this._ensurePoly();const te=this._currentPoly;return buildAdaptiveQuadratic(this._currentPoly.points,te.lastX,te.lastY,X,K,J,Q,ee),this}closePath(){return this.endPoly(!0),this}addPath(X,K){this.endPoly(),K&&!K.isIdentity()&&(X=X.clone(!0),X.transform(K));for(let J=0;J<X.instructions.length;J++){const Q=X.instructions[J];this[Q.action](...Q.data)}return this}finish(X=!1){this.endPoly(X)}rect(X,K,J,Q,ee){return this.drawShape(new Rectangle(X,K,J,Q),ee),this}circle(X,K,J,Q){return this.drawShape(new Circle(X,K,J),Q),this}poly(X,K,J){const Q=new Polygon(X);return Q.closePath=K,this.drawShape(Q,J),this}regularPoly(X,K,J,Q,ee=0,te){Q=Math.max(Q|0,3);const re=-1*Math.PI/2+ee,ne=Math.PI*2/Q,ie=[];for(let se=0;se<Q;se++){const oe=se*ne+re;ie.push(X+J*Math.cos(oe),K+J*Math.sin(oe))}return this.poly(ie,!1,te),this}roundPoly(X,K,J,Q,ee,te=0,re){if(Q=Math.max(Q|0,3),ee<=0)return this.regularPoly(X,K,J,Q,te);const ne=J*Math.sin(Math.PI/Q)-.001;ee=Math.min(ee,ne);const ie=-1*Math.PI/2+te,se=Math.PI*2/Q,oe=(Q-2)*Math.PI/Q/2;for(let ae=0;ae<Q;ae++){const le=ae*se+ie,ce=X+J*Math.cos(le),de=K+J*Math.sin(le),he=le+Math.PI+oe,pe=le-Math.PI-oe,fe=ce+ee*Math.cos(he),ge=de+ee*Math.sin(he),me=ce+ee*Math.cos(pe),ye=de+ee*Math.sin(pe);ae===0?this.moveTo(fe,ge):this.lineTo(fe,ge),this.quadraticCurveTo(ce,de,me,ye,re)}return this.closePath()}roundShape(X,K,J=!1,Q){return X.length<3?this:(J?roundedShapeQuadraticCurve(this,X,K,Q):roundedShapeArc(this,X,K),this.closePath())}filletRect(X,K,J,Q,ee){if(ee===0)return this.rect(X,K,J,Q);const te=Math.min(J,Q)/2,re=Math.min(te,Math.max(-te,ee)),ne=X+J,ie=K+Q,se=re<0?-re:0,oe=Math.abs(re);return this.moveTo(X,K+oe).arcTo(X+se,K+se,X+oe,K,oe).lineTo(ne-oe,K).arcTo(ne-se,K+se,ne,K+oe,oe).lineTo(ne,ie-oe).arcTo(ne-se,ie-se,X+J-oe,ie,oe).lineTo(X+oe,ie).arcTo(X+se,ie-se,X,ie-oe,oe).closePath()}chamferRect(X,K,J,Q,ee,te){if(ee<=0)return this.rect(X,K,J,Q);const re=Math.min(ee,Math.min(J,Q)/2),ne=X+J,ie=K+Q,se=[X+re,K,ne-re,K,ne,K+re,ne,ie-re,ne-re,ie,X+re,ie,X,ie-re,X,K+re];for(let oe=se.length-1;oe>=2;oe-=2)se[oe]===se[oe-2]&&se[oe-1]===se[oe-3]&&se.splice(oe-1,2);return this.poly(se,void 0,te)}ellipse(X,K,J,Q,ee){return this.drawShape(new Ellipse(X,K,J,Q),ee),this}roundRect(X,K,J,Q,ee,te){return this.drawShape(new RoundedRectangle(X,K,J,Q,ee),te),this}drawShape(X,K){return this.endPoly(),this.shapePrimitives.push({shape:X,transform:K}),this}startPoly(X,K){let J=this._currentPoly;return J&&this.endPoly(),J=new Polygon,J.points.push(X,K),this._currentPoly=J,this}endPoly(X=!1){const K=this._currentPoly;return K&&K.points.length>2&&(K.closePath=X,this.shapePrimitives.push({shape:K})),this._currentPoly=null,this}_ensurePoly(X=!0){if(!this._currentPoly&&(this._currentPoly=new Polygon,X)){const K=this.shapePrimitives[this.shapePrimitives.length-1];if(K){let J=K.shape.x,Q=K.shape.y;if(!K.transform.isIdentity()){const ee=K.transform,te=J;J=ee.a*J+ee.c*Q+ee.tx,Q=ee.b*te+ee.d*Q+ee.ty}this._currentPoly.points.push(J,Q)}else this._currentPoly.points.push(0,0)}}buildPath(){const X=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let K=0;K<X.instructions.length;K++){const J=X.instructions[K];this[J.action](...J.data)}this.finish()}get bounds(){const X=this._bounds;X.clear();const K=this.shapePrimitives;for(let J=0;J<K.length;J++){const Q=K[J],ee=Q.shape.getBounds(Y$1);Q.transform?(X.pushMatrix(Q.transform),X.addRect(ee),X.popMatrix()):X.addRect(ee)}return X}}class GraphicsPath{constructor(X){this.instructions=[],this.uid=uid("graphicsPath"),this._dirty=!0;var K;typeof X=="string"?SVGToGraphicsPath(X,this):this.instructions=(K=X==null?void 0:X.slice())!=null?K:[]}get shapePath(){return this._shapePath||(this._shapePath=new ShapePath(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(X,K){return X=X.clone(),this.instructions.push({action:"addPath",data:[X,K]}),this._dirty=!0,this}arc(...X){return this.instructions.push({action:"arc",data:X}),this._dirty=!0,this}arcTo(...X){return this.instructions.push({action:"arcTo",data:X}),this._dirty=!0,this}arcToSvg(...X){return this.instructions.push({action:"arcToSvg",data:X}),this._dirty=!0,this}bezierCurveTo(...X){return this.instructions.push({action:"bezierCurveTo",data:X}),this._dirty=!0,this}bezierCurveToShort(X,K,J,Q,ee){const te=this.instructions[this.instructions.length-1],re=this.getLastPoint(Point.shared);let ne=0,ie=0;if(!te||te.action!=="bezierCurveTo")ne=re.x,ie=re.y;else{ne=te.data[2],ie=te.data[3];const se=re.x,oe=re.y;ne=se+(se-ne),ie=oe+(oe-ie)}return this.instructions.push({action:"bezierCurveTo",data:[ne,ie,X,K,J,Q,ee]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...X){return this.instructions.push({action:"ellipse",data:X}),this._dirty=!0,this}lineTo(...X){return this.instructions.push({action:"lineTo",data:X}),this._dirty=!0,this}moveTo(...X){return this.instructions.push({action:"moveTo",data:X}),this}quadraticCurveTo(...X){return this.instructions.push({action:"quadraticCurveTo",data:X}),this._dirty=!0,this}quadraticCurveToShort(X,K,J){const Q=this.instructions[this.instructions.length-1],ee=this.getLastPoint(Point.shared);let te=0,re=0;if(!Q||Q.action!=="quadraticCurveTo")te=ee.x,re=ee.y;else{te=Q.data[0],re=Q.data[1];const ne=ee.x,ie=ee.y;te=ne+(ne-te),re=ie+(ie-re)}return this.instructions.push({action:"quadraticCurveTo",data:[te,re,X,K,J]}),this._dirty=!0,this}rect(X,K,J,Q,ee){return this.instructions.push({action:"rect",data:[X,K,J,Q,ee]}),this._dirty=!0,this}circle(X,K,J,Q){return this.instructions.push({action:"circle",data:[X,K,J,Q]}),this._dirty=!0,this}roundRect(...X){return this.instructions.push({action:"roundRect",data:X}),this._dirty=!0,this}poly(...X){return this.instructions.push({action:"poly",data:X}),this._dirty=!0,this}regularPoly(...X){return this.instructions.push({action:"regularPoly",data:X}),this._dirty=!0,this}roundPoly(...X){return this.instructions.push({action:"roundPoly",data:X}),this._dirty=!0,this}roundShape(...X){return this.instructions.push({action:"roundShape",data:X}),this._dirty=!0,this}filletRect(...X){return this.instructions.push({action:"filletRect",data:X}),this._dirty=!0,this}chamferRect(...X){return this.instructions.push({action:"chamferRect",data:X}),this._dirty=!0,this}star(X,K,J,Q,ee,te,re){ee=ee||Q/2;const ne=-1*Math.PI/2+te,ie=J*2,se=Math.PI*2/ie,oe=[];for(let ae=0;ae<ie;ae++){const le=ae%2?ee:Q,ce=ae*se+ne;oe.push(X+le*Math.cos(ce),K+le*Math.sin(ce))}return this.poly(oe,!0,re),this}clone(X=!1){const K=new GraphicsPath;if(!X)K.instructions=this.instructions.slice();else for(let J=0;J<this.instructions.length;J++){const Q=this.instructions[J];K.instructions.push({action:Q.action,data:Q.data.slice()})}return K}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(X){if(X.isIdentity())return this;const K=X.a,J=X.b,Q=X.c,ee=X.d,te=X.tx,re=X.ty;let ne=0,ie=0,se=0,oe=0,ae=0,le=0,ce=0,de=0;for(let he=0;he<this.instructions.length;he++){const pe=this.instructions[he],fe=pe.data;switch(pe.action){case"moveTo":case"lineTo":ne=fe[0],ie=fe[1],fe[0]=K*ne+Q*ie+te,fe[1]=J*ne+ee*ie+re;break;case"bezierCurveTo":se=fe[0],oe=fe[1],ae=fe[2],le=fe[3],ne=fe[4],ie=fe[5],fe[0]=K*se+Q*oe+te,fe[1]=J*se+ee*oe+re,fe[2]=K*ae+Q*le+te,fe[3]=J*ae+ee*le+re,fe[4]=K*ne+Q*ie+te,fe[5]=J*ne+ee*ie+re;break;case"quadraticCurveTo":se=fe[0],oe=fe[1],ne=fe[2],ie=fe[3],fe[0]=K*se+Q*oe+te,fe[1]=J*se+ee*oe+re,fe[2]=K*ne+Q*ie+te,fe[3]=J*ne+ee*ie+re;break;case"arcToSvg":ne=fe[5],ie=fe[6],ce=fe[0],de=fe[1],fe[0]=K*ce+Q*de,fe[1]=J*ce+ee*de,fe[5]=K*ne+Q*ie+te,fe[6]=J*ne+ee*ie+re;break;case"circle":fe[4]=p$A(fe[3],X);break;case"rect":fe[4]=p$A(fe[4],X);break;case"ellipse":fe[8]=p$A(fe[8],X);break;case"roundRect":fe[5]=p$A(fe[5],X);break;case"addPath":fe[0].transform(X);break;case"poly":fe[2]=p$A(fe[2],X);break;default:break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(X){let K=this.instructions.length-1,J=this.instructions[K];if(!J)return X.x=0,X.y=0,X;for(;J.action==="closePath";){if(K--,K<0)return X.x=0,X.y=0,X;J=this.instructions[K]}switch(J.action){case"moveTo":case"lineTo":X.x=J.data[0],X.y=J.data[1];break;case"quadraticCurveTo":X.x=J.data[2],X.y=J.data[3];break;case"bezierCurveTo":X.x=J.data[4],X.y=J.data[5];break;case"arc":case"arcToSvg":X.x=J.data[5],X.y=J.data[6];break;case"addPath":J.data[0].getLastPoint(X);break}return X}}function p$A(Z,X){return Z?Z.prepend(X):X.clone()}var L$3=Object.defineProperty,P$8=Object.getOwnPropertySymbols,q=Object.prototype.hasOwnProperty,H$4=Object.prototype.propertyIsEnumerable,s$x=(Z,X,K)=>X in Z?L$3(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,b$m=(Z,X)=>{for(var K in X||(X={}))q.call(X,K)&&s$x(Z,K,X[K]);if(P$8)for(var K of P$8(X))H$4.call(X,K)&&s$x(Z,K,X[K]);return Z};function SVGParser(Z,X){if(typeof Z=="string"){const J=document.createElement("div");J.innerHTML=Z.trim(),Z=J.querySelector("svg")}const K={context:X,path:new GraphicsPath};return I$3(Z,K,null,null),X}function I$3(Z,X,K,J){const Q=Z.children,{fillStyle:ee,strokeStyle:te}=M$6(Z);ee&&K?K=b$m(b$m({},K),ee):ee&&(K=ee),te&&J?J=b$m(b$m({},J),te):te&&(J=te),X.context.fillStyle=K,X.context.strokeStyle=J;let re,ne,ie,se,oe,ae,le,ce,de,he,pe,fe,ge,me,ye,_e,Ae;switch(Z.nodeName.toLowerCase()){case"path":me=Z.getAttribute("d"),ye=new GraphicsPath(me),X.context.path(ye),K&&X.context.fill(),J&&X.context.stroke();break;case"circle":le=o$p(Z,"cx",0),ce=o$p(Z,"cy",0),de=o$p(Z,"r",0),X.context.ellipse(le,ce,de,de),K&&X.context.fill(),J&&X.context.stroke();break;case"rect":re=o$p(Z,"x",0),ne=o$p(Z,"y",0),_e=o$p(Z,"width",0),Ae=o$p(Z,"height",0),he=o$p(Z,"rx",0),pe=o$p(Z,"ry",0),he||pe?X.context.roundRect(re,ne,_e,Ae,he||pe):X.context.rect(re,ne,_e,Ae),K&&X.context.fill(),J&&X.context.stroke();break;case"ellipse":le=o$p(Z,"cx",0),ce=o$p(Z,"cy",0),he=o$p(Z,"rx",0),pe=o$p(Z,"ry",0),X.context.beginPath(),X.context.ellipse(le,ce,he,pe),K&&X.context.fill(),J&&X.context.stroke();break;case"line":ie=o$p(Z,"x1",0),se=o$p(Z,"y1",0),oe=o$p(Z,"x2",0),ae=o$p(Z,"y2",0),X.context.beginPath(),X.context.moveTo(ie,se),X.context.lineTo(oe,ae),J&&X.context.stroke();break;case"polygon":ge=Z.getAttribute("points"),fe=ge.match(/\d+/g).map(ve=>parseInt(ve,10)),X.context.poly(fe,!0),K&&X.context.fill(),J&&X.context.stroke();break;case"polyline":ge=Z.getAttribute("points"),fe=ge.match(/\d+/g).map(ve=>parseInt(ve,10)),X.context.poly(fe,!1),J&&X.context.stroke();break;case"g":case"svg":break;default:{console.info(`[SVG parser] <${Z.nodeName}> elements unsupported`);break}}for(let ve=0;ve<Q.length;ve++)I$3(Q[ve],X,K,J)}function o$p(Z,X,K){const J=Z.getAttribute(X);return J?Number(J):K}function M$6(Z){const X=Z.getAttribute("style"),K={},J={};let Q=!1,ee=!1;if(X){const te=X.split(";");for(let re=0;re<te.length;re++){const ne=te[re],[ie,se]=ne.split(":");switch(ie){case"stroke":se!=="none"&&(K.color=Color.shared.setValue(se).toNumber(),ee=!0);break;case"stroke-width":K.width=Number(se);break;case"fill":se!=="none"&&(Q=!0,J.color=Color.shared.setValue(se).toNumber());break;case"fill-opacity":J.alpha=Number(se);break;case"stroke-opacity":K.alpha=Number(se);break;case"opacity":J.alpha=Number(se),K.alpha=Number(se);break}}}else{const te=Z.getAttribute("stroke");te&&te!=="none"&&(ee=!0,K.color=Color.shared.setValue(te).toNumber(),K.width=o$p(Z,"stroke-width",1));const re=Z.getAttribute("fill");re&&re!=="none"&&(Q=!0,J.color=Color.shared.setValue(re).toNumber())}return{strokeStyle:ee?K:null,fillStyle:Q?J:null}}const n$v=class{constructor(Z,X,K,J){this.uid=uid("fillGradient"),this.type="linear",this.gradientStops=[],this.x0=Z,this.y0=X,this.x1=K,this.y1=J}addColorStop(Z,X){return this.gradientStops.push({offset:Z,color:Color.shared.setValue(X).toHex()}),this}buildLinearGradient(){const Z=n$v.defaultTextureSize,{gradientStops:X}=this,K=DOMAdapter.get().createCanvas();K.width=Z,K.height=Z;const J=K.getContext("2d"),Q=J.createLinearGradient(0,0,n$v.defaultTextureSize,1);for(let ce=0;ce<X.length;ce++){const de=X[ce];Q.addColorStop(de.offset,de.color)}J.fillStyle=Q,J.fillRect(0,0,Z,Z),this.texture=new Texture({source:new ImageSource({resource:K,style:{addressModeU:"clamp-to-edge",addressModeV:"repeat"}})});const{x0:ee,y0:te,x1:re,y1:ne}=this,ie=new Matrix,se=re-ee,oe=ne-te,ae=Math.sqrt(se*se+oe*oe),le=Math.atan2(oe,se);ie.translate(-ee,-te),ie.scale(1/Z,1/Z),ie.rotate(-le),ie.scale(256/ae,1),this.transform=ie}};let FillGradient=n$v;FillGradient.defaultTextureSize=256;const t$d={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class FillPattern{constructor(X,K){this.uid=uid("fillPattern"),this.transform=new Matrix,this.texture=X,this.transform.scale(1/X.frame.width,1/X.frame.height),K&&(X.source.style.addressModeU=t$d[K].addressModeU,X.source.style.addressModeV=t$d[K].addressModeV)}setTransform(X){const K=this.texture;this.transform.copyFrom(X),this.transform.invert(),this.transform.scale(1/K.frame.width,1/K.frame.height)}}var y$g=Object.defineProperty,S$7=Object.defineProperties,d$o=Object.getOwnPropertyDescriptors,u$t=Object.getOwnPropertySymbols,C$3=Object.prototype.hasOwnProperty,h$o=Object.prototype.propertyIsEnumerable,x$d=(Z,X,K)=>X in Z?y$g(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$u=(Z,X)=>{for(var K in X||(X={}))C$3.call(X,K)&&x$d(Z,K,X[K]);if(u$t)for(var K of u$t(X))h$o.call(X,K)&&x$d(Z,K,X[K]);return Z},a$t=(Z,X)=>S$7(Z,d$o(X));function convertFillInputToFillStyle(Z,X){var K,J;if(!Z)return null;let Q,ee;if(Z!=null&&Z.fill?(ee=Z.fill,Q=n$u(n$u({},X),Z)):(ee=Z,Q=X),Color.isColorLike(ee)){const ne=Color.shared.setValue(ee!=null?ee:0);return a$t(n$u({},Q),{color:ne.toNumber(),alpha:ne.alpha===1?Q.alpha:ne.alpha,texture:Texture.WHITE})}else if(ee instanceof FillPattern){const ne=ee;return a$t(n$u({},Q),{color:16777215,texture:ne.texture,matrix:ne.transform,fill:(K=Q.fill)!=null?K:null})}else if(ee instanceof FillGradient){const ne=ee;return ne.buildLinearGradient(),a$t(n$u({},Q),{color:16777215,texture:ne.texture,matrix:ne.transform})}const te=n$u(n$u({},X),Z);if(te.texture){if(te.texture!==Texture.WHITE){const ie=((J=te.matrix)==null?void 0:J.invert())||new Matrix;ie.scale(1/te.texture.frame.width,1/te.texture.frame.height),te.matrix=ie}const ne=te.texture.source.style;ne.addressMode==="clamp-to-edge"&&(ne.addressMode="repeat")}const re=Color.shared.setValue(te.color);return te.alpha*=re.alpha,te.color=re.toNumber(),te.matrix=te.matrix?te.matrix.clone():null,te}var G$1=Object.defineProperty,P$7=Object.getOwnPropertySymbols,M$5=Object.prototype.hasOwnProperty,w$6=Object.prototype.propertyIsEnumerable,F$4=(Z,X,K)=>X in Z?G$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,b$l=(Z,X)=>{for(var K in X||(X={}))M$5.call(X,K)&&F$4(Z,K,X[K]);if(P$7)for(var K of P$7(X))w$6.call(X,K)&&F$4(Z,K,X[K]);return Z};const U$3=new Point,I$2=new Matrix,u$s=class extends eventemitter3{constructor(){super(...arguments),this.uid=uid("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new GraphicsPath,this._transform=new Matrix,this._fillStyle=b$l({},u$s.defaultFillStyle),this._strokeStyle=b$l({},u$s.defaultStrokeStyle),this._stateStack=[],this._tick=0,this._bounds=new Bounds,this._boundsDirty=!0}get fillStyle(){return this._fillStyle}set fillStyle(Z){this._fillStyle=convertFillInputToFillStyle(Z,u$s.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(Z){this._strokeStyle=convertFillInputToFillStyle(Z,u$s.defaultStrokeStyle)}setFillStyle(Z){return this._fillStyle=convertFillInputToFillStyle(Z,u$s.defaultFillStyle),this}setStrokeStyle(Z){return this._strokeStyle=convertFillInputToFillStyle(Z,u$s.defaultStrokeStyle),this}texture(Z,X,K,J,Q,ee){return this.instructions.push({action:"texture",data:{image:Z,dx:K||0,dy:J||0,dw:Q||Z.frame.width,dh:ee||Z.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:X?Color.shared.setValue(X).toNumber():0}}),this.onUpdate(),this}beginPath(){return this._activePath=new GraphicsPath,this}fill(Z,X){let K;const J=this.instructions[this.instructions.length-1];return this._tick===0&&J&&J.action==="stroke"?K=J.data.path:K=this._activePath.clone(),K?(Z&&(X!==void 0&&typeof Z=="number"&&(deprecation("8.0.0","GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),Z={color:Z,alpha:X}),this._fillStyle=convertFillInputToFillStyle(Z,u$s.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:K}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:Z,y:X}=this._activePath.getLastPoint(Point.shared);this._activePath.clear(),this._activePath.moveTo(Z,X)}stroke(Z){let X;const K=this.instructions[this.instructions.length-1];return this._tick===0&&K&&K.action==="fill"?X=K.data.path:X=this._activePath.clone(),X?(Z&&(this._strokeStyle=convertFillInputToFillStyle(Z,u$s.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:X}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let Z=0;Z<2;Z++){const X=this.instructions[this.instructions.length-1-Z],K=this._activePath.clone();if(X&&(X.action==="stroke"||X.action==="fill"))if(X.data.hole)X.data.hole.addPath(K);else{X.data.hole=K;break}}return this._initNextPathLocation(),this}arc(Z,X,K,J,Q,ee){this._tick++;const te=this._transform;return this._activePath.arc(te.a*Z+te.c*X+te.tx,te.b*Z+te.d*X+te.ty,K,J,Q,ee),this}arcTo(Z,X,K,J,Q){this._tick++;const ee=this._transform;return this._activePath.arcTo(ee.a*Z+ee.c*X+ee.tx,ee.b*Z+ee.d*X+ee.ty,ee.a*K+ee.c*J+ee.tx,ee.b*K+ee.d*J+ee.ty,Q),this}arcToSvg(Z,X,K,J,Q,ee,te){this._tick++;const re=this._transform;return this._activePath.arcToSvg(Z,X,K,J,Q,re.a*ee+re.c*te+re.tx,re.b*ee+re.d*te+re.ty),this}bezierCurveTo(Z,X,K,J,Q,ee,te){this._tick++;const re=this._transform;return this._activePath.bezierCurveTo(re.a*Z+re.c*X+re.tx,re.b*Z+re.d*X+re.ty,re.a*K+re.c*J+re.tx,re.b*K+re.d*J+re.ty,re.a*Q+re.c*ee+re.tx,re.b*Q+re.d*ee+re.ty,te),this}closePath(){var Z;return this._tick++,(Z=this._activePath)==null||Z.closePath(),this}ellipse(Z,X,K,J){return this._tick++,this._activePath.ellipse(Z,X,K,J,this._transform.clone()),this}circle(Z,X,K){return this._tick++,this._activePath.circle(Z,X,K,this._transform.clone()),this}path(Z){return this._tick++,this._activePath.addPath(Z,this._transform.clone()),this}lineTo(Z,X){this._tick++;const K=this._transform;return this._activePath.lineTo(K.a*Z+K.c*X+K.tx,K.b*Z+K.d*X+K.ty),this}moveTo(Z,X){this._tick++;const K=this._transform,J=this._activePath.instructions,Q=K.a*Z+K.c*X+K.tx,ee=K.b*Z+K.d*X+K.ty;return J.length===1&&J[0].action==="moveTo"?(J[0].data[0]=Q,J[0].data[1]=ee,this):(this._activePath.moveTo(Q,ee),this)}quadraticCurveTo(Z,X,K,J,Q){this._tick++;const ee=this._transform;this._activePath.quadraticCurveTo(ee.a*Z+ee.c*X+ee.tx,ee.b*Z+ee.d*X+ee.ty,ee.a*K+ee.c*J+ee.tx,ee.b*K+ee.d*J+ee.ty,Q)}rect(Z,X,K,J){return this._tick++,this._activePath.rect(Z,X,K,J,this._transform.clone()),this}roundRect(Z,X,K,J,Q){return this._tick++,this._activePath.roundRect(Z,X,K,J,Q,this._transform.clone()),this}poly(Z,X){return this._tick++,this._activePath.poly(Z,X,this._transform.clone()),this}regularPoly(Z,X,K,J,Q=0,ee){return this._tick++,this._activePath.regularPoly(Z,X,K,J,Q,ee),this}roundPoly(Z,X,K,J,Q,ee){return this._tick++,this._activePath.roundPoly(Z,X,K,J,Q,ee),this}roundShape(Z,X,K,J){return this._tick++,this._activePath.roundShape(Z,X,K,J),this}filletRect(Z,X,K,J,Q){return this._tick++,this._activePath.filletRect(Z,X,K,J,Q),this}chamferRect(Z,X,K,J,Q,ee){return this._tick++,this._activePath.chamferRect(Z,X,K,J,Q,ee),this}star(Z,X,K,J,Q,ee){return this._tick++,this._activePath.star(Z,X,K,J,Q,ee,this._transform.clone()),this}svg(Z){this._tick++,SVGParser(Z,this)}restore(){const Z=this._stateStack.pop();Z&&(this._transform=Z.transform,this._fillStyle=Z.fillStyle,this._strokeStyle=Z.strokeStyle)}save(){this._stateStack.push({transform:this._transform.clone(),fillStyle:b$l({},this._fillStyle),strokeStyle:b$l({},this._strokeStyle)})}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(Z){return this._transform.rotate(Z),this}scale(Z,X=Z){return this._transform.scale(Z,X),this}setTransform(Z,X,K,J,Q,ee){return Z instanceof Matrix?(this._transform.set(Z.a,Z.b,Z.c,Z.d,Z.tx,Z.ty),this):(this._transform.set(Z,X,K,J,Q,ee),this)}transform(Z,X,K,J,Q,ee){return Z instanceof Matrix?(this._transform.append(Z),this):(I$2.set(Z,X,K,J,Q,ee),this._transform.append(I$2),this)}translate(Z,X){return this._transform.translate(Z,X),this}clear(){return this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const Z=this._bounds;Z.clear();for(let X=0;X<this.instructions.length;X++){const K=this.instructions[X],J=K.action;if(J==="fill"){const Q=K.data;Z.addBounds(Q.path.bounds)}else if(J==="texture"){const Q=K.data;Z.pushMatrix(Q.transform),Z.addFrame(Q.dx,Q.dy,Q.dx+Q.dw,Q.dy+Q.dh),Z.popMatrix()}if(J==="stroke"){const Q=K.data,ee=Q.style.width/2,te=Q.path.bounds;Z.addFrame(te.minX-ee,te.minY-ee,te.maxX+ee,te.maxY+ee)}}return Z}containsPoint(Z){var X;if(!this.bounds.containsPoint(Z.x,Z.y))return!1;const K=this.instructions;let J=!1;for(let Q=0;Q<K.length;Q++){const ee=K[Q],te=ee.data,re=te.path;if(!ee.action||!re)continue;const ne=te.style,ie=re.shapePath.shapePrimitives;for(let se=0;se<ie.length;se++){const oe=ie[se].shape;if(!ne||!oe)continue;const ae=ie[se].transform,le=ae?ae.applyInverse(Z,U$3):Z;ee.action==="fill"?J=oe.contains(le.x,le.y):J=oe.strokeContains(le.x,le.y,ne.width);const ce=te.hole;if(ce){const de=(X=ce.shapePath)==null?void 0:X.shapePrimitives;if(de)for(let he=0;he<de.length;he++)de[he].shape.contains(le.x,le.y)&&(J=!1)}if(J)return!0}}return J}destroy(Z=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof Z=="boolean"?Z:Z==null?void 0:Z.texture){const X=typeof Z=="boolean"?Z:Z==null?void 0:Z.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(X),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(X)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};let GraphicsContext=u$s;GraphicsContext.defaultFillStyle={color:16777215,alpha:1,texture:Texture.WHITE,matrix:null,fill:null},GraphicsContext.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:Texture.WHITE,matrix:null,fill:null};const m$t=/^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,p$z=".svg",c$q="image/svg+xml",loadSvg={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.Low},name:"loadSVG",test(Z){return checkDataUrl(Z,c$q)||checkExtension(Z,p$z)},async testParse(Z){return typeof Z=="string"&&Z.startsWith("data:image/svg+xml")||typeof Z=="string"&&m$t.test(Z)},async parse(Z){const X=new GraphicsContext;return X.svg(Z),X},async load(Z){return(await DOMAdapter.get().fetch(Z)).text()},unload(Z){Z.destroy(!0)}};function getResolutionOfUrl(Z,X=1){var K;const J=(K=Resolver.RETINA_PREFIX)==null?void 0:K.exec(Z);return J?parseFloat(J[1]):X}let o$o=0,i$m;const p$y="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",m$s={id:"checkImageBitmap",code:`
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${p$y}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `},u$r={id:"loadImageBitmap",code:`
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`};let s$w;class c$p{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(X=>{const K=URL.createObjectURL(new Blob([m$s.code],{type:"application/javascript"})),J=new Worker(K);J.addEventListener("message",Q=>{J.terminate(),URL.revokeObjectURL(K),X(Q.data)})}),this._isImageBitmapSupported)}loadImageBitmap(X){return this._run("loadImageBitmap",[X])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){i$m===void 0&&(i$m=navigator.hardwareConcurrency||4);let X=this._workerPool.pop();return!X&&this._createdWorkers<i$m&&(s$w||(s$w=URL.createObjectURL(new Blob([u$r.code],{type:"application/javascript"}))),this._createdWorkers++,X=new Worker(s$w),X.addEventListener("message",K=>{this._complete(K.data),this._returnWorker(K.target),this._next()})),X}_returnWorker(X){this._workerPool.push(X)}_complete(X){X.error!==void 0?this._resolveHash[X.uuid].reject(X.error):this._resolveHash[X.uuid].resolve(X.data),this._resolveHash[X.uuid]=null}async _run(X,K){await this._initWorkers();const J=new Promise((Q,ee)=>{this._queue.push({id:X,arguments:K,resolve:Q,reject:ee})});return this._next(),J}_next(){if(!this._queue.length)return;const X=this._getWorker();if(!X)return;const K=this._queue.pop(),J=K.id;this._resolveHash[o$o]={resolve:K.resolve,reject:K.reject},X.postMessage({data:K.arguments,uuid:o$o++,id:J})}}const d$n=new c$p;function createTexture(Z,X,K){Z.label=K;const J=new Texture({source:Z,label:K}),Q=()=>{delete X.promiseCache[K],Cache.has(K)&&Cache.remove(K)};return J.once("destroy",()=>{K in X.promiseCache&&Q()}),J.source.once("destroy",()=>{Z.destroyed||Q()}),J}var c$o=Object.defineProperty,s$v=Object.getOwnPropertySymbols,d$m=Object.prototype.hasOwnProperty,f$s=Object.prototype.propertyIsEnumerable,m$r=(Z,X,K)=>X in Z?c$o(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$t=(Z,X)=>{for(var K in X||(X={}))d$m.call(X,K)&&m$r(Z,K,X[K]);if(s$v)for(var K of s$v(X))f$s.call(X,K)&&m$r(Z,K,X[K]);return Z};const B$3=[".jpeg",".jpg",".png",".webp",".avif"],L$2=["image/jpeg","image/png","image/webp","image/avif"];async function loadImageBitmap(Z){const X=await DOMAdapter.get().fetch(Z);if(!X.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${Z}: ${X.status} ${X.statusText}`);const K=await X.blob();return await createImageBitmap(K)}const loadTextures={name:"loadTextures",extension:{type:u$z.LoadParser,priority:LoaderParserPriority.High},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(Z){return checkDataUrl(Z,L$2)||checkExtension(Z,B$3)},async load(Z,X,K){var J;let Q=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await d$n.isImageBitmapSupported()?Q=await d$n.loadImageBitmap(Z):Q=await loadImageBitmap(Z):Q=await new Promise(te=>{Q=new Image,Q.crossOrigin=this.config.crossOrigin,Q.src=Z,Q.complete?te(Q):Q.onload=()=>{te(Q)}});const ee=new ImageSource(n$t({resource:Q,alphaMode:"premultiply-alpha-on-upload",resolution:((J=X.data)==null?void 0:J.resolution)||getResolutionOfUrl(Z)},X.data));return createTexture(ee,K,Z)},unload(Z){Z.destroy(!0)}};let t$c;async function detectVideoAlphaMode(){return t$c!=null||(t$c=(async()=>{var Z;const X=document.createElement("canvas").getContext("webgl");if(!X)return"premultiply-alpha-on-upload";const K=await new Promise(te=>{const re=document.createElement("video");re.onloadeddata=()=>te(re),re.onerror=()=>te(null),re.autoplay=!1,re.crossOrigin="anonymous",re.preload="auto",re.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",re.load()});if(!K)return"premultiply-alpha-on-upload";const J=X.createTexture();X.bindTexture(X.TEXTURE_2D,J);const Q=X.createFramebuffer();X.bindFramebuffer(X.FRAMEBUFFER,Q),X.framebufferTexture2D(X.FRAMEBUFFER,X.COLOR_ATTACHMENT0,X.TEXTURE_2D,J,0),X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),X.pixelStorei(X.UNPACK_COLORSPACE_CONVERSION_WEBGL,X.NONE),X.texImage2D(X.TEXTURE_2D,0,X.RGBA,X.RGBA,X.UNSIGNED_BYTE,K);const ee=new Uint8Array(4);return X.readPixels(0,0,1,1,X.RGBA,X.UNSIGNED_BYTE,ee),X.deleteFramebuffer(Q),X.deleteTexture(J),(Z=X.getExtension("WEBGL_lose_context"))==null||Z.loseContext(),ee[0]<=ee[3]?"premultiplied-alpha":"premultiply-alpha-on-upload"})()),t$c}var c$n=Object.defineProperty,_$6=Object.defineProperties,m$q=Object.getOwnPropertyDescriptors,d$l=Object.getOwnPropertySymbols,v$6=Object.prototype.hasOwnProperty,y$f=Object.prototype.propertyIsEnumerable,l$n=(Z,X,K)=>X in Z?c$n(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$n=(Z,X)=>{for(var K in X||(X={}))v$6.call(X,K)&&l$n(Z,K,X[K]);if(d$l)for(var K of d$l(X))y$f.call(X,K)&&l$n(Z,K,X[K]);return Z},u$q=(Z,X)=>_$6(Z,m$q(X));const r$a=class extends TextureSource{constructor(Z){var X;super(Z),this.isReady=!1,this.uploadMethodId="video",Z=o$n(o$n({},r$a.defaultOptions),Z),this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=Z.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=Z.autoPlay!==!1,this.alphaMode=(X=Z.alphaMode)!=null?X:"premultiply-alpha-on-upload",this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onCanPlayThrough=this._onCanPlayThrough.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),Z.autoLoad!==!1&&this.load()}updateFrame(){if(!this.destroyed){if(this._updateFPS){const Z=Ticker.shared.elapsedMS*this.resource.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-Z)}(!this._updateFPS||this._msToNextUpdate<=0)&&(this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0),this.isValid&&this.update()}}_videoFrameRequestCallback(){this.updateFrame(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.source.requestVideoFrameCallback(this._videoFrameRequestCallback)}get isValid(){return!!this.resource.videoWidth&&!!this.resource.videoHeight}async load(){if(this._load)return this._load;const Z=this.resource,X=this.options;return(Z.readyState===Z.HAVE_ENOUGH_DATA||Z.readyState===Z.HAVE_FUTURE_DATA)&&Z.width&&Z.height&&(Z.complete=!0),Z.addEventListener("play",this._onPlayStart),Z.addEventListener("pause",this._onPlayStop),Z.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._mediaReady():(X.preload||Z.addEventListener("canplay",this._onCanPlay),Z.addEventListener("canplaythrough",this._onCanPlayThrough),Z.addEventListener("error",this._onError,!0)),this.alphaMode=await detectVideoAlphaMode(),this._load=new Promise((K,J)=>{this.isValid?K(this):(this._resolve=K,this._reject=J,X.preloadTimeoutMs!==void 0&&(this._preloadTimeout=setTimeout(()=>{this._onError(new ErrorEvent(`Preload exceeded timeout of ${X.preloadTimeoutMs}ms`))})),Z.load())}),this._load}_onError(Z){this.resource.removeEventListener("error",this._onError,!0),this.emit("error",Z),this._reject&&(this._reject(Z),this._reject=null,this._resolve=null)}_isSourcePlaying(){const Z=this.resource;return!Z.paused&&!Z.ended}_isSourceReady(){return this.resource.readyState>2}_onPlayStart(){this.isValid||this._mediaReady(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0)}_onCanPlay(){this.resource.removeEventListener("canplay",this._onCanPlay),this._mediaReady()}_onCanPlayThrough(){this.resource.removeEventListener("canplaythrough",this._onCanPlay),this._preloadTimeout&&(clearTimeout(this._preloadTimeout),this._preloadTimeout=void 0),this._mediaReady()}_mediaReady(){const Z=this.resource;this.isValid&&(this.isReady=!0,this.resize(Z.videoWidth,Z.videoHeight)),this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0,this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.resource.play()}destroy(){this._configureAutoUpdate();const Z=this.resource;Z&&(Z.removeEventListener("play",this._onPlayStart),Z.removeEventListener("pause",this._onPlayStop),Z.removeEventListener("seeked",this._onSeeked),Z.removeEventListener("canplay",this._onCanPlay),Z.removeEventListener("canplaythrough",this._onCanPlayThrough),Z.removeEventListener("error",this._onError,!0),Z.pause(),Z.src="",Z.load()),super.destroy()}get autoUpdate(){return this._autoUpdate}set autoUpdate(Z){Z!==this._autoUpdate&&(this._autoUpdate=Z,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(Z){Z!==this._updateFPS&&(this._updateFPS=Z,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.source.requestVideoFrameCallback?(this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),this._videoFrameRequestCallbackHandle===null&&(this._videoFrameRequestCallbackHandle=this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))):(this._videoFrameRequestCallbackHandle!==null&&(this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Ticker.shared.add(this.updateFrame,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(this._videoFrameRequestCallbackHandle!==null&&(this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(Z){return globalThis.HTMLVideoElement&&Z instanceof HTMLVideoElement||globalThis.VideoFrame&&Z instanceof VideoFrame}};let VideoSource=r$a;VideoSource.extension=u$z.TextureSource,VideoSource.defaultOptions=u$q(o$n({},TextureSource.defaultOptions),{autoLoad:!0,autoPlay:!0,updateFPS:0,crossorigin:!0,loop:!1,muted:!0,playsinline:!0,preload:!1}),VideoSource.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};var h$n=Object.defineProperty,x$c=Object.defineProperties,L$1=Object.getOwnPropertyDescriptors,v$5=Object.getOwnPropertySymbols,V=Object.prototype.hasOwnProperty,b$k=Object.prototype.propertyIsEnumerable,y$e=(Z,X,K)=>X in Z?h$n(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$p=(Z,X)=>{for(var K in X||(X={}))V.call(X,K)&&y$e(Z,K,X[K]);if(v$5)for(var K of v$5(X))b$k.call(X,K)&&y$e(Z,K,X[K]);return Z},l$m=(Z,X)=>x$c(Z,L$1(X));const g$n=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"],U$2=g$n.map(Z=>`video/${Z.substring(1)}`);function crossOrigin(Z,X,K){K===void 0&&!X.startsWith("data:")?Z.crossOrigin=determineCrossOrigin(X):K!==!1&&(Z.crossOrigin=typeof K=="string"?K:"anonymous")}function preloadVideo(Z){return new Promise((X,K)=>{Z.addEventListener("canplaythrough",J),Z.addEventListener("error",Q),Z.load();function J(){ee(),X()}function Q(te){ee(),K(te)}function ee(){Z.removeEventListener("canplaythrough",J),Z.removeEventListener("error",Q)}})}function determineCrossOrigin(Z,X=globalThis.location){if(Z.startsWith("data:"))return"";X=X||globalThis.location;const K=new URL(Z,document.baseURI);return K.hostname!==X.hostname||K.port!==X.port||K.protocol!==X.protocol?"anonymous":""}const loadVideoTextures={name:"loadVideo",extension:{type:u$z.LoadParser},config:null,test(Z){const X=checkDataUrl(Z,U$2),K=checkExtension(Z,g$n);return X||K},async load(Z,X,K){var J,Q;const ee=u$p(l$m(u$p({},VideoSource.defaultOptions),{resolution:((J=X.data)==null?void 0:J.resolution)||getResolutionOfUrl(Z),alphaMode:((Q=X.data)==null?void 0:Q.alphaMode)||await detectVideoAlphaMode()}),X.data),te=document.createElement("video"),re={preload:ee.autoLoad!==!1?"auto":void 0,"webkit-playsinline":ee.playsinline!==!1?"":void 0,playsinline:ee.playsinline!==!1?"":void 0,muted:ee.muted===!0?"":void 0,loop:ee.loop===!0?"":void 0,autoplay:ee.autoPlay!==!1?"":void 0};Object.keys(re).forEach(se=>{const oe=re[se];oe!==void 0&&te.setAttribute(se,oe)}),ee.muted===!0&&(te.muted=!0),crossOrigin(te,Z,ee.crossorigin);const ne=document.createElement("source");let ie;if(Z.startsWith("data:"))ie=Z.slice(5,Z.indexOf(";"));else if(!Z.startsWith("blob:")){const se=Z.split("?")[0].slice(Z.lastIndexOf(".")+1).toLowerCase();ie=VideoSource.MIME_TYPES[se]||`video/${se}`}return ne.src=Z,ie&&(ne.type=ie),new Promise(se=>{const oe=async()=>{const ae=new VideoSource(l$m(u$p({},ee),{resource:te}));te.removeEventListener("canplay",oe),X.data.preload&&await preloadVideo(te),se(createTexture(ae,K,Z))};te.addEventListener("canplay",oe),te.appendChild(ne)})},unload(Z){Z.destroy(!0)}},resolveTextureUrl={extension:u$z.ResolveParser,test:loadTextures.test,parse:Z=>{var X,K;return{resolution:parseFloat((K=(X=Resolver.RETINA_PREFIX.exec(Z))==null?void 0:X[1])!=null?K:"1"),format:Z.split(".").pop(),src:Z}}};b$r.add(cacheTextureArray,detectDefaults,detectAvif,detectWebp,detectMp4,detectOgv,detectWebm,loadJson,loadTxt,loadWebFont,loadSvg,loadTextures,loadVideoTextures,resolveTextureUrl,loadBitmapFont,bitmapFontCachePlugin);const m$p={loader:u$z.LoadParser,resolver:u$z.ResolveParser,cache:u$z.CacheParser,detection:u$z.DetectionParser};b$r.handle(u$z.Asset,Z=>{const X=Z.ref;Object.entries(m$p).filter(([K])=>!!X[K]).forEach(([K,J])=>{var Q;return b$r.add(Object.assign(X[K],{extension:(Q=X[K].extension)!=null?Q:J}))})},Z=>{const X=Z.ref;Object.keys(m$p).filter(K=>!!X[K]).forEach(K=>b$r.remove(X[K]))});const detectBasis={extension:{type:u$z.DetectionParser,priority:3},test:async()=>!!(await isWebGPUSupported()||isWebGLSupported()),add:async Z=>[...Z,"basis"],remove:async Z=>Z.filter(X=>X!=="basis")};class CompressedSource extends TextureSource{constructor(X){super(X),this.uploadMethodId="compressed",this.resource=X.resource,this.mipLevelCount=this.resource.length}}let s$u;function getSupportedGlCompressedTextureFormats(){if(s$u)return s$u;const Z=document.createElement("canvas").getContext("webgl");return Z?(s$u=[...Z.getExtension("WEBGL_compressed_texture_s3tc")?["bc2-rgba-unorm","bc3-rgba-unorm","bc7-rgba-unorm"]:[],...Z.getExtension("WEBGL_compressed_texture_s3tc_srgb")?["bc2-rgba-unorm-srgb","bc3-rgba-unorm-srgb","bc7-rgba-unorm-srgb"]:[],...Z.getExtension("WEBGL_compressed_texture_astc")?["etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","eac-r11unorm","eac-rg11unorm"]:[],...Z.getExtension("WEBGL_compressed_texture_astc")?["astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"]:[]],s$u):[]}let r$9;async function getSupportedGPUCompressedTextureFormats(){if(r$9)return r$9;const Z=await navigator.gpu.requestAdapter();return r$9=[...Z.features.has("texture-compression-bc")?["bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb"]:[],...Z.features.has("texture-compression-etc2")?["etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm"]:[],...Z.features.has("texture-compression-astc")?["astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"]:[]],r$9}let e$4;async function getSupportedCompressedTextureFormats(){return e$4!==void 0||(e$4=await(async()=>{const Z=await isWebGPUSupported(),X=isWebGLSupported();if(Z&&X){const K=await getSupportedGPUCompressedTextureFormats(),J=getSupportedGlCompressedTextureFormats();return K.filter(Q=>J.includes(Q))}else{if(Z)return await getSupportedGPUCompressedTextureFormats();if(X)return getSupportedGlCompressedTextureFormats()}return[]})()),e$4}const nonCompressedFormats=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8"];let r$8;async function getSupportedTextureFormats(){if(r$8!==void 0)return r$8;const Z=await getSupportedCompressedTextureFormats();return r$8=[...nonCompressedFormats,...Z],r$8}function decodeBase64(Z,X){var K=atob(Z);if(X){for(var J=new Uint8Array(K.length),Q=0,ee=K.length;Q<ee;++Q)J[Q]=K.charCodeAt(Q);return new TextDecoder("utf-16le").decode(new Uint16Array(J.buffer))}return K}function createURL(Z,X,K){var J=X===void 0?null:X,Q=K===void 0?!1:K,ee=decodeBase64(Z,Q),te=ee.indexOf(`
`,10)+1,re=ee.substring(te)+(J?"//# sourceMappingURL="+J:""),ne=new Blob([re],{type:"application/javascript"});return URL.createObjectURL(ne)}function createBase64WorkerFactory(Z,X,K){var J;return function(ee){return J=J||createURL(Z,X,K),new Worker(J,ee)}}var WorkerFactory$1=createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIGZ1bmN0aW9uIGNyZWF0ZUxldmVsQnVmZmVycyhiYXNpc1RleHR1cmUsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCkgewogICAgICBjb25zdCBpbWFnZXMgPSBiYXNpc1RleHR1cmUuZ2V0TnVtSW1hZ2VzKCk7CiAgICAgIGNvbnN0IGxldmVscyA9IGJhc2lzVGV4dHVyZS5nZXROdW1MZXZlbHMoMCk7CiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBiYXNpc1RleHR1cmUuc3RhcnRUcmFuc2NvZGluZygpOwogICAgICBpZiAoIXN1Y2Nlc3MpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInN0YXJ0VHJhbnNjb2RpbmcgZmFpbGVkIik7CiAgICAgIH0KICAgICAgY29uc3QgbGV2ZWxCdWZmZXJzID0gW107CiAgICAgIGZvciAobGV0IGxldmVsSW5kZXggPSAwOyBsZXZlbEluZGV4IDwgbGV2ZWxzOyArK2xldmVsSW5kZXgpIHsKICAgICAgICBmb3IgKGxldCBzbGljZUluZGV4ID0gMDsgc2xpY2VJbmRleCA8IGltYWdlczsgKytzbGljZUluZGV4KSB7CiAgICAgICAgICBjb25zdCB0cmFuc2NvZGVTaXplID0gYmFzaXNUZXh0dXJlLmdldEltYWdlVHJhbnNjb2RlZFNpemVJbkJ5dGVzKHNsaWNlSW5kZXgsIGxldmVsSW5kZXgsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCk7CiAgICAgICAgICBjb25zdCBsZXZlbEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRyYW5zY29kZVNpemUpOwogICAgICAgICAgY29uc3Qgc3VjY2VzczIgPSBiYXNpc1RleHR1cmUudHJhbnNjb2RlSW1hZ2UobGV2ZWxCdWZmZXIsIHNsaWNlSW5kZXgsIGxldmVsSW5kZXgsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCwgMSwgMCk7CiAgICAgICAgICBpZiAoIXN1Y2Nlc3MyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidHJhbnNjb2RlSW1hZ2UgZmFpbGVkIik7CiAgICAgICAgICB9CiAgICAgICAgICBsZXZlbEJ1ZmZlcnMucHVzaChsZXZlbEJ1ZmZlcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBsZXZlbEJ1ZmZlcnM7CiAgICB9CgogICAgY29uc3QgZ3B1Rm9ybWF0VG9CYXNpc1RyYW5zY29kZXJGb3JtYXRNYXAgPSB7CiAgICAgICJiYzMtcmdiYS11bm9ybSI6IDMsCiAgICAgIC8vIGNURkJDM19SR0JBCiAgICAgICJiYzctcmdiYS11bm9ybSI6IDYsCiAgICAgIC8vIGNURkJDN19SR0JBLAogICAgICAiZXRjMi1yZ2JhOHVub3JtIjogMSwKICAgICAgLy8gY1RGRVRDMl9SR0JBLAogICAgICAiYXN0Yy00eDQtdW5vcm0iOiAxMCwKICAgICAgLy8gY1RGQVNUQ180eDRfUkdCQSwKICAgICAgLy8gVW5jb21wcmVzc2VkCiAgICAgIHJnYmE4dW5vcm06IDEzLAogICAgICAvLyBjVEZSR0JBMzIsCiAgICAgIHJnYmE0dW5vcm06IDE2CiAgICAgIC8vIGNURlJHQkE0NDQ0LAogICAgfTsKICAgIGZ1bmN0aW9uIGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0KHRyYW5zY29kZXJGb3JtYXQpIHsKICAgICAgY29uc3QgZm9ybWF0ID0gZ3B1Rm9ybWF0VG9CYXNpc1RyYW5zY29kZXJGb3JtYXRNYXBbdHJhbnNjb2RlckZvcm1hdF07CiAgICAgIGlmIChmb3JtYXQpIHsKICAgICAgICByZXR1cm4gZm9ybWF0OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHJhbnNjb2RlckZvcm1hdDogJHt0cmFuc2NvZGVyRm9ybWF0fWApOwogICAgfQoKICAgIGNvbnN0IHNldHRpbmdzID0gewogICAgICBqc1VybDogImJhc2lzL2Jhc2lzX3RyYW5zY29kZXIuanMiLAogICAgICB3YXNtVXJsOiAiYmFzaXMvYmFzaXNfdHJhbnNjb2Rlci53YXNtIgogICAgfTsKICAgIGxldCBiYXNpc1RyYW5zY29kZXJGb3JtYXQ7CiAgICBsZXQgYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdDsKICAgIGxldCBiYXNpc1Byb21pc2U7CiAgICBhc3luYyBmdW5jdGlvbiBnZXRCYXNpcygpIHsKICAgICAgaWYgKCFiYXNpc1Byb21pc2UpIHsKICAgICAgICBjb25zdCBhYnNvbHV0ZUpzVXJsID0gbmV3IFVSTChzZXR0aW5ncy5qc1VybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIGNvbnN0IGFic29sdXRlV2FzbVVybCA9IG5ldyBVUkwoc2V0dGluZ3Mud2FzbVVybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpbXBvcnRTY3JpcHRzKGFic29sdXRlSnNVcmwpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUud2FybigiW1BpeGkuanNdIEZhaWxlZCB0byBsb2FkIEJhc2lzIGluIHdvcmtlciB2aWEgaW1wb3J0U2NyaXB0cy4gRmFsbGluZyBiYWNrIHRvIGV2YWwuIik7CiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlSnNVcmwpOwogICAgICAgICAgbGV0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7CiAgICAgICAgICB0ZXh0ICs9ICJcbnNlbGYuQkFTSVMgPSBCQVNJUzsiOwogICAgICAgICAgZXZhbCh0ZXh0KTsKICAgICAgICB9CiAgICAgICAgYmFzaXNQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIEJBU0lTKHsKICAgICAgICAgICAgbG9jYXRlRmlsZTogKF9maWxlKSA9PiBhYnNvbHV0ZVdhc21VcmwKICAgICAgICAgIH0pLnRoZW4oKG1vZHVsZSkgPT4gewogICAgICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZUJhc2lzKCk7CiAgICAgICAgICAgIHJlc29sdmUobW9kdWxlLkJhc2lzRmlsZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gYmFzaXNQcm9taXNlOwogICAgfQogICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hCYXNpc1RleHR1cmUodXJsLCBCYXNpc1RleHR1cmUpIHsKICAgICAgY29uc3QgYmFzaXNSZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7CiAgICAgIGlmIChiYXNpc1Jlc3BvbnNlLm9rKSB7CiAgICAgICAgY29uc3QgYmFzaXNBcnJheUJ1ZmZlciA9IGF3YWl0IGJhc2lzUmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICByZXR1cm4gbmV3IEJhc2lzVGV4dHVyZShuZXcgVWludDhBcnJheShiYXNpc0FycmF5QnVmZmVyKSk7CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBCYXNpcyB0ZXh0dXJlOiAke3VybH1gKTsKICAgIH0KICAgIGNvbnN0IHByZWZlcnJlZFRyYW5zY29kZWRGb3JtYXQgPSBbCiAgICAgICJldGMyLXJnYmE4dW5vcm0iLAogICAgICAiYmM3LXJnYmEtdW5vcm0iLAogICAgICAiYmMzLXJnYmEtdW5vcm0iLAogICAgICAiYXN0Yy00eDQtdW5vcm0iLAogICAgICAicmdiYTh1bm9ybSIKICAgIF07CiAgICBhc3luYyBmdW5jdGlvbiBsb2FkKHVybCkgewogICAgICBjb25zdCBCYXNpc1RleHR1cmUgPSBhd2FpdCBnZXRCYXNpcygpOwogICAgICBjb25zdCBiYXNpc1RleHR1cmUgPSBhd2FpdCBmZXRjaEJhc2lzVGV4dHVyZSh1cmwsIEJhc2lzVGV4dHVyZSk7CiAgICAgIGNvbnN0IGxldmVsQnVmZmVycyA9IGNyZWF0ZUxldmVsQnVmZmVycyhiYXNpc1RleHR1cmUsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCk7CiAgICAgIHJldHVybiB7CiAgICAgICAgd2lkdGg6IGJhc2lzVGV4dHVyZS5nZXRJbWFnZVdpZHRoKDAsIDApLAogICAgICAgIGhlaWdodDogYmFzaXNUZXh0dXJlLmdldEltYWdlSGVpZ2h0KDAsIDApLAogICAgICAgIGZvcm1hdDogYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdCwKICAgICAgICByZXNvdXJjZTogbGV2ZWxCdWZmZXJzLAogICAgICAgIGFscGhhTW9kZTogIm5vLXByZW11bHRpcGx5LWFscGhhIgogICAgICB9OwogICAgfQogICAgYXN5bmMgZnVuY3Rpb24gaW5pdChqc1VybCwgd2FzbVVybCwgc3VwcG9ydGVkVGV4dHVyZXMpIHsKICAgICAgaWYgKGpzVXJsKQogICAgICAgIHNldHRpbmdzLmpzVXJsID0ganNVcmw7CiAgICAgIGlmICh3YXNtVXJsKQogICAgICAgIHNldHRpbmdzLndhc21VcmwgPSB3YXNtVXJsOwogICAgICBiYXNpc1RyYW5zY29kZWRUZXh0dXJlRm9ybWF0ID0gcHJlZmVycmVkVHJhbnNjb2RlZEZvcm1hdC5maWx0ZXIoKGZvcm1hdCkgPT4gc3VwcG9ydGVkVGV4dHVyZXMuaW5jbHVkZXMoZm9ybWF0KSlbMF07CiAgICAgIGJhc2lzVHJhbnNjb2RlckZvcm1hdCA9IGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0KGJhc2lzVHJhbnNjb2RlZFRleHR1cmVGb3JtYXQpOwogICAgICBhd2FpdCBnZXRCYXNpcygpOwogICAgfQogICAgY29uc3QgbWVzc2FnZUhhbmRsZXJzID0gewogICAgICBpbml0OiBhc3luYyAoZGF0YSkgPT4gewogICAgICAgIGNvbnN0IHsganNVcmwsIHdhc21VcmwsIHN1cHBvcnRlZFRleHR1cmVzIH0gPSBkYXRhOwogICAgICAgIGF3YWl0IGluaXQoanNVcmwsIHdhc21VcmwsIHN1cHBvcnRlZFRleHR1cmVzKTsKICAgICAgfSwKICAgICAgbG9hZDogYXN5bmMgKGRhdGEpID0+IHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgdGV4dHVyZU9wdGlvbnMgPSBhd2FpdCBsb2FkKGRhdGEudXJsKTsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICJsb2FkIiwKICAgICAgICAgICAgdXJsOiBkYXRhLnVybCwKICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSwKICAgICAgICAgICAgdGV4dHVyZU9wdGlvbnMsCiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXM6IHRleHR1cmVPcHRpb25zLnJlc291cmNlPy5tYXAoKGFycikgPT4gYXJyLmJ1ZmZlcikKICAgICAgICAgIH07CiAgICAgICAgfSBjYXRjaCAoZTIpIHsKICAgICAgICAgIHRocm93IGUyOwogICAgICAgIH0KICAgICAgfQogICAgfTsKICAgIHNlbGYub25tZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2VFdmVudCkgPT4gewogICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZUV2ZW50LmRhdGE7CiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IG1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlLnR5cGVdKG1lc3NhZ2UpOwogICAgICBpZiAocmVzcG9uc2UyKSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZTIsIHJlc3BvbnNlMi50cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgfTsKCn0pKCk7Cgo=",null,!1);const basisTranscoderUrls={jsUrl:"https://files.pixijs.download/transcoders/basis/basis_transcoder.js",wasmUrl:"https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"};function setBasisTranscoderPath(Z){Object.assign(basisTranscoderUrls,Z)}let r$7;const i$l={};function c$m(Z){return r$7||(r$7=new WorkerFactory$1,r$7.onmessage=X=>{const{success:K,url:J,textureOptions:Q}=X.data;K||console.warn("Failed to load Basis texture",J),i$l[J](Q)},r$7.postMessage({type:"init",jsUrl:basisTranscoderUrls.jsUrl,wasmUrl:basisTranscoderUrls.wasmUrl,supportedTextures:Z})),r$7}function loadBasisOnWorker(Z,X){const K=c$m(X);return new Promise(J=>{i$l[Z]=J,K.postMessage({type:"load",url:Z})})}const loadBasis={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.High},name:"loadBasis",test(Z){return checkExtension(Z,[".basis"])},async load(Z,X,K){const J=await getSupportedTextureFormats(),Q=await loadBasisOnWorker(Z,J),ee=new CompressedSource(Q);return createTexture(ee,K,Z)},unload(Z){Array.isArray(Z)?Z.forEach(X=>X.destroy(!0)):Z.destroy(!0)}};b$r.add(loadBasis,detectBasis);function createLevelBuffers(Z,X){const K=Z.getNumImages(),J=Z.getNumLevels(0);if(!Z.startTranscoding())throw new Error("startTranscoding failed");const Q=[];for(let ee=0;ee<J;++ee)for(let te=0;te<K;++te){const re=Z.getImageTranscodedSizeInBytes(te,ee,X),ne=new Uint8Array(re);if(!Z.transcodeImage(ne,te,ee,X,1,0))throw new Error("transcodeImage failed");Q.push(ne)}return Q}const n$s={"bc3-rgba-unorm":3,"bc7-rgba-unorm":6,"etc2-rgba8unorm":1,"astc-4x4-unorm":10,rgba8unorm:13,rgba4unorm:16};function gpuFormatToBasisTranscoderFormat(Z){const X=n$s[Z];if(X)return X;throw new Error(`Unsupported transcoderFormat: ${Z}`)}const settings$1={jsUrl:"basis/basis_transcoder.js",wasmUrl:"basis/basis_transcoder.wasm"};let basisTranscoderFormat$1,basisTranscodedTextureFormat$1,basisPromise;async function getBasis(){if(!basisPromise){const absoluteJsUrl=new URL(settings$1.jsUrl,location.origin).href,absoluteWasmUrl=new URL(settings$1.wasmUrl,location.origin).href;try{importScripts(absoluteJsUrl)}catch(e){const response=await fetch(absoluteJsUrl);let text=await response.text();text+=`
self.BASIS = BASIS;`,eval(text)}basisPromise=new Promise(Z=>{BASIS({locateFile:X=>absoluteWasmUrl}).then(X=>{X.initializeBasis(),Z(X.BasisFile)})})}return basisPromise}async function fetchBasisTexture(Z,X){const K=await fetch(Z);if(K.ok){const J=await K.arrayBuffer();return new X(new Uint8Array(J))}throw new Error(`Failed to load Basis texture: ${Z}`)}const preferredTranscodedFormat$1=["etc2-rgba8unorm","bc7-rgba-unorm","bc3-rgba-unorm","astc-4x4-unorm","rgba8unorm"];async function load$1(Z){const X=await getBasis(),K=await fetchBasisTexture(Z,X),J=createLevelBuffers(K,basisTranscoderFormat$1);return{width:K.getImageWidth(0,0),height:K.getImageHeight(0,0),format:basisTranscodedTextureFormat$1,resource:J,alphaMode:"no-premultiply-alpha"}}async function init$1(Z,X,K){Z&&(settings$1.jsUrl=Z),X&&(settings$1.wasmUrl=X),basisTranscodedTextureFormat$1=preferredTranscodedFormat$1.filter(J=>K.includes(J))[0],basisTranscoderFormat$1=gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat$1),await getBasis()}const messageHandlers$1={init:async Z=>{const{jsUrl:X,wasmUrl:K,supportedTextures:J}=Z;await init$1(X,K,J)},load:async Z=>{var X;try{const K=await load$1(Z.url);return{type:"load",url:Z.url,success:!0,textureOptions:K,transferables:(X=K.resource)==null?void 0:X.map(J=>J.buffer)}}catch(K){throw K}}};self.onmessage=async Z=>{const X=Z.data,K=await messageHandlers$1[X.type](X);K&&self.postMessage(K,K.transferables)};const validFormats=["basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"],resolveCompressedTextureUrl={extension:u$z.ResolveParser,test:Z=>checkExtension(Z,[".ktx",".ktx2",".dds"]),parse:Z=>{var X,K;let J;const Q=Z.split(".");if(Q.length>2){const ee=Q[Q.length-2];validFormats.includes(ee),J=ee}else J=Q[Q.length-1];return{resolution:parseFloat((K=(X=Resolver.RETINA_PREFIX.exec(Z))==null?void 0:X[1])!=null?K:"1"),format:J,src:Z}}};let s$t;const detectCompressed={extension:{type:u$z.DetectionParser,priority:2},test:async()=>!!(await isWebGPUSupported()||isWebGLSupported()),add:async Z=>{const X=await getSupportedCompressedTextureFormats();return s$t=f$r(X),[...s$t,...Z]},remove:async Z=>s$t?Z.filter(X=>!(X in s$t)):Z};function f$r(Z){const X=["basis"],K={};return Z.forEach(J=>{const Q=J.split("-")[0];Q&&!K[Q]&&(K[Q]=!0,X.push(Q))}),X.sort((J,Q)=>{const ee=validFormats.indexOf(J),te=validFormats.indexOf(Q);return ee===-1?1:te===-1?-1:ee-te}),X}const G=542327876,H$3=131072,L=4;function p$x(Z){return Z.charCodeAt(0)+(Z.charCodeAt(1)<<8)+(Z.charCodeAt(2)<<16)+(Z.charCodeAt(3)<<24)}function l$l(Z){return String.fromCharCode(Z&255,Z>>8&255,Z>>16&255,Z>>24&255)}const T$9=p$x("DXT1"),g$m=p$x("DXT3"),O$6=p$x("DXT5"),b$j=31,A$5=0,F$3=1,S$6=2,U$1=3,B$2=4,R$1=7,y$d=20,_$5=21,w$5=22,k$1=23,I$1=24,P$6=25;function parseDDS(Z,X){const K=new Int32Array(Z,0,b$j);if(K[A$5]!==542327876)throw new Error("Invalid magic number in DDS header");if((K[y$d]===0?1:0)&4)throw new Error("Unsupported format, must contain a FourCC code");const J=K[_$5];let Q=0,ee=0,te;switch(J){case T$9:Q=8,te="bc1-rgba-unorm";break;case g$m:Q=16,te="bc2-rgba-unorm";break;case O$6:Q=16,te="bc3-rgba-unorm";break;default:{const ce=K[w$5],de=K[k$1],he=K[I$1],pe=K[P$6];ce===32&&(de&255&&he&65280&&pe&16711680?(te="rgba8unorm",ee=4):de&16711680&&he&65280&&pe&255&&(te="bgra8unorm",ee=4))}}const re=K[B$2],ne=K[U$1];let ie=K[F$3]+4;if(X.indexOf(te)===-1)throw new Error(`Unsupported texture format: ${l$l(J)} ${te}`);if(Q===0)return{format:te,width:re,height:ne,resource:[new Uint8Array(Z,ie,re*ne*ee)],alphaMode:"no-premultiply-alpha"};let se=1;K[S$6]&131072&&(se=Math.max(1,K[R$1]));const oe=[];let ae=re,le=ne;for(let ce=0;ce<se;++ce){const de=Q?Math.max(4,ae)/4*Math.max(4,le)/4*Q:ae*le*4,he=new Uint8Array(Z,ie,de);oe.push(he),ie+=de,ae=Math.max(ae>>1,1),le=Math.max(le>>1,1)}return{format:te,width:re,height:ne,resource:oe,alphaMode:"no-premultiply-alpha"}}const loadDDS={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.High},name:"loadDDS",test(Z){return checkExtension(Z,[".dds"])},async load(Z,X,K){const J=await getSupportedTextureFormats(),Q=await(await fetch(Z)).arrayBuffer(),ee=parseDDS(Q,J),te=new CompressedSource(ee);return createTexture(te,K,Z)},unload(Z){Array.isArray(Z)?Z.forEach(X=>X.destroy(!0)):Z.destroy(!0)}};b$r.add(loadDDS,detectCompressed,resolveCompressedTextureUrl);var WorkerFactory=createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIGNvbnN0IGNvbnZlcnRlcnMgPSB7CiAgICAgIHJnYjh1bm9ybTogewogICAgICAgIGNvbnZlcnRlZEZvcm1hdDogInJnYmE4dW5vcm0iLAogICAgICAgIGNvbnZlcnRGdW5jdGlvbjogY29udmVydFJHQnRvUkdCQQogICAgICB9LAogICAgICAicmdiOHVub3JtLXNyZ2IiOiB7CiAgICAgICAgY29udmVydGVkRm9ybWF0OiAicmdiYTh1bm9ybS1zcmdiIiwKICAgICAgICBjb252ZXJ0RnVuY3Rpb246IGNvbnZlcnRSR0J0b1JHQkEKICAgICAgfQogICAgfTsKICAgIGZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRJZlJlcXVpcmVkKHRleHR1cmVPcHRpb25zKSB7CiAgICAgIGNvbnN0IGZvcm1hdCA9IHRleHR1cmVPcHRpb25zLmZvcm1hdDsKICAgICAgaWYgKGNvbnZlcnRlcnNbZm9ybWF0XSkgewogICAgICAgIGNvbnN0IGNvbnZlcnRGdW5jdGlvbiA9IGNvbnZlcnRlcnNbZm9ybWF0XS5jb252ZXJ0RnVuY3Rpb247CiAgICAgICAgY29uc3QgbGV2ZWxCdWZmZXJzID0gdGV4dHVyZU9wdGlvbnMucmVzb3VyY2U7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbEJ1ZmZlcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGxldmVsQnVmZmVyc1tpXSA9IGNvbnZlcnRGdW5jdGlvbihsZXZlbEJ1ZmZlcnNbaV0pOwogICAgICAgIH0KICAgICAgICB0ZXh0dXJlT3B0aW9ucy5mb3JtYXQgPSBjb252ZXJ0ZXJzW2Zvcm1hdF0uY29udmVydGVkRm9ybWF0OwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBjb252ZXJ0UkdCdG9SR0JBKGxldmVsQnVmZmVyKSB7CiAgICAgIGNvbnN0IHBpeGVsQ291bnQgPSBsZXZlbEJ1ZmZlci5ieXRlTGVuZ3RoIC8gMzsKICAgICAgY29uc3QgbGV2ZWxCdWZmZXJXaXRoQWxwaGEgPSBuZXcgVWludDMyQXJyYXkocGl4ZWxDb3VudCk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGl4ZWxDb3VudDsgKytpKSB7CiAgICAgICAgbGV2ZWxCdWZmZXJXaXRoQWxwaGFbaV0gPSBsZXZlbEJ1ZmZlcltpICogM10gKyAobGV2ZWxCdWZmZXJbaSAqIDMgKyAxXSA8PCA4KSArIChsZXZlbEJ1ZmZlcltpICogMyArIDJdIDw8IDE2KSArIDQyNzgxOTAwODA7CiAgICAgIH0KICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxldmVsQnVmZmVyV2l0aEFscGhhLmJ1ZmZlcik7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlTGV2ZWxCdWZmZXJzRnJvbUtUWChrdHhUZXh0dXJlKSB7CiAgICAgIGNvbnN0IGxldmVsQnVmZmVycyA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGt0eFRleHR1cmUubnVtTGV2ZWxzOyBpKyspIHsKICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBrdHhUZXh0dXJlLmdldEltYWdlRGF0YShpLCAwLCAwKTsKICAgICAgICBjb25zdCBsZXZlbEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGltYWdlRGF0YS5ieXRlTGVuZ3RoKTsKICAgICAgICBsZXZlbEJ1ZmZlci5zZXQoaW1hZ2VEYXRhKTsKICAgICAgICBsZXZlbEJ1ZmZlcnMucHVzaChsZXZlbEJ1ZmZlcik7CiAgICAgIH0KICAgICAgcmV0dXJuIGxldmVsQnVmZmVyczsKICAgIH0KCiAgICBjb25zdCBnbEZvcm1hdFRvR1BVRm9ybWF0TWFwID0gewogICAgICA2NDA4OiAicmdiYTh1bm9ybSIsCiAgICAgIDMyODU2OiAiYmdyYTh1bm9ybSIsCiAgICAgIC8vCiAgICAgIDMyODU3OiAicmdiMTBhMnVub3JtIiwKICAgICAgMzMxODk6ICJkZXB0aDE2dW5vcm0iLAogICAgICAzMzE5MDogImRlcHRoMjRwbHVzIiwKICAgICAgMzMzMjE6ICJyOHVub3JtIiwKICAgICAgMzMzMjM6ICJyZzh1bm9ybSIsCiAgICAgIDMzMzI1OiAicjE2ZmxvYXQiLAogICAgICAzMzMyNjogInIzMmZsb2F0IiwKICAgICAgMzMzMjc6ICJyZzE2ZmxvYXQiLAogICAgICAzMzMyODogInJnMzJmbG9hdCIsCiAgICAgIDMzMzI5OiAicjhzaW50IiwKICAgICAgMzMzMzA6ICJyOHVpbnQiLAogICAgICAzMzMzMTogInIxNnNpbnQiLAogICAgICAzMzMzMjogInIxNnVpbnQiLAogICAgICAzMzMzMzogInIzMnNpbnQiLAogICAgICAzMzMzNDogInIzMnVpbnQiLAogICAgICAzMzMzNTogInJnOHNpbnQiLAogICAgICAzMzMzNjogInJnOHVpbnQiLAogICAgICAzMzMzNzogInJnMTZzaW50IiwKICAgICAgMzMzMzg6ICJyZzE2dWludCIsCiAgICAgIDMzMzM5OiAicmczMnNpbnQiLAogICAgICAzMzM0MDogInJnMzJ1aW50IiwKICAgICAgMzM3Nzg6ICJiYzItcmdiYS11bm9ybSIsCiAgICAgIDMzNzc5OiAiYmMzLXJnYmEtdW5vcm0iLAogICAgICAzNDgzNjogInJnYmEzMmZsb2F0IiwKICAgICAgMzQ4NDI6ICJyZ2JhMTZmbG9hdCIsCiAgICAgIDM1MDU2OiAiZGVwdGgyNHBsdXMtc3RlbmNpbDgiLAogICAgICAzNTg5ODogInJnMTFiMTB1ZmxvYXQiLAogICAgICAzNTkwMTogInJnYjllNXVmbG9hdCIsCiAgICAgIDM1OTA3OiAicmdiYTh1bm9ybS1zcmdiIiwKICAgICAgLy8gYmdyYTh1bm9ybS1zcmdiCiAgICAgIDM2MDEyOiAiZGVwdGgzMmZsb2F0IiwKICAgICAgMzYwMTM6ICJkZXB0aDMyZmxvYXQtc3RlbmNpbDgiLAogICAgICAzNjE2ODogInN0ZW5jaWw4IiwKICAgICAgMzYyMDg6ICJyZ2JhMzJ1aW50IiwKICAgICAgMzYyMTQ6ICJyZ2JhMTZ1aW50IiwKICAgICAgMzYyMjA6ICJyZ2JhOHVpbnQiLAogICAgICAzNjIyNjogInJnYmEzMnNpbnQiLAogICAgICAzNjIzMjogInJnYmExNnNpbnQiLAogICAgICAzNjIzODogInJnYmE4c2ludCIsCiAgICAgIDM2NDkyOiAiYmM3LXJnYmEtdW5vcm0iLAogICAgICAzNjc1NjogInI4c25vcm0iLAogICAgICAzNjc1NzogInJnOHNub3JtIiwKICAgICAgMzY3NTk6ICJyZ2JhOHNub3JtIiwKICAgICAgMzc0OTY6ICJldGMyLXJnYmE4dW5vcm0iLAogICAgICAzNzgwODogImFzdGMtNHg0LXVub3JtIgogICAgfTsKICAgIGZ1bmN0aW9uIGdsRm9ybWF0VG9HUFVGb3JtYXQoZ2xJbnRlcm5hbEZvcm1hdCkgewogICAgICBjb25zdCBmb3JtYXQgPSBnbEZvcm1hdFRvR1BVRm9ybWF0TWFwW2dsSW50ZXJuYWxGb3JtYXRdOwogICAgICBpZiAoZm9ybWF0KSB7CiAgICAgICAgcmV0dXJuIGZvcm1hdDsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGdsSW50ZXJuYWxGb3JtYXQ6ICR7Z2xJbnRlcm5hbEZvcm1hdH1gKTsKICAgIH0KCiAgICBjb25zdCB2a0Zvcm1hdFRvR1BVRm9ybWF0TWFwID0gewogICAgICAyMzogInJnYjh1bm9ybSIsCiAgICAgIC8vIFZLX0ZPUk1BVF9SOEc4QjhfVU5PUk0KICAgICAgMzc6ICJyZ2JhOHVub3JtIiwKICAgICAgLy8gVktfRk9STUFUX1I4RzhCOEE4X1VOT1JNCiAgICAgIDQzOiAicmdiYTh1bm9ybS1zcmdiIgogICAgICAvLyBWS19GT1JNQVRfUjhHOEI4QThfU1JHQgogICAgICAvLyBUT0RPIGFkZCBtb3JlIQogICAgfTsKICAgIGZ1bmN0aW9uIHZrRm9ybWF0VG9HUFVGb3JtYXQodmtGb3JtYXQpIHsKICAgICAgY29uc3QgZm9ybWF0ID0gdmtGb3JtYXRUb0dQVUZvcm1hdE1hcFt2a0Zvcm1hdF07CiAgICAgIGlmIChmb3JtYXQpIHsKICAgICAgICByZXR1cm4gZm9ybWF0OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVmtGb3JtYXQ6ICR7dmtGb3JtYXR9YCk7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0VGV4dHVyZUZvcm1hdEZyb21LVFhUZXh0dXJlKGt0eFRleHR1cmUpIHsKICAgICAgaWYgKGt0eFRleHR1cmUuY2xhc3NJZCA9PT0gMikgewogICAgICAgIHJldHVybiB2a0Zvcm1hdFRvR1BVRm9ybWF0KGt0eFRleHR1cmUudmtGb3JtYXQpOwogICAgICB9CiAgICAgIHJldHVybiBnbEZvcm1hdFRvR1BVRm9ybWF0KGt0eFRleHR1cmUuZ2xJbnRlcm5hbGZvcm1hdCk7CiAgICB9CgogICAgY29uc3QgZ3B1Rm9ybWF0VG9CYXNpc1RyYW5zY29kZXJGb3JtYXRNYXAgPSB7CiAgICAgICJiYzMtcmdiYS11bm9ybSI6ICJCQzNfUkdCQSIsCiAgICAgICJiYzctcmdiYS11bm9ybSI6ICJCQzdfTTVfUkdCQSIsCiAgICAgICJldGMyLXJnYmE4dW5vcm0iOiAiRVRDMl9SR0JBIiwKICAgICAgImFzdGMtNHg0LXVub3JtIjogIkFTVENfNHg0X1JHQkEiLAogICAgICAvLyBVbmNvbXByZXNzZWQKICAgICAgcmdiYTh1bm9ybTogIlJHQkEzMiIsCiAgICAgIHJnMTFiMTB1ZmxvYXQ6ICJSMTFGX0cxMUZfQjEwRiIKICAgIH07CiAgICBmdW5jdGlvbiBncHVGb3JtYXRUb0tUWEJhc2lzVHJhbnNjb2RlckZvcm1hdCh0cmFuc2NvZGVyRm9ybWF0KSB7CiAgICAgIGNvbnN0IGZvcm1hdCA9IGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0TWFwW3RyYW5zY29kZXJGb3JtYXRdOwogICAgICBpZiAoZm9ybWF0KSB7CiAgICAgICAgcmV0dXJuIGZvcm1hdDsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRyYW5zY29kZXJGb3JtYXQ6ICR7dHJhbnNjb2RlckZvcm1hdH1gKTsKICAgIH0KCiAgICBjb25zdCBzZXR0aW5ncyA9IHsKICAgICAganNVcmw6ICIiLAogICAgICB3YXNtVXJsOiAiIgogICAgfTsKICAgIGxldCBiYXNpc1RyYW5zY29kZXJGb3JtYXQ7CiAgICBsZXQgYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdDsKICAgIGxldCBrdHhQcm9taXNlOwogICAgYXN5bmMgZnVuY3Rpb24gZ2V0S1RYKCkgewogICAgICBpZiAoIWt0eFByb21pc2UpIHsKICAgICAgICBjb25zdCBhYnNvbHV0ZUpzVXJsID0gbmV3IFVSTChzZXR0aW5ncy5qc1VybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIGNvbnN0IGFic29sdXRlV2FzbVVybCA9IG5ldyBVUkwoc2V0dGluZ3Mud2FzbVVybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpbXBvcnRTY3JpcHRzKGFic29sdXRlSnNVcmwpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUud2FybigiRmFpbGVkIHRvIGxvYWQgS1RYKDIpIGluIHdvcmtlciB2aWEgaW1wb3J0U2NyaXB0cy4gRmFsbGluZyBiYWNrIHRvIGV2YWwuIik7CiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlSnNVcmwpOwogICAgICAgICAgbGV0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7CiAgICAgICAgICB0ZXh0ICs9ICJcbnNlbGYuTElCS1RYID0gTElCS1RYOyI7CiAgICAgICAgICBldmFsKHRleHQpOwogICAgICAgIH0KICAgICAgICBrdHhQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIExJQktUWCh7CiAgICAgICAgICAgIGxvY2F0ZUZpbGU6IChfZmlsZSkgPT4gYWJzb2x1dGVXYXNtVXJsCiAgICAgICAgICB9KS50aGVuKChsaWJrdHgpID0+IHsKICAgICAgICAgICAgcmVzb2x2ZShsaWJrdHgpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGt0eFByb21pc2U7CiAgICB9CiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaEtUWFRleHR1cmUodXJsLCBrdHgpIHsKICAgICAgY29uc3Qga3R4MlJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTsKICAgICAgaWYgKGt0eDJSZXNwb25zZS5vaykgewogICAgICAgIGNvbnN0IGt0eDJBcnJheUJ1ZmZlciA9IGF3YWl0IGt0eDJSZXNwb25zZS5hcnJheUJ1ZmZlcigpOwogICAgICAgIHJldHVybiBuZXcga3R4Lmt0eFRleHR1cmUobmV3IFVpbnQ4QXJyYXkoa3R4MkFycmF5QnVmZmVyKSk7CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBLVFgoMikgdGV4dHVyZTogJHt1cmx9YCk7CiAgICB9CiAgICBjb25zdCBwcmVmZXJyZWRUcmFuc2NvZGVkRm9ybWF0ID0gWwogICAgICAiZXRjMi1yZ2JhOHVub3JtIiwKICAgICAgImJjNy1yZ2JhLXVub3JtIiwKICAgICAgImJjMy1yZ2JhLXVub3JtIiwKICAgICAgImFzdGMtNHg0LXVub3JtIiwKICAgICAgInJnYmE4dW5vcm0iCiAgICBdOwogICAgYXN5bmMgZnVuY3Rpb24gbG9hZCh1cmwpIHsKICAgICAgY29uc3Qga3R4ID0gYXdhaXQgZ2V0S1RYKCk7CiAgICAgIGNvbnN0IGt0eFRleHR1cmUgPSBhd2FpdCBmZXRjaEtUWFRleHR1cmUodXJsLCBrdHgpOwogICAgICBsZXQgZm9ybWF0OwogICAgICBpZiAoa3R4VGV4dHVyZS5uZWVkc1RyYW5zY29kaW5nKSB7CiAgICAgICAgZm9ybWF0ID0gYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdDsKICAgICAgICBjb25zdCB0cmFuc2NvZGVGb3JtYXQgPSBrdHguVHJhbnNjb2RlVGFyZ2V0W2Jhc2lzVHJhbnNjb2RlckZvcm1hdF07CiAgICAgICAgY29uc3QgcmVzdWx0ID0ga3R4VGV4dHVyZS50cmFuc2NvZGVCYXNpcyh0cmFuc2NvZGVGb3JtYXQsIDApOwogICAgICAgIGlmIChyZXN1bHQgIT09IGt0eC5FcnJvckNvZGUuU1VDQ0VTUykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gdHJhbnNjb2RlIGJhc2lzIHRleHR1cmUuIik7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZShrdHhUZXh0dXJlKTsKICAgICAgfQogICAgICBjb25zdCBsZXZlbEJ1ZmZlcnMgPSBjcmVhdGVMZXZlbEJ1ZmZlcnNGcm9tS1RYKGt0eFRleHR1cmUpOwogICAgICBjb25zdCB0ZXh0dXJlT3B0aW9ucyA9IHsKICAgICAgICB3aWR0aDoga3R4VGV4dHVyZS5iYXNlV2lkdGgsCiAgICAgICAgaGVpZ2h0OiBrdHhUZXh0dXJlLmJhc2VIZWlnaHQsCiAgICAgICAgZm9ybWF0LAogICAgICAgIG1pcExldmVsQ291bnQ6IGt0eFRleHR1cmUubnVtTGV2ZWxzLAogICAgICAgIHJlc291cmNlOiBsZXZlbEJ1ZmZlcnMsCiAgICAgICAgYWxwaGFNb2RlOiAibm8tcHJlbXVsdGlwbHktYWxwaGEiCiAgICAgIH07CiAgICAgIGNvbnZlcnRGb3JtYXRJZlJlcXVpcmVkKHRleHR1cmVPcHRpb25zKTsKICAgICAgcmV0dXJuIHRleHR1cmVPcHRpb25zOwogICAgfQogICAgYXN5bmMgZnVuY3Rpb24gaW5pdChqc1VybCwgd2FzbVVybCwgc3VwcG9ydGVkVGV4dHVyZXMpIHsKICAgICAgaWYgKGpzVXJsKQogICAgICAgIHNldHRpbmdzLmpzVXJsID0ganNVcmw7CiAgICAgIGlmICh3YXNtVXJsKQogICAgICAgIHNldHRpbmdzLndhc21VcmwgPSB3YXNtVXJsOwogICAgICBiYXNpc1RyYW5zY29kZWRUZXh0dXJlRm9ybWF0ID0gcHJlZmVycmVkVHJhbnNjb2RlZEZvcm1hdC5maWx0ZXIoKGZvcm1hdCkgPT4gc3VwcG9ydGVkVGV4dHVyZXMuaW5jbHVkZXMoZm9ybWF0KSlbMF07CiAgICAgIGJhc2lzVHJhbnNjb2RlckZvcm1hdCA9IGdwdUZvcm1hdFRvS1RYQmFzaXNUcmFuc2NvZGVyRm9ybWF0KGJhc2lzVHJhbnNjb2RlZFRleHR1cmVGb3JtYXQpOwogICAgICBhd2FpdCBnZXRLVFgoKTsKICAgIH0KICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVycyA9IHsKICAgICAgaW5pdDogYXN5bmMgKGRhdGEpID0+IHsKICAgICAgICBjb25zdCB7IGpzVXJsLCB3YXNtVXJsLCBzdXBwb3J0ZWRUZXh0dXJlcyB9ID0gZGF0YTsKICAgICAgICBhd2FpdCBpbml0KGpzVXJsLCB3YXNtVXJsLCBzdXBwb3J0ZWRUZXh0dXJlcyk7CiAgICAgIH0sCiAgICAgIGxvYWQ6IGFzeW5jIChkYXRhKSA9PiB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IHRleHR1cmVPcHRpb25zID0gYXdhaXQgbG9hZChkYXRhLnVybCk7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICB0eXBlOiAibG9hZCIsCiAgICAgICAgICAgIHVybDogZGF0YS51cmwsCiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsCiAgICAgICAgICAgIHRleHR1cmVPcHRpb25zLAogICAgICAgICAgICB0cmFuc2ZlcmFibGVzOiB0ZXh0dXJlT3B0aW9ucy5yZXNvdXJjZT8ubWFwKChhcnIpID0+IGFyci5idWZmZXIpCiAgICAgICAgICB9OwogICAgICAgIH0gY2F0Y2ggKGUyKSB7CiAgICAgICAgICB0aHJvdyBlMjsKICAgICAgICB9CiAgICAgIH0KICAgIH07CiAgICBzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VFdmVudC5kYXRhOwogICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBtZXNzYWdlSGFuZGxlcnNbbWVzc2FnZS50eXBlXT8uKG1lc3NhZ2UpOwogICAgICBpZiAocmVzcG9uc2UyKSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZTIsIHJlc3BvbnNlMi50cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgfTsKCn0pKCk7Cgo=",null,!1);const ktxTranscoderUrls={jsUrl:"https://files.pixijs.download/transcoders/ktx/libktx.js",wasmUrl:"https://files.pixijs.download/transcoders/ktx/libktx.wasm"};function setKTXTranscoderPath(Z){Object.assign(ktxTranscoderUrls,Z)}let r$6;const i$k={};function T$8(Z){return r$6||(r$6=new WorkerFactory,r$6.onmessage=X=>{const{success:K,url:J,textureOptions:Q}=X.data;K||console.warn("Failed to load KTX texture",J),i$k[J](Q)},r$6.postMessage({type:"init",jsUrl:ktxTranscoderUrls.jsUrl,wasmUrl:ktxTranscoderUrls.wasmUrl,supportedTextures:Z})),r$6}function loadKTX2onWorker(Z,X){const K=T$8(X);return new Promise(J=>{i$k[Z]=J,K.postMessage({type:"load",url:Z})})}const loadKTX={extension:{type:u$z.LoadParser,priority:LoaderParserPriority.High},name:"loadKTX",test(Z){return checkExtension(Z,[".ktx2",".ktx"])},async load(Z,X,K){const J=await getSupportedTextureFormats(),Q=await loadKTX2onWorker(Z,J),ee=new CompressedSource(Q);return createTexture(ee,K,Z)},unload(Z){Array.isArray(Z)?Z.forEach(X=>X.destroy(!0)):Z.destroy(!0)}};b$r.add(loadKTX),b$r.add(resolveCompressedTextureUrl),b$r.add(detectCompressed);function createLevelBuffersFromKTX(Z){const X=[];for(let K=0;K<Z.numLevels;K++){const J=Z.getImageData(K,0,0),Q=new Uint8Array(J.byteLength);Q.set(J),X.push(Q)}return X}const n$r={6408:"rgba8unorm",32856:"bgra8unorm",32857:"rgb10a2unorm",33189:"depth16unorm",33190:"depth24plus",33321:"r8unorm",33323:"rg8unorm",33325:"r16float",33326:"r32float",33327:"rg16float",33328:"rg32float",33329:"r8sint",33330:"r8uint",33331:"r16sint",33332:"r16uint",33333:"r32sint",33334:"r32uint",33335:"rg8sint",33336:"rg8uint",33337:"rg16sint",33338:"rg16uint",33339:"rg32sint",33340:"rg32uint",33778:"bc2-rgba-unorm",33779:"bc3-rgba-unorm",34836:"rgba32float",34842:"rgba16float",35056:"depth24plus-stencil8",35898:"rg11b10ufloat",35901:"rgb9e5ufloat",35907:"rgba8unorm-srgb",36012:"depth32float",36013:"depth32float-stencil8",36168:"stencil8",36208:"rgba32uint",36214:"rgba16uint",36220:"rgba8uint",36226:"rgba32sint",36232:"rgba16sint",36238:"rgba8sint",36492:"bc7-rgba-unorm",36756:"r8snorm",36757:"rg8snorm",36759:"rgba8snorm",37496:"etc2-rgba8unorm",37808:"astc-4x4-unorm"};function glFormatToGPUFormat(Z){const X=n$r[Z];if(X)return X;throw new Error(`Unsupported glInternalFormat: ${Z}`)}const t$b={23:"rgb8unorm",37:"rgba8unorm",43:"rgba8unorm-srgb"};function vkFormatToGPUFormat(Z){const X=t$b[Z];if(X)return X;throw new Error(`Unsupported VkFormat: ${Z}`)}function getTextureFormatFromKTXTexture(Z){return Z.classId===2?vkFormatToGPUFormat(Z.vkFormat):glFormatToGPUFormat(Z.glInternalformat)}const t$a={"bc3-rgba-unorm":"BC3_RGBA","bc7-rgba-unorm":"BC7_M5_RGBA","etc2-rgba8unorm":"ETC2_RGBA","astc-4x4-unorm":"ASTC_4x4_RGBA",rgba8unorm:"RGBA32",rg11b10ufloat:"R11F_G11F_B10F"};function gpuFormatToKTXBasisTranscoderFormat(Z){const X=t$a[Z];if(X)return X;throw new Error(`Unsupported transcoderFormat: ${Z}`)}const c$l={rgb8unorm:{convertedFormat:"rgba8unorm",convertFunction:i$j},"rgb8unorm-srgb":{convertedFormat:"rgba8unorm-srgb",convertFunction:i$j}};function convertFormatIfRequired(Z){const X=Z.format;if(c$l[X]){const K=c$l[X].convertFunction,J=Z.resource;for(let Q=0;Q<J.length;Q++)J[Q]=K(J[Q]);Z.format=c$l[X].convertedFormat}}function i$j(Z){const X=Z.byteLength/3,K=new Uint32Array(X);for(let J=0;J<X;++J)K[J]=Z[J*3]+(Z[J*3+1]<<8)+(Z[J*3+2]<<16)+4278190080;return new Uint8Array(K.buffer)}const settings={jsUrl:"",wasmUrl:""};let basisTranscoderFormat,basisTranscodedTextureFormat,ktxPromise;async function getKTX(){if(!ktxPromise){const absoluteJsUrl=new URL(settings.jsUrl,location.origin).href,absoluteWasmUrl=new URL(settings.wasmUrl,location.origin).href;try{importScripts(absoluteJsUrl)}catch(e){const response=await fetch(absoluteJsUrl);let text=await response.text();text+=`
self.LIBKTX = LIBKTX;`,eval(text)}ktxPromise=new Promise(Z=>{LIBKTX({locateFile:X=>absoluteWasmUrl}).then(X=>{Z(X)})})}return ktxPromise}async function fetchKTXTexture(Z,X){const K=await fetch(Z);if(K.ok){const J=await K.arrayBuffer();return new X.ktxTexture(new Uint8Array(J))}throw new Error(`Failed to load KTX(2) texture: ${Z}`)}const preferredTranscodedFormat=["etc2-rgba8unorm","bc7-rgba-unorm","bc3-rgba-unorm","astc-4x4-unorm","rgba8unorm"];async function load(Z){const X=await getKTX(),K=await fetchKTXTexture(Z,X);let J;if(K.needsTranscoding){J=basisTranscodedTextureFormat;const te=X.TranscodeTarget[basisTranscoderFormat];if(K.transcodeBasis(te,0)!==X.ErrorCode.SUCCESS)throw new Error("Unable to transcode basis texture.")}else J=getTextureFormatFromKTXTexture(K);const Q=createLevelBuffersFromKTX(K),ee={width:K.baseWidth,height:K.baseHeight,format:J,mipLevelCount:K.numLevels,resource:Q,alphaMode:"no-premultiply-alpha"};return convertFormatIfRequired(ee),ee}async function init(Z,X,K){Z&&(settings.jsUrl=Z),X&&(settings.wasmUrl=X),basisTranscodedTextureFormat=preferredTranscodedFormat.filter(J=>K.includes(J))[0],basisTranscoderFormat=gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat),await getKTX()}const messageHandlers={init:async Z=>{const{jsUrl:X,wasmUrl:K,supportedTextures:J}=Z;await init(X,K,J)},load:async Z=>{var X;try{const K=await load(Z.url);return{type:"load",url:Z.url,success:!0,textureOptions:K,transferables:(X=K.resource)==null?void 0:X.map(J=>J.buffer)}}catch(K){throw K}}};self.onmessage=async Z=>{var X;const K=Z.data,J=await((X=messageHandlers[K.type])==null?void 0:X.call(messageHandlers,K));J&&self.postMessage(J,J.transferables)};const n$q=new Bounds,u$o=class{cull(Z,X,K=!0){this._cullRecursive(Z,X,K)}_cullRecursive(Z,X,K=!0){var J;if(Z.cullable&&Z.view){const Q=(J=Z.cullArea)!=null?J:getGlobalBounds(Z,K,n$q);Z.visible=!(Q.x>=X.x+X.width||Q.y>=X.y+X.height||Q.x+Q.width<=X.x||Q.y+Q.height<=X.y)}if(Z.cullableChildren)for(let Q=0;Q<Z.children.length;Q++)this._cullRecursive(Z.children[Q],X,K)}};let Culler=u$o;Culler.shared=new u$o;class CullerPlugin{static init(){this._renderRef=this.render.bind(this),this.render=()=>{Culler.shared.cull(this.stage,this.renderer.screen),this.renderer.render({container:this.stage})}}static destroy(){this.render=this._renderRef}}CullerPlugin.extension={priority:10,type:u$z.Application,name:"culler"};class s$s{constructor(){this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}init(X){this.removeTickerListener(),this.events=X,this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}get pauseUpdate(){return this._pauseUpdate}set pauseUpdate(X){this._pauseUpdate=X}addTickerListener(){this._tickerAdded||!this.domElement||(Ticker.system.add(this._tickerUpdate,this,UPDATE_PRIORITY.INTERACTION),this._tickerAdded=!0)}removeTickerListener(){this._tickerAdded&&(Ticker.system.remove(this._tickerUpdate,this),this._tickerAdded=!1)}pointerMoved(){this._didMove=!0}_update(){if(!this.domElement||this._pauseUpdate)return;if(this._didMove){this._didMove=!1;return}const X=this.events._rootPointerEvent;this.events.supportsTouchEvents&&X.pointerType==="touch"||globalThis.document.dispatchEvent(new PointerEvent("pointermove",{clientX:X.clientX,clientY:X.clientY}))}_tickerUpdate(X){this._deltaTime+=X.deltaTime,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this._update())}}const EventsTicker=new s$s;class FederatedMouseEvent extends FederatedEvent{constructor(){super(...arguments),this.client=new Point,this.movement=new Point,this.offset=new Point,this.global=new Point,this.screen=new Point}get clientX(){return this.client.x}get clientY(){return this.client.y}get x(){return this.clientX}get y(){return this.clientY}get movementX(){return this.movement.x}get movementY(){return this.movement.y}get offsetX(){return this.offset.x}get offsetY(){return this.offset.y}get globalX(){return this.global.x}get globalY(){return this.global.y}get screenX(){return this.screen.x}get screenY(){return this.screen.y}getLocalPosition(X,K,J){return X.worldTransform.applyInverse(J||this.global,K)}getModifierState(X){return"getModifierState"in this.nativeEvent&&this.nativeEvent.getModifierState(X)}initMouseEvent(X,K,J,Q,ee,te,re,ne,ie,se,oe,ae,le,ce,de){throw new Error("Method not implemented.")}}class FederatedPointerEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.width=0,this.height=0,this.isPrimary=!1}getCoalescedEvents(){return this.type==="pointermove"||this.type==="mousemove"||this.type==="touchmove"?[this]:[]}getPredictedEvents(){throw new Error("getPredictedEvents is not supported!")}}class FederatedWheelEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.DOM_DELTA_PIXEL=0,this.DOM_DELTA_LINE=1,this.DOM_DELTA_PAGE=2}}FederatedWheelEvent.DOM_DELTA_PIXEL=0,FederatedWheelEvent.DOM_DELTA_LINE=1,FederatedWheelEvent.DOM_DELTA_PAGE=2;const b$i=2048,F$2=new Point,g$l=new Point;class EventBoundary{constructor(X){this.dispatch=new eventemitter3,this.moveOnAll=!1,this.enableGlobalMoveEvents=!0,this.mappingState={trackingData:{}},this.eventPool=new Map,this._allInteractiveElements=[],this._hitElements=[],this._isPointerMoveEvent=!1,this.rootTarget=X,this.hitPruneFn=this.hitPruneFn.bind(this),this.hitTestFn=this.hitTestFn.bind(this),this.mapPointerDown=this.mapPointerDown.bind(this),this.mapPointerMove=this.mapPointerMove.bind(this),this.mapPointerOut=this.mapPointerOut.bind(this),this.mapPointerOver=this.mapPointerOver.bind(this),this.mapPointerUp=this.mapPointerUp.bind(this),this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this),this.mapWheel=this.mapWheel.bind(this),this.mappingTable={},this.addEventMapping("pointerdown",this.mapPointerDown),this.addEventMapping("pointermove",this.mapPointerMove),this.addEventMapping("pointerout",this.mapPointerOut),this.addEventMapping("pointerleave",this.mapPointerOut),this.addEventMapping("pointerover",this.mapPointerOver),this.addEventMapping("pointerup",this.mapPointerUp),this.addEventMapping("pointerupoutside",this.mapPointerUpOutside),this.addEventMapping("wheel",this.mapWheel)}addEventMapping(X,K){this.mappingTable[X]||(this.mappingTable[X]=[]),this.mappingTable[X].push({fn:K,priority:0}),this.mappingTable[X].sort((J,Q)=>J.priority-Q.priority)}dispatchEvent(X,K){X.propagationStopped=!1,X.propagationImmediatelyStopped=!1,this.propagate(X,K),this.dispatch.emit(K||X.type,X)}mapEvent(X){if(!this.rootTarget)return;const K=this.mappingTable[X.type];if(K)for(let J=0,Q=K.length;J<Q;J++)K[J].fn(X)}hitTest(X,K){EventsTicker.pauseUpdate=!0;const J=this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive",Q=this[J](this.rootTarget,this.rootTarget.eventMode,F$2.set(X,K),this.hitTestFn,this.hitPruneFn);return Q&&Q[0]}propagate(X,K){if(!X.target)return;const J=X.composedPath();X.eventPhase=X.CAPTURING_PHASE;for(let Q=0,ee=J.length-1;Q<ee;Q++)if(X.currentTarget=J[Q],this.notifyTarget(X,K),X.propagationStopped||X.propagationImmediatelyStopped)return;if(X.eventPhase=X.AT_TARGET,X.currentTarget=X.target,this.notifyTarget(X,K),!(X.propagationStopped||X.propagationImmediatelyStopped)){X.eventPhase=X.BUBBLING_PHASE;for(let Q=J.length-2;Q>=0;Q--)if(X.currentTarget=J[Q],this.notifyTarget(X,K),X.propagationStopped||X.propagationImmediatelyStopped)return}}all(X,K,J=this._allInteractiveElements){if(J.length===0)return;X.eventPhase=X.BUBBLING_PHASE;const Q=Array.isArray(K)?K:[K];for(let ee=J.length-1;ee>=0;ee--)Q.forEach(te=>{X.currentTarget=J[ee],this.notifyTarget(X,te)})}propagationPath(X){const K=[X];for(let J=0;J<b$i&&X!==this.rootTarget&&X.parent;J++){if(!X.parent)throw new Error("Cannot find propagation path to disconnected target");K.push(X.parent),X=X.parent}return K.reverse(),K}hitTestMoveRecursive(X,K,J,Q,ee,te=!1){let re=!1;if(this._interactivePrune(X))return null;if((X.eventMode==="dynamic"||K==="dynamic")&&(EventsTicker.pauseUpdate=!1),X.interactiveChildren&&X.children){const se=X.children;for(let oe=se.length-1;oe>=0;oe--){const ae=se[oe],le=this.hitTestMoveRecursive(ae,this._isInteractive(K)?K:ae.eventMode,J,Q,ee,te||ee(X,J));if(le){if(le.length>0&&!le[le.length-1].parent)continue;const ce=X.isInteractive();(le.length>0||ce)&&(ce&&this._allInteractiveElements.push(X),le.push(X)),this._hitElements.length===0&&(this._hitElements=le),re=!0}}}const ne=this._isInteractive(K),ie=X.isInteractive();return ie&&ie&&this._allInteractiveElements.push(X),te||this._hitElements.length>0?null:re?this._hitElements:ne&&!ee(X,J)&&Q(X,J)?ie?[X]:[]:null}hitTestRecursive(X,K,J,Q,ee){if(this._interactivePrune(X)||ee(X,J))return null;if((X.eventMode==="dynamic"||K==="dynamic")&&(EventsTicker.pauseUpdate=!1),X.interactiveChildren&&X.children){const ne=X.children,ie=J;for(let se=ne.length-1;se>=0;se--){const oe=ne[se],ae=this.hitTestRecursive(oe,this._isInteractive(K)?K:oe.eventMode,ie,Q,ee);if(ae){if(ae.length>0&&!ae[ae.length-1].parent)continue;const le=X.isInteractive();return(ae.length>0||le)&&ae.push(X),ae}}}const te=this._isInteractive(K),re=X.isInteractive();return te&&Q(X,J)?re?[X]:[]:null}_isInteractive(X){return X==="static"||X==="dynamic"}_interactivePrune(X){return!X||!X.visible||!X.renderable||X.eventMode==="none"||X.eventMode==="passive"&&!X.interactiveChildren}hitPruneFn(X,K){if(X.hitArea&&(X.worldTransform.applyInverse(K,g$l),!X.hitArea.contains(g$l.x,g$l.y)))return!0;if(X.effects&&X.effects.length)for(let J=0;J<X.effects.length;J++){const Q=X.effects[J];if(Q.containsPoint&&!Q.containsPoint(K,this.hitTestFn))return!0}return!1}hitTestFn(X,K){var J;return X.hitArea?!0:(J=X.view)!=null&&J.containsPoint?(X.worldTransform.applyInverse(K,g$l),X.view.containsPoint(g$l)):!1}notifyTarget(X,K){var J,Q;K=K!=null?K:X.type;const ee=`on${K}`;(Q=(J=X.currentTarget)[ee])==null||Q.call(J,X);const te=X.eventPhase===X.CAPTURING_PHASE||X.eventPhase===X.AT_TARGET?`${K}capture`:K;this._notifyListeners(X,te),X.eventPhase===X.AT_TARGET&&this._notifyListeners(X,K)}mapPointerDown(X){if(!(X instanceof FederatedPointerEvent))return;const K=this.createPointerEvent(X);if(this.dispatchEvent(K,"pointerdown"),K.pointerType==="touch")this.dispatchEvent(K,"touchstart");else if(K.pointerType==="mouse"||K.pointerType==="pen"){const Q=K.button===2;this.dispatchEvent(K,Q?"rightdown":"mousedown")}const J=this.trackingData(X.pointerId);J.pressTargetsByButton[X.button]=K.composedPath(),this.freeEvent(K)}mapPointerMove(X){var K,J,Q;if(!(X instanceof FederatedPointerEvent))return;this._allInteractiveElements.length=0,this._hitElements.length=0,this._isPointerMoveEvent=!0;const ee=this.createPointerEvent(X);this._isPointerMoveEvent=!1;const te=ee.pointerType==="mouse"||ee.pointerType==="pen",re=this.trackingData(X.pointerId),ne=this.findMountedTarget(re.overTargets);if(((K=re.overTargets)==null?void 0:K.length)>0&&ne!==ee.target){const oe=X.type==="mousemove"?"mouseout":"pointerout",ae=this.createPointerEvent(X,oe,ne);if(this.dispatchEvent(ae,"pointerout"),te&&this.dispatchEvent(ae,"mouseout"),!ee.composedPath().includes(ne)){const le=this.createPointerEvent(X,"pointerleave",ne);for(le.eventPhase=le.AT_TARGET;le.target&&!ee.composedPath().includes(le.target);)le.currentTarget=le.target,this.notifyTarget(le),te&&this.notifyTarget(le,"mouseleave"),le.target=le.target.parent;this.freeEvent(le)}this.freeEvent(ae)}if(ne!==ee.target){const oe=X.type==="mousemove"?"mouseover":"pointerover",ae=this.clonePointerEvent(ee,oe);this.dispatchEvent(ae,"pointerover"),te&&this.dispatchEvent(ae,"mouseover");let le=ne==null?void 0:ne.parent;for(;le&&le!==this.rootTarget.parent&&le!==ee.target;)le=le.parent;if(!le||le===this.rootTarget.parent){const ce=this.clonePointerEvent(ee,"pointerenter");for(ce.eventPhase=ce.AT_TARGET;ce.target&&ce.target!==ne&&ce.target!==this.rootTarget.parent;)ce.currentTarget=ce.target,this.notifyTarget(ce),te&&this.notifyTarget(ce,"mouseenter"),ce.target=ce.target.parent;this.freeEvent(ce)}this.freeEvent(ae)}const ie=[],se=(J=this.enableGlobalMoveEvents)!=null?J:!0;this.moveOnAll?ie.push("pointermove"):this.dispatchEvent(ee,"pointermove"),se&&ie.push("globalpointermove"),ee.pointerType==="touch"&&(this.moveOnAll?ie.splice(1,0,"touchmove"):this.dispatchEvent(ee,"touchmove"),se&&ie.push("globaltouchmove")),te&&(this.moveOnAll?ie.splice(1,0,"mousemove"):this.dispatchEvent(ee,"mousemove"),se&&ie.push("globalmousemove"),this.cursor=(Q=ee.target)==null?void 0:Q.cursor),ie.length>0&&this.all(ee,ie),this._allInteractiveElements.length=0,this._hitElements.length=0,re.overTargets=ee.composedPath(),this.freeEvent(ee)}mapPointerOver(X){var K;if(!(X instanceof FederatedPointerEvent))return;const J=this.trackingData(X.pointerId),Q=this.createPointerEvent(X),ee=Q.pointerType==="mouse"||Q.pointerType==="pen";this.dispatchEvent(Q,"pointerover"),ee&&this.dispatchEvent(Q,"mouseover"),Q.pointerType==="mouse"&&(this.cursor=(K=Q.target)==null?void 0:K.cursor);const te=this.clonePointerEvent(Q,"pointerenter");for(te.eventPhase=te.AT_TARGET;te.target&&te.target!==this.rootTarget.parent;)te.currentTarget=te.target,this.notifyTarget(te),ee&&this.notifyTarget(te,"mouseenter"),te.target=te.target.parent;J.overTargets=Q.composedPath(),this.freeEvent(Q),this.freeEvent(te)}mapPointerOut(X){if(!(X instanceof FederatedPointerEvent))return;const K=this.trackingData(X.pointerId);if(K.overTargets){const J=X.pointerType==="mouse"||X.pointerType==="pen",Q=this.findMountedTarget(K.overTargets),ee=this.createPointerEvent(X,"pointerout",Q);this.dispatchEvent(ee),J&&this.dispatchEvent(ee,"mouseout");const te=this.createPointerEvent(X,"pointerleave",Q);for(te.eventPhase=te.AT_TARGET;te.target&&te.target!==this.rootTarget.parent;)te.currentTarget=te.target,this.notifyTarget(te),J&&this.notifyTarget(te,"mouseleave"),te.target=te.target.parent;K.overTargets=null,this.freeEvent(ee),this.freeEvent(te)}this.cursor=null}mapPointerUp(X){if(!(X instanceof FederatedPointerEvent))return;const K=performance.now(),J=this.createPointerEvent(X);if(this.dispatchEvent(J,"pointerup"),J.pointerType==="touch")this.dispatchEvent(J,"touchend");else if(J.pointerType==="mouse"||J.pointerType==="pen"){const re=J.button===2;this.dispatchEvent(J,re?"rightup":"mouseup")}const Q=this.trackingData(X.pointerId),ee=this.findMountedTarget(Q.pressTargetsByButton[X.button]);let te=ee;if(ee&&!J.composedPath().includes(ee)){let re=ee;for(;re&&!J.composedPath().includes(re);){if(J.currentTarget=re,this.notifyTarget(J,"pointerupoutside"),J.pointerType==="touch")this.notifyTarget(J,"touchendoutside");else if(J.pointerType==="mouse"||J.pointerType==="pen"){const ne=J.button===2;this.notifyTarget(J,ne?"rightupoutside":"mouseupoutside")}re=re.parent}delete Q.pressTargetsByButton[X.button],te=re}if(te){const re=this.clonePointerEvent(J,"click");re.target=te,re.path=null,Q.clicksByButton[X.button]||(Q.clicksByButton[X.button]={clickCount:0,target:re.target,timeStamp:K});const ne=Q.clicksByButton[X.button];if(ne.target===re.target&&K-ne.timeStamp<200?++ne.clickCount:ne.clickCount=1,ne.target=re.target,ne.timeStamp=K,re.detail=ne.clickCount,re.pointerType==="mouse"){const ie=re.button===2;this.dispatchEvent(re,ie?"rightclick":"click")}else re.pointerType==="touch"&&this.dispatchEvent(re,"tap");this.dispatchEvent(re,"pointertap"),this.freeEvent(re)}this.freeEvent(J)}mapPointerUpOutside(X){if(!(X instanceof FederatedPointerEvent))return;const K=this.trackingData(X.pointerId),J=this.findMountedTarget(K.pressTargetsByButton[X.button]),Q=this.createPointerEvent(X);if(J){let ee=J;for(;ee;)Q.currentTarget=ee,this.notifyTarget(Q,"pointerupoutside"),Q.pointerType==="touch"?this.notifyTarget(Q,"touchendoutside"):(Q.pointerType==="mouse"||Q.pointerType==="pen")&&this.notifyTarget(Q,Q.button===2?"rightupoutside":"mouseupoutside"),ee=ee.parent;delete K.pressTargetsByButton[X.button]}this.freeEvent(Q)}mapWheel(X){if(!(X instanceof FederatedWheelEvent))return;const K=this.createWheelEvent(X);this.dispatchEvent(K),this.freeEvent(K)}findMountedTarget(X){if(!X)return null;let K=X[0];for(let J=1;J<X.length&&X[J].parent===K;J++)K=X[J];return K}createPointerEvent(X,K,J){var Q;const ee=this.allocateEvent(FederatedPointerEvent);return this.copyPointerData(X,ee),this.copyMouseData(X,ee),this.copyData(X,ee),ee.nativeEvent=X.nativeEvent,ee.originalEvent=X,ee.target=(Q=J!=null?J:this.hitTest(ee.global.x,ee.global.y))!=null?Q:this._hitElements[0],typeof K=="string"&&(ee.type=K),ee}createWheelEvent(X){const K=this.allocateEvent(FederatedWheelEvent);return this.copyWheelData(X,K),this.copyMouseData(X,K),this.copyData(X,K),K.nativeEvent=X.nativeEvent,K.originalEvent=X,K.target=this.hitTest(K.global.x,K.global.y),K}clonePointerEvent(X,K){const J=this.allocateEvent(FederatedPointerEvent);return J.nativeEvent=X.nativeEvent,J.originalEvent=X.originalEvent,this.copyPointerData(X,J),this.copyMouseData(X,J),this.copyData(X,J),J.target=X.target,J.path=X.composedPath().slice(),J.type=K!=null?K:J.type,J}copyWheelData(X,K){K.deltaMode=X.deltaMode,K.deltaX=X.deltaX,K.deltaY=X.deltaY,K.deltaZ=X.deltaZ}copyPointerData(X,K){X instanceof FederatedPointerEvent&&K instanceof FederatedPointerEvent&&(K.pointerId=X.pointerId,K.width=X.width,K.height=X.height,K.isPrimary=X.isPrimary,K.pointerType=X.pointerType,K.pressure=X.pressure,K.tangentialPressure=X.tangentialPressure,K.tiltX=X.tiltX,K.tiltY=X.tiltY,K.twist=X.twist)}copyMouseData(X,K){X instanceof FederatedMouseEvent&&K instanceof FederatedMouseEvent&&(K.altKey=X.altKey,K.button=X.button,K.buttons=X.buttons,K.client.copyFrom(X.client),K.ctrlKey=X.ctrlKey,K.metaKey=X.metaKey,K.movement.copyFrom(X.movement),K.screen.copyFrom(X.screen),K.shiftKey=X.shiftKey,K.global.copyFrom(X.global))}copyData(X,K){K.isTrusted=X.isTrusted,K.srcElement=X.srcElement,K.timeStamp=performance.now(),K.type=X.type,K.detail=X.detail,K.view=X.view,K.which=X.which,K.layer.copyFrom(X.layer),K.page.copyFrom(X.page)}trackingData(X){return this.mappingState.trackingData[X]||(this.mappingState.trackingData[X]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[X]}allocateEvent(X){this.eventPool.has(X)||this.eventPool.set(X,[]);const K=this.eventPool.get(X).pop()||new X(this);return K.eventPhase=K.NONE,K.currentTarget=null,K.path=null,K.target=null,K}freeEvent(X){if(X.manager!==this)throw new Error("It is illegal to free an event not managed by this EventBoundary!");const K=X.constructor;this.eventPool.has(K)||this.eventPool.set(K,[]),this.eventPool.get(K).push(X)}_notifyListeners(X,K){const J=X.currentTarget._events[K];if(J&&X.currentTarget.isInteractive())if("fn"in J)J.once&&X.currentTarget.removeListener(K,J.fn,void 0,!0),J.fn.call(J.context,X);else for(let Q=0,ee=J.length;Q<ee&&!X.propagationImmediatelyStopped;Q++)J[Q].once&&X.currentTarget.removeListener(K,J[Q].fn,void 0,!0),J[Q].fn.call(J[Q].context,X)}}var c$k=Object.defineProperty,h$m=Object.getOwnPropertySymbols,f$q=Object.prototype.hasOwnProperty,y$c=Object.prototype.propertyIsEnumerable,m$o=(Z,X,K)=>X in Z?c$k(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$w=(Z,X)=>{for(var K in X||(X={}))f$q.call(X,K)&&m$o(Z,K,X[K]);if(h$m)for(var K of h$m(X))y$c.call(X,K)&&m$o(Z,K,X[K]);return Z};const b$h=1,g$k={touchstart:"pointerdown",touchend:"pointerup",touchendoutside:"pointerupoutside",touchmove:"pointermove",touchcancel:"pointercancel"},u$n=class{constructor(Z){this.supportsTouchEvents="ontouchstart"in globalThis,this.supportsPointerEvents=!!globalThis.PointerEvent,this.domElement=null,this.resolution=1,this.renderer=Z,this.rootBoundary=new EventBoundary(null),EventsTicker.init(this),this.autoPreventDefault=!0,this._eventsAdded=!1,this._rootPointerEvent=new FederatedPointerEvent(null),this._rootWheelEvent=new FederatedWheelEvent(null),this.cursorStyles={default:"inherit",pointer:"pointer"},this.features=new Proxy(p$w({},u$n.defaultEventFeatures),{set:(X,K,J)=>(K==="globalMove"&&(this.rootBoundary.enableGlobalMoveEvents=J),X[K]=J,!0)}),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onPointerOverOut=this._onPointerOverOut.bind(this),this.onWheel=this.onWheel.bind(this)}static get defaultEventMode(){return this._defaultEventMode}init(Z){var X,K;const{canvas:J,resolution:Q}=this.renderer;this.setTargetElement(J),this.resolution=Q,u$n._defaultEventMode=(X=Z.eventMode)!=null?X:"passive",Object.assign(this.features,(K=Z.eventFeatures)!=null?K:{}),this.rootBoundary.enableGlobalMoveEvents=this.features.globalMove}resolutionChange(Z){this.resolution=Z}destroy(){this.setTargetElement(null),this.renderer=null,this._currentCursor=null}setCursor(Z){Z=Z||"default";let X=!0;if(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas&&(X=!1),this._currentCursor===Z)return;this._currentCursor=Z;const K=this.cursorStyles[Z];if(K)switch(typeof K){case"string":X&&(this.domElement.style.cursor=K);break;case"function":K(Z);break;case"object":X&&Object.assign(this.domElement.style,K);break}else X&&typeof Z=="string"&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,Z)&&(this.domElement.style.cursor=Z)}get pointer(){return this._rootPointerEvent}_onPointerDown(Z){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const X=this._normalizeToPointerData(Z);this.autoPreventDefault&&X[0].isNormalized&&(Z.cancelable||!("cancelable"in Z))&&Z.preventDefault();for(let K=0,J=X.length;K<J;K++){const Q=X[K],ee=this._bootstrapEvent(this._rootPointerEvent,Q);this.rootBoundary.mapEvent(ee)}this.setCursor(this.rootBoundary.cursor)}_onPointerMove(Z){if(!this.features.move)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,EventsTicker.pointerMoved();const X=this._normalizeToPointerData(Z);for(let K=0,J=X.length;K<J;K++){const Q=this._bootstrapEvent(this._rootPointerEvent,X[K]);this.rootBoundary.mapEvent(Q)}this.setCursor(this.rootBoundary.cursor)}_onPointerUp(Z){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;let X=Z.target;Z.composedPath&&Z.composedPath().length>0&&(X=Z.composedPath()[0]);const K=X!==this.domElement?"outside":"",J=this._normalizeToPointerData(Z);for(let Q=0,ee=J.length;Q<ee;Q++){const te=this._bootstrapEvent(this._rootPointerEvent,J[Q]);te.type+=K,this.rootBoundary.mapEvent(te)}this.setCursor(this.rootBoundary.cursor)}_onPointerOverOut(Z){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const X=this._normalizeToPointerData(Z);for(let K=0,J=X.length;K<J;K++){const Q=this._bootstrapEvent(this._rootPointerEvent,X[K]);this.rootBoundary.mapEvent(Q)}this.setCursor(this.rootBoundary.cursor)}onWheel(Z){if(!this.features.wheel)return;const X=this.normalizeWheelEvent(Z);this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,this.rootBoundary.mapEvent(X)}setTargetElement(Z){this._removeEvents(),this.domElement=Z,EventsTicker.domElement=Z,this._addEvents()}_addEvents(){if(this._eventsAdded||!this.domElement)return;EventsTicker.addTickerListener();const Z=this.domElement.style;Z&&(globalThis.navigator.msPointerEnabled?(Z.msContentZooming="none",Z.msTouchAction="none"):this.supportsPointerEvents&&(Z.touchAction="none")),this.supportsPointerEvents?(globalThis.document.addEventListener("pointermove",this._onPointerMove,!0),this.domElement.addEventListener("pointerdown",this._onPointerDown,!0),this.domElement.addEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.addEventListener("pointerover",this._onPointerOverOut,!0),globalThis.addEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.addEventListener("mousemove",this._onPointerMove,!0),this.domElement.addEventListener("mousedown",this._onPointerDown,!0),this.domElement.addEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.addEventListener("mouseover",this._onPointerOverOut,!0),globalThis.addEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.addEventListener("touchstart",this._onPointerDown,!0),this.domElement.addEventListener("touchend",this._onPointerUp,!0),this.domElement.addEventListener("touchmove",this._onPointerMove,!0))),this.domElement.addEventListener("wheel",this.onWheel,{passive:!0,capture:!0}),this._eventsAdded=!0}_removeEvents(){if(!this._eventsAdded||!this.domElement)return;EventsTicker.removeTickerListener();const Z=this.domElement.style;Z&&(globalThis.navigator.msPointerEnabled?(Z.msContentZooming="",Z.msTouchAction=""):this.supportsPointerEvents&&(Z.touchAction="")),this.supportsPointerEvents?(globalThis.document.removeEventListener("pointermove",this._onPointerMove,!0),this.domElement.removeEventListener("pointerdown",this._onPointerDown,!0),this.domElement.removeEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.removeEventListener("pointerover",this._onPointerOverOut,!0),globalThis.removeEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.removeEventListener("mousemove",this._onPointerMove,!0),this.domElement.removeEventListener("mousedown",this._onPointerDown,!0),this.domElement.removeEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.removeEventListener("mouseover",this._onPointerOverOut,!0),globalThis.removeEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.removeEventListener("touchstart",this._onPointerDown,!0),this.domElement.removeEventListener("touchend",this._onPointerUp,!0),this.domElement.removeEventListener("touchmove",this._onPointerMove,!0))),this.domElement.removeEventListener("wheel",this.onWheel,!0),this.domElement=null,this._eventsAdded=!1}mapPositionToPoint(Z,X,K){const J=this.domElement.isConnected?this.domElement.getBoundingClientRect():{x:0,y:0,width:this.domElement.width,height:this.domElement.height,left:0,top:0},Q=1/this.resolution;Z.x=(X-J.left)*(this.domElement.width/J.width)*Q,Z.y=(K-J.top)*(this.domElement.height/J.height)*Q}_normalizeToPointerData(Z){const X=[];if(this.supportsTouchEvents&&Z instanceof TouchEvent)for(let K=0,J=Z.changedTouches.length;K<J;K++){const Q=Z.changedTouches[K];typeof Q.button=="undefined"&&(Q.button=0),typeof Q.buttons=="undefined"&&(Q.buttons=1),typeof Q.isPrimary=="undefined"&&(Q.isPrimary=Z.touches.length===1&&Z.type==="touchstart"),typeof Q.width=="undefined"&&(Q.width=Q.radiusX||1),typeof Q.height=="undefined"&&(Q.height=Q.radiusY||1),typeof Q.tiltX=="undefined"&&(Q.tiltX=0),typeof Q.tiltY=="undefined"&&(Q.tiltY=0),typeof Q.pointerType=="undefined"&&(Q.pointerType="touch"),typeof Q.pointerId=="undefined"&&(Q.pointerId=Q.identifier||0),typeof Q.pressure=="undefined"&&(Q.pressure=Q.force||.5),typeof Q.twist=="undefined"&&(Q.twist=0),typeof Q.tangentialPressure=="undefined"&&(Q.tangentialPressure=0),typeof Q.layerX=="undefined"&&(Q.layerX=Q.offsetX=Q.clientX),typeof Q.layerY=="undefined"&&(Q.layerY=Q.offsetY=Q.clientY),Q.isNormalized=!0,Q.type=Z.type,X.push(Q)}else if(!globalThis.MouseEvent||Z instanceof MouseEvent&&(!this.supportsPointerEvents||!(Z instanceof globalThis.PointerEvent))){const K=Z;typeof K.isPrimary=="undefined"&&(K.isPrimary=!0),typeof K.width=="undefined"&&(K.width=1),typeof K.height=="undefined"&&(K.height=1),typeof K.tiltX=="undefined"&&(K.tiltX=0),typeof K.tiltY=="undefined"&&(K.tiltY=0),typeof K.pointerType=="undefined"&&(K.pointerType="mouse"),typeof K.pointerId=="undefined"&&(K.pointerId=b$h),typeof K.pressure=="undefined"&&(K.pressure=.5),typeof K.twist=="undefined"&&(K.twist=0),typeof K.tangentialPressure=="undefined"&&(K.tangentialPressure=0),K.isNormalized=!0,X.push(K)}else X.push(Z);return X}normalizeWheelEvent(Z){const X=this._rootWheelEvent;return this._transferMouseData(X,Z),X.deltaX=Z.deltaX,X.deltaY=Z.deltaY,X.deltaZ=Z.deltaZ,X.deltaMode=Z.deltaMode,this.mapPositionToPoint(X.screen,Z.clientX,Z.clientY),X.global.copyFrom(X.screen),X.offset.copyFrom(X.screen),X.nativeEvent=Z,X.type=Z.type,X}_bootstrapEvent(Z,X){return Z.originalEvent=null,Z.nativeEvent=X,Z.pointerId=X.pointerId,Z.width=X.width,Z.height=X.height,Z.isPrimary=X.isPrimary,Z.pointerType=X.pointerType,Z.pressure=X.pressure,Z.tangentialPressure=X.tangentialPressure,Z.tiltX=X.tiltX,Z.tiltY=X.tiltY,Z.twist=X.twist,this._transferMouseData(Z,X),this.mapPositionToPoint(Z.screen,X.clientX,X.clientY),Z.global.copyFrom(Z.screen),Z.offset.copyFrom(Z.screen),Z.isTrusted=X.isTrusted,Z.type==="pointerleave"&&(Z.type="pointerout"),Z.type.startsWith("mouse")&&(Z.type=Z.type.replace("mouse","pointer")),Z.type.startsWith("touch")&&(Z.type=g$k[Z.type]||Z.type),Z}_transferMouseData(Z,X){Z.isTrusted=X.isTrusted,Z.srcElement=X.srcElement,Z.timeStamp=performance.now(),Z.type=X.type,Z.altKey=X.altKey,Z.button=X.button,Z.buttons=X.buttons,Z.client.x=X.clientX,Z.client.y=X.clientY,Z.ctrlKey=X.ctrlKey,Z.metaKey=X.metaKey,Z.movement.x=X.movementX,Z.movement.y=X.movementY,Z.page.x=X.pageX,Z.page.y=X.pageY,Z.relatedTarget=null,Z.shiftKey=X.shiftKey}};let EventSystem=u$n;EventSystem.extension={name:"events",type:[u$z.WebGLSystem,u$z.CanvasSystem,u$z.WebGPUSystem],priority:-1},EventSystem.defaultEventFeatures={move:!0,globalMove:!0,click:!0,wheel:!0};const FederatedContainer={onclick:null,onmousedown:null,onmouseenter:null,onmouseleave:null,onmousemove:null,onglobalmousemove:null,onmouseout:null,onmouseover:null,onmouseup:null,onmouseupoutside:null,onpointercancel:null,onpointerdown:null,onpointerenter:null,onpointerleave:null,onpointermove:null,onglobalpointermove:null,onpointerout:null,onpointerover:null,onpointertap:null,onpointerup:null,onpointerupoutside:null,onrightclick:null,onrightdown:null,onrightup:null,onrightupoutside:null,ontap:null,ontouchcancel:null,ontouchend:null,ontouchendoutside:null,ontouchmove:null,onglobaltouchmove:null,ontouchstart:null,onwheel:null,get interactive(){return this.eventMode==="dynamic"||this.eventMode==="static"},set interactive(Z){this.eventMode=Z?"static":"passive"},_internalEventMode:void 0,get eventMode(){var Z;return(Z=this._internalEventMode)!=null?Z:EventSystem.defaultEventMode},set eventMode(Z){this._internalEventMode=Z},isInteractive(){return this.eventMode==="static"||this.eventMode==="dynamic"},interactiveChildren:!0,hitArea:null,addEventListener(Z,X,K){const J=typeof K=="boolean"&&K||typeof K=="object"&&K.capture,Q=typeof X=="function"?void 0:X;Z=J?`${Z}capture`:Z,X=typeof X=="function"?X:X.handleEvent,this.on(Z,X,Q)},removeEventListener(Z,X,K){const J=typeof K=="boolean"&&K||typeof K=="object"&&K.capture,Q=typeof X=="function"?void 0:X;Z=J?`${Z}capture`:Z,X=typeof X=="function"?X:X.handleEvent,this.off(Z,X,Q)},dispatchEvent(Z){if(!(Z instanceof FederatedEvent))throw new Error("Container cannot propagate events outside of the Federated Events API");return Z.defaultPrevented=!1,Z.path=null,Z.target=this,Z.manager.dispatchEvent(Z),!Z.defaultPrevented}};b$r.add(EventSystem),Container.mixin(FederatedContainer);const o$m=class{constructor(Z,X){this.linkedSheets=[],this._texture=Z instanceof Texture?Z:null,this.textureSource=Z.source,this.textures={},this.animations={},this.data=X;const K=parseFloat(X.meta.scale);K?(this.resolution=K,Z.source.resolution=this.resolution):this.resolution=Z.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(Z=>{this._callback=Z,this._batchIndex=0,this._frameKeys.length<=o$m.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(Z){let X=Z;const K=o$m.BATCH_SIZE;for(;X-Z<K&&X<this._frameKeys.length;){const J=this._frameKeys[X],Q=this._frames[J],ee=Q.frame;if(ee){let te=null,re=null;const ne=Q.trimmed!==!1&&Q.sourceSize?Q.sourceSize:Q.frame,ie=new Rectangle(0,0,Math.floor(ne.w)/this.resolution,Math.floor(ne.h)/this.resolution);Q.rotated?te=new Rectangle(Math.floor(ee.x)/this.resolution,Math.floor(ee.y)/this.resolution,Math.floor(ee.h)/this.resolution,Math.floor(ee.w)/this.resolution):te=new Rectangle(Math.floor(ee.x)/this.resolution,Math.floor(ee.y)/this.resolution,Math.floor(ee.w)/this.resolution,Math.floor(ee.h)/this.resolution),Q.trimmed!==!1&&Q.spriteSourceSize&&(re=new Rectangle(Math.floor(Q.spriteSourceSize.x)/this.resolution,Math.floor(Q.spriteSourceSize.y)/this.resolution,Math.floor(ee.w)/this.resolution,Math.floor(ee.h)/this.resolution)),this.textures[J]=new Texture({source:this.textureSource,frame:te,orig:ie,trim:re,rotate:Q.rotated?2:0,defaultAnchor:Q.anchor,defaultBorders:Q.borders,label:J.toString()})}X++}}_processAnimations(){const Z=this.data.animations||{};for(const X in Z){this.animations[X]=[];for(let K=0;K<Z[X].length;K++){const J=Z[X][K];this.animations[X].push(this.textures[J])}}}_parseComplete(){const Z=this._callback;this._callback=null,this._batchIndex=0,Z.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*o$m.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*o$m.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(Z=!1){var X;for(const K in this.textures)this.textures[K].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,Z&&((X=this._texture)==null||X.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};let Spritesheet=o$m;Spritesheet.BATCH_SIZE=1e3;const E$1=["jpg","png","jpeg","avif","webp"];function y$b(Z,X,K){const J={};if(Z.forEach(Q=>{J[Q]=X}),Object.keys(X.textures).forEach(Q=>{J[Q]=X.textures[Q]}),!K){const Q=path.dirname(Z[0]);X.linkedSheets.forEach((ee,te)=>{const re=y$b([`${Q}/${X.data.meta.related_multi_packs[te]}`],ee,!0);Object.assign(J,re)})}return J}const spritesheetAsset={extension:u$z.Asset,cache:{test:Z=>Z instanceof Spritesheet,getCacheableAssets:(Z,X)=>y$b(Z,X,!1)},resolver:{test:Z=>{const X=Z.split("?")[0].split("."),K=X.pop(),J=X.pop();return K==="json"&&E$1.includes(J)},parse:Z=>{var X,K;const J=Z.split(".");return{resolution:parseFloat((K=(X=Resolver.RETINA_PREFIX.exec(Z))==null?void 0:X[1])!=null?K:"1"),format:J[J.length-2],src:Z}}},loader:{name:"spritesheetLoader",extension:{type:u$z.LoadParser,priority:LoaderParserPriority.Normal},async testParse(Z,X){return path.extname(X.src).toLowerCase()===".json"&&!!Z.frames},async parse(Z,X,K){var J,Q,ee;const{texture:te,imageFilename:re}=(J=X==null?void 0:X.data)!=null?J:{};let ne=path.dirname(X.src);ne&&ne.lastIndexOf("/")!==ne.length-1&&(ne+="/");let ie;if(te instanceof Texture)ie=te;else{const ae=copySearchParams(ne+(re!=null?re:Z.meta.image),X.src);ie=(await K.load([ae]))[ae]}const se=new Spritesheet(ie.source,Z);await se.parse();const oe=(Q=Z==null?void 0:Z.meta)==null?void 0:Q.related_multi_packs;if(Array.isArray(oe)){const ae=[];for(const ce of oe){if(typeof ce!="string")continue;let de=ne+ce;(ee=X.data)!=null&&ee.ignoreMultiPack||(de=copySearchParams(de,X.src),ae.push(K.load({src:de,data:{ignoreMultiPack:!0}})))}const le=await Promise.all(ae);se.linkedSheets=le,le.forEach(ce=>{ce.linkedSheets=[se].concat(se.linkedSheets.filter(de=>de!==ce))})}return se},unload(Z){Z.destroy(!0)}}};b$r.add(spritesheetAsset);const emptyViewObserver={onViewUpdate:()=>{}};function updateQuadBounds(Z,X,K,J){const{width:Q,height:ee}=K.orig,te=K.trim;if(te){const re=te.width,ne=te.height;Z.left=te.x-X._x*Q-J,Z.right=Z.left+re,Z.top=te.y-X._y*ee-J,Z.bottom=Z.top+ne}else Z.left=-X._x*Q-J,Z.right=Z.left+Q,Z.top=-X._y*ee-J,Z.bottom=Z.top+ee}class SpriteView{constructor(X){this.renderPipeId="sprite",this.owner=emptyViewObserver,this.uid=uid("spriteView"),this.batched=!0,this._didUpdate=!1,this._bounds={left:0,right:1,top:0,bottom:0},this._sourceBounds={left:0,right:1,top:0,bottom:0},this._boundsDirty=!0,this._sourceBoundsDirty=!0,this.roundPixels=0;var K,J;this.anchor=new ObservablePoint(this,((K=X.defaultAnchor)==null?void 0:K.x)||0,((J=X.defaultAnchor)==null?void 0:J.y)||0),this.texture=X}set texture(X){X||(X=Texture.EMPTY),this._texture!==X&&(this._texture=X,this.onUpdate())}get texture(){return this._texture}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}get sourceBounds(){return this._sourceBoundsDirty&&(this._updateSourceBounds(),this._sourceBoundsDirty=!1),this._sourceBounds}containsPoint(X){const K=this.sourceBounds;return X.x>=K.right&&X.x<=K.left&&X.y>=K.bottom&&X.y<=K.top}addBounds(X){const K=this._texture.trim?this.sourceBounds:this.bounds;X.addFrame(K.left,K.top,K.right,K.bottom)}onUpdate(){this._didUpdate=!0,this._sourceBoundsDirty=this._boundsDirty=!0,this.owner.onViewUpdate()}_updateBounds(){updateQuadBounds(this._bounds,this.anchor,this._texture,0)}_updateSourceBounds(){const X=this.anchor,K=this._texture,J=this._sourceBounds,{width:Q,height:ee}=K.orig;J.right=-X._x*Q,J.left=J.right+Q,J.bottom=-X._y*ee,J.top=J.bottom+ee}destroy(X=!1){if(this.anchor=null,typeof X=="boolean"?X:X==null?void 0:X.texture){const K=typeof X=="boolean"?X:X==null?void 0:X.textureSource;this._texture.destroy(K)}this._texture=null,this._bounds=null,this._sourceBounds=null}}var m$n=Object.defineProperty,o$l=Object.getOwnPropertySymbols,p$v=Object.prototype.hasOwnProperty,u$m=Object.prototype.propertyIsEnumerable,s$r=(Z,X,K)=>X in Z?m$n(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,x$b=(Z,X)=>{for(var K in X||(X={}))p$v.call(X,K)&&s$r(Z,K,X[K]);if(o$l)for(var K of o$l(X))u$m.call(X,K)&&s$r(Z,K,X[K]);return Z},h$l=(Z,X)=>{var K={};for(var J in Z)p$v.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&o$l)for(var J of o$l(Z))X.indexOf(J)<0&&u$m.call(Z,J)&&(K[J]=Z[J]);return K};class Sprite extends Container{static from(X,K=!1){return X instanceof Texture?new Sprite(X):new Sprite(Texture.from(X,K))}constructor(X=Texture.EMPTY){X instanceof Texture&&(X={texture:X});const K=X,{texture:J}=K,Q=h$l(K,["texture"]);super(x$b({view:new SpriteView(J!=null?J:Texture.EMPTY),label:"Sprite"},Q)),this.allowChildren=!1}get anchor(){return this.view.anchor}set anchor(X){this.view.anchor.x=X.x,this.view.anchor.y=X.y}get texture(){return this.view.texture}set texture(X){this.view.texture=X}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}const s$q=new Bounds;function addMaskBounds(Z,X,K){const J=s$q;Z.measurable=!0,getGlobalBounds(Z,K,J),X.addBoundsMask(J),Z.measurable=!1}function addMaskLocalBounds(Z,X,K){const J=new Bounds;Z.measurable=!0;const Q=getMatrixRelativeToParent(Z,K,new Matrix);getLocalBounds(Z,J,Q),Z.measurable=!1,X.addBoundsMask(J)}function getMatrixRelativeToParent(Z,X,K){return Z&&Z!==X&&(getMatrixRelativeToParent(Z.parent,X,K),Z.didChange&&updateLocalTransform(Z.localTransform,Z),K.append(Z.localTransform)),K}class AlphaMask{constructor(X){this.priority=0,this.pipe="alphaMask",X!=null&&X.mask&&this.init(X.mask)}init(X){this.mask=X,this.renderMaskToTexture=!(X instanceof Sprite),this.mask.renderable=this.renderMaskToTexture,this.mask.includeInBuild=!this.renderMaskToTexture,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask=null}addBounds(X,K){addMaskBounds(this.mask,X,K)}addLocalBounds(X,K){addMaskLocalBounds(this.mask,X,K)}containsPoint(X,K){const J=this.mask;return K(J,X)}destroy(){this.reset()}static test(X){return X instanceof Sprite}}AlphaMask.extension=u$z.MaskEffect;class ColorMask{constructor(X){this.priority=0,this.pipe="colorMask",X!=null&&X.mask&&this.init(X.mask)}init(X){this.mask=X}destroy(){}static test(X){return typeof X=="number"}}ColorMask.extension=u$z.MaskEffect;class StencilMask{constructor(X){this.priority=0,this.pipe="stencilMask",X!=null&&X.mask&&this.init(X.mask)}init(X){this.mask=X,this.mask.includeInBuild=!1,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask.includeInBuild=!0,this.mask=null}addBounds(X,K){addMaskBounds(this.mask,X,K)}addLocalBounds(X,K){addMaskLocalBounds(this.mask,X,K)}containsPoint(X,K){const J=this.mask;return K(J,X)}destroy(){this.reset()}static test(X){return X instanceof Container}}StencilMask.extension=u$z.MaskEffect;var u$l=Object.defineProperty,y$a=Object.defineProperties,c$j=Object.getOwnPropertyDescriptors,i$i=Object.getOwnPropertySymbols,A$4=Object.prototype.hasOwnProperty,p$u=Object.prototype.propertyIsEnumerable,f$p=(Z,X,K)=>X in Z?u$l(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$k=(Z,X)=>{for(var K in X||(X={}))A$4.call(X,K)&&f$p(Z,K,X[K]);if(i$i)for(var K of i$i(X))p$u.call(X,K)&&f$p(Z,K,X[K]);return Z},s$p=(Z,X)=>y$a(Z,c$j(X));class BufferImageSource extends TextureSource{constructor(X){const K=X.resource||new Float32Array(X.width*X.height*4);let J=X.format;J||(K instanceof Float32Array?J="rgba32float":K instanceof Int32Array||K instanceof Uint32Array?J="rgba32uint":K instanceof Int16Array||K instanceof Uint16Array?J="rgba16uint":(K instanceof Int8Array,J="bgra8unorm")),super(s$p(o$k({},X),{resource:K,format:J})),this.uploadMethodId="buffer"}static test(X){return X instanceof Int8Array||X instanceof Uint8Array||X instanceof Uint8ClampedArray||X instanceof Int16Array||X instanceof Uint16Array||X instanceof Int32Array||X instanceof Uint32Array||X instanceof Float32Array}}BufferImageSource.extension=u$z.TextureSource;class CanvasSource extends TextureSource{constructor(X){X.resource||(X.resource=DOMAdapter.get().createCanvas()),X.width||(X.width=X.resource.width,X.autoDensity||(X.width/=X.resolution)),X.height||(X.height=X.resource.height,X.autoDensity||(X.height/=X.resolution)),super(X),this.uploadMethodId="image",this.autoDensity=X.autoDensity;const K=X.resource;(this.pixelWidth!==K.width||this.pixelWidth!==K.height)&&this.resizeCanvas()}resizeCanvas(){this.autoDensity&&(this.resource.style.width=`${this.width}px`,this.resource.style.height=`${this.height}px`),this.resource.width=this.pixelWidth,this.resource.height=this.pixelHeight}resize(X=this.width,K=this.height,J=this._resolution){super.resize(X,K,J),this.resizeCanvas()}static test(X){return globalThis.HTMLCanvasElement&&X instanceof HTMLCanvasElement||globalThis.OffscreenCanvas&&X instanceof OffscreenCanvas}}CanvasSource.extension=u$z.TextureSource,b$r.add(AlphaMask,ColorMask,StencilMask,VideoSource,ImageSource,CanvasSource,BufferImageSource);const i$h={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},e$3=0,s$o=1,n$p=2,o$j=3,a$s=4,d$k=5;class State{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<e$3)}set blend(X){!!(this.data&1<<e$3)!==X&&(this.data^=1<<e$3)}get offsets(){return!!(this.data&1<<s$o)}set offsets(X){!!(this.data&1<<s$o)!==X&&(this.data^=1<<s$o)}set cullMode(X){if(X==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=X==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<n$p)}set culling(X){!!(this.data&1<<n$p)!==X&&(this.data^=1<<n$p)}get depthTest(){return!!(this.data&1<<o$j)}set depthTest(X){!!(this.data&1<<o$j)!==X&&(this.data^=1<<o$j)}get depthMask(){return!!(this.data&1<<d$k)}set depthMask(X){!!(this.data&1<<d$k)!==X&&(this.data^=1<<d$k)}get clockwiseFrontFace(){return!!(this.data&1<<a$s)}set clockwiseFrontFace(X){!!(this.data&1<<a$s)!==X&&(this.data^=1<<a$s)}get blendMode(){return this._blendMode}set blendMode(X){this.blend=X!=="none",this._blendMode=X,this._blendModeId=i$h[X]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(X){this.offsets=!!X,this._polygonOffset=X}static for2d(){const X=new State;return X.depthTest=!1,X.blend=!0,X}}function colorToUniform(Z,X,K,J){K[J++]=(Z>>16&255)/255,K[J++]=(Z>>8&255)/255,K[J++]=(Z&255)/255,K[J++]=X}function color32BitToUniform(Z,X,K){X[K++]=(Z&255)/255,X[K++]=(Z>>8&255)/255,X[K++]=(Z>>16&255)/255,X[K++]=(Z>>24&255)/255}class GraphicsPipe{constructor(X,K){this.state=State.for2d(),this._renderableBatchesHash=Object.create(null),this.renderer=X,this._adaptor=K,this._adaptor.init()}validateRenderable(X){const K=X.view.context,J=!!this._renderableBatchesHash[X.uid],Q=this.renderer.graphicsContext.updateGpuContext(K);return!!(Q.isBatchable||J!==Q.isBatchable)}addRenderable(X,K){const J=this.renderer.graphicsContext.updateGpuContext(X.view.context);X.view._didUpdate&&(X.view._didUpdate=!1,this._rebuild(X)),J.isBatchable?this._addToBatcher(X,K):(this.renderer.renderPipes.batch.break(K),K.add({renderPipeId:"graphics",renderable:X}))}updateRenderable(X){const K=this._renderableBatchesHash[X.uid];if(K)for(let J=0;J<K.length;J++){const Q=K[J];Q.batcher.updateElement(Q)}}destroyRenderable(X){this._removeBatchForRenderable(X.uid)}execute({renderable:X}){if(!X.isRenderable)return;const K=this.renderer,J=X.view.context;if(!K.graphicsContext.getGpuContext(J).batches.length)return;const Q=J.customShader||this._adaptor.shader;this.state.blendMode=X.rgBlendMode;const ee=Q.resources.localUniforms.uniforms;ee.uTransformMatrix=X.rgTransform,ee.uRound=K._roundPixels|X.view.roundPixels,color32BitToUniform(X.rgColorAlpha,ee.uColor,0),this._adaptor.execute(this,X)}_rebuild(X){const K=!!this._renderableBatchesHash[X.uid],J=this.renderer.graphicsContext.updateGpuContext(X.view.context);K&&this._removeBatchForRenderable(X.uid),J.isBatchable&&this._initBatchesForRenderable(X),X.view.batched=J.isBatchable}_addToBatcher(X,K){const J=this.renderer.renderPipes.batch,Q=this._getBatchesForRenderable(X);for(let ee=0;ee<Q.length;ee++){const te=Q[ee];J.addToBatch(te,K)}}_getBatchesForRenderable(X){return this._renderableBatchesHash[X.uid]||this._initBatchesForRenderable(X)}_initBatchesForRenderable(X){const K=X.view.context,J=this.renderer.graphicsContext.getGpuContext(K),Q=this.renderer._roundPixels|X.view.roundPixels,ee=J.batches.map(te=>{const re=BigPool.get(BatchableGraphics);return te.copyTo(re),re.renderable=X,re.roundPixels=Q,re});return this._renderableBatchesHash[X.uid]=ee,X.on("destroyed",()=>{this.destroyRenderable(X)}),ee}_removeBatchForRenderable(X){this._renderableBatchesHash[X].forEach(K=>{BigPool.return(K)}),this._renderableBatchesHash[X]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const X in this._renderableBatchesHash)this._removeBatchForRenderable(X);this._renderableBatchesHash=null}}GraphicsPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"graphics"},b$r.add(GraphicsPipe),b$r.add(GraphicsContextSystem);function defaultUniformValue(Z,X){switch(Z){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*X);case"vec3<f32>":return new Float32Array(3*X);case"vec4<f32>":return new Float32Array(4*X);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}var l$k=Object.defineProperty,f$o=Object.getOwnPropertySymbols,m$m=Object.prototype.hasOwnProperty,b$g=Object.prototype.propertyIsEnumerable,p$t=(Z,X,K)=>X in Z?l$k(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$n=(Z,X)=>{for(var K in X||(X={}))m$m.call(X,K)&&p$t(Z,K,X[K]);if(f$o)for(var K of f$o(X))b$g.call(X,K)&&p$t(Z,K,X[K]);return Z};const a$r=class{constructor(Z,X){this._touched=0,this.uid=uid("uniform"),this._resourceType="uniformGroup",this._resourceId=this.uid,this.isUniformGroup=!0,this._dirtyId=0;var K,J;X=s$n(s$n({},a$r.defaultOptions),X),this.uniformStructures=Z;const Q={};for(const ee in Z){const te=Z[ee];te.name=ee,te.size=(K=te.size)!=null?K:1,(J=te.value)!=null||(te.value=defaultUniformValue(te.type,te.size)),Q[ee]=te.value}this.uniforms=Q,this._dirtyId=1,this.ubo=X.ubo,this.isStatic=X.isStatic,this._signature=Object.keys(Q).map(ee=>`${ee}-${Z[ee].type}`).join("-")}update(){this._dirtyId++}};let UniformGroup=a$r;UniformGroup.defaultOptions={ubo:!1,isStatic:!1};class BatchableMesh{constructor(){this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.rgBlendMode}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null}packIndex(X,K,J){const Q=this.renderable.view.geometry.indices;for(let ee=0;ee<Q.length;ee++)X[K++]=Q[ee]+J}packAttributes(X,K,J,Q){const ee=this.renderable,te=this.renderable.view.geometry,re=ee.rgTransform,ne=Q<<16|this.roundPixels&65535,ie=re.a,se=re.b,oe=re.c,ae=re.d,le=re.tx,ce=re.ty,de=te.positions,he=te.uvs,pe=ee.rgColorAlpha;for(let fe=0;fe<de.length;fe+=2){const ge=de[fe],me=de[fe+1];X[J]=ie*ge+oe*me+le,X[J+1]=se*ge+ae*me+ce,X[J+2]=he[fe],X[J+3]=he[fe+1],K[J+4]=pe,K[J+5]=ne,J+=6}}get vertexSize(){return this.renderable.view.geometry.positions.length/2}get indexSize(){return this.renderable.view.geometry.indices.length}}class MeshPipe{constructor(X,K){this.localUniforms=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup({0:this.localUniforms}),this._renderableHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this.renderer=X,this._adaptor=K,this._adaptor.init()}validateRenderable(X){const K=this._getRenderableData(X),J=K.batched,Q=X.view.batched;if(K.batched=Q,J!==Q)return!0;if(Q){const ee=X.view._geometry;if(ee.indices.length!==K.indexSize||ee.positions.length!==K.vertexSize)return K.indexSize=ee.indices.length,K.vertexSize=ee.positions.length,!0;const te=this._getBatchableMesh(X),re=X.view.texture;if(te.texture._source!==re._source&&te.texture._source!==re._source)return te.batcher.checkAndUpdateTexture(te,re)}return!1}addRenderable(X,K){const J=this.renderer.renderPipes.batch,{batched:Q}=this._getRenderableData(X);if(Q){const ee=this._getBatchableMesh(X);ee.texture=X.view._texture,J.addToBatch(ee)}else J.break(K),K.add({renderPipeId:"mesh",renderable:X})}updateRenderable(X){if(X.view.batched){const K=this._gpuBatchableMeshHash[X.uid];K.texture=X.view._texture,K.batcher.updateElement(K)}}destroyRenderable(X){this._renderableHash[X.uid]=null;const K=this._gpuBatchableMeshHash[X.uid];BigPool.return(K),this._gpuBatchableMeshHash[X.uid]=null}execute({renderable:X}){if(!X.isRenderable)return;const K=X.view;K.state.blendMode=X.rgBlendMode;const J=this.localUniforms;J.uniforms.uTransformMatrix=X.rgTransform,J.uniforms.uRound=this.renderer._roundPixels|X.view.roundPixels,J.update(),color32BitToUniform(X.rgColorAlpha,J.uniforms.uColor,0),this._adaptor.execute(this,X)}_getRenderableData(X){return this._renderableHash[X.uid]||this._initRenderableData(X)}_initRenderableData(X){const K=X.view;return this._renderableHash[X.uid]={batched:K.batched,indexSize:K._geometry.indices.length,vertexSize:K._geometry.positions.length},X.on("destroyed",()=>{this.destroyRenderable(X)}),this._renderableHash[X.uid]}_getBatchableMesh(X){return this._gpuBatchableMeshHash[X.uid]||this._initBatchableMesh(X)}_initBatchableMesh(X){const K=BigPool.get(BatchableMesh);return K.renderable=X,K.texture=X.view._texture,K.roundPixels=this.renderer._roundPixels|X.view.roundPixels,this._gpuBatchableMeshHash[X.uid]=K,K.renderable=X,K}destroy(){for(const X in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[X]&&BigPool.return(this._gpuBatchableMeshHash[X]);this._gpuBatchableMeshHash=null,this._renderableHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"mesh"},b$r.add(MeshPipe);class BatchableSprite{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.rgBlendMode}packAttributes(X,K,J,Q){const ee=this.renderable,te=this.texture,re=ee.rgTransform,ne=re.a,ie=re.b,se=re.c,oe=re.d,ae=re.tx,le=re.ty,ce=this.bounds,de=ce.right,he=ce.left,pe=ce.bottom,fe=ce.top,ge=te.uvs,me=ee.rgColorAlpha,ye=Q<<16|this.roundPixels&65535;X[J+0]=ne*he+se*fe+ae,X[J+1]=oe*fe+ie*he+le,X[J+2]=ge.x0,X[J+3]=ge.y0,K[J+4]=me,K[J+5]=ye,X[J+6]=ne*de+se*fe+ae,X[J+7]=oe*fe+ie*de+le,X[J+8]=ge.x1,X[J+9]=ge.y1,K[J+10]=me,K[J+11]=ye,X[J+12]=ne*de+se*pe+ae,X[J+13]=oe*pe+ie*de+le,X[J+14]=ge.x2,X[J+15]=ge.y2,K[J+16]=me,K[J+17]=ye,X[J+18]=ne*he+se*pe+ae,X[J+19]=oe*pe+ie*he+le,X[J+20]=ge.x3,X[J+21]=ge.y3,K[J+22]=me,K[J+23]=ye}packIndex(X,K,J){X[K]=J+0,X[K+1]=J+1,X[K+2]=J+2,X[K+3]=J+0,X[K+4]=J+2,X[K+5]=J+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}class CanvasTextPipe{constructor(X){this._gpuText=Object.create(null),this._renderer=X}validateRenderable(X){var K;const J=this._getGpuText(X),Q=X.view._getKey();if(J.currentKey!==Q){const ee=X.view,te=(K=ee.resolution)!=null?K:this._renderer.resolution,{width:re,height:ne}=this._renderer.canvasText.getTextureSize(ee.text,te,ee._style);return!(this._renderer.canvasText.getReferenceCount(J.currentKey)===1&&re===J.texture._source.width&&ne===J.texture._source.height)}return!1}addRenderable(X,K){const J=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),this._renderer.renderPipes.batch.addToBatch(J)}updateRenderable(X){const K=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),K.batcher.updateElement(K)}destroyRenderable(X){this._destroyRenderableById(X.uid)}_destroyRenderableById(X){const K=this._gpuText[X];this._renderer.canvasText.decreaseReferenceCount(K.currentKey),BigPool.return(K.batchableSprite),this._gpuText[X]=null}_updateText(X){const K=X.view._getKey(),J=this._getGpuText(X),Q=J.batchableSprite;J.currentKey!==K&&this._updateGpuText(X),X.view._didUpdate=!1;const ee=X.view._style.padding;updateQuadBounds(Q.bounds,X.view.anchor,Q.texture,ee)}_updateGpuText(X){var K;const J=this._getGpuText(X),Q=J.batchableSprite,ee=X.view;J.texture&&this._renderer.canvasText.decreaseReferenceCount(J.currentKey);const te=(K=ee.resolution)!=null?K:this._renderer.resolution;J.texture=Q.texture=this._renderer.canvasText.getTexture(ee.text,te,ee._style,ee._getKey()),J.currentKey=ee._getKey(),Q.texture=J.texture}_getGpuText(X){return this._gpuText[X.uid]||this.initGpuText(X)}initGpuText(X){const K={texture:null,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite)};return K.batchableSprite.renderable=X,K.batchableSprite.bounds={left:0,right:1,top:0,bottom:0},K.batchableSprite.roundPixels=this._renderer._roundPixels|X.view.roundPixels,this._gpuText[X.uid]=K,this._updateText(X),X.on("destroyed",()=>{this.destroyRenderable(X)}),K}destroy(){for(const X in this._gpuText)this._destroyRenderableById(X);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"text"};function nextPow2(Z){return Z+=Z===0?1:0,--Z,Z|=Z>>>1,Z|=Z>>>2,Z|=Z>>>4,Z|=Z>>>8,Z|=Z>>>16,Z+1}function isPow2(Z){return!(Z&Z-1)&&!!Z}function log2(Z){let X=(Z>65535?1:0)<<4;Z>>>=X;let K=(Z>255?1:0)<<3;return Z>>>=K,X|=K,K=(Z>15?1:0)<<2,Z>>>=K,X|=K,K=(Z>3?1:0)<<1,Z>>>=K,X|=K,X|Z>>1}class CanvasPoolClass{constructor(X){this._canvasPool=Object.create(null),this.canvasOptions=X||{},this.enableFullScreen=!1}_createCanvasAndContext(X,K){const J=DOMAdapter.get().createCanvas();J.width=X,J.height=K;const Q=J.getContext("2d");return{canvas:J,context:Q}}getOptimalCanvasAndContext(X,K,J=1){X=Math.ceil(X*J-1e-6),K=Math.ceil(K*J-1e-6),X=nextPow2(X),K=nextPow2(K);const Q=(X<<17)+(K<<1);this._canvasPool[Q]||(this._canvasPool[Q]=[]);let ee=this._canvasPool[Q].pop();return ee||(ee=this._createCanvasAndContext(X,K)),ee}returnCanvasAndContext(X){const{width:K,height:J}=X.canvas,Q=(K<<17)+(J<<1);this._canvasPool[Q].push(X)}clear(){this._canvasPool={}}}const CanvasPool=new CanvasPoolClass;var b$f=Object.defineProperty,m$l=Object.defineProperties,f$n=Object.getOwnPropertyDescriptors,n$o=Object.getOwnPropertySymbols,T$7=Object.prototype.hasOwnProperty,_$4=Object.prototype.propertyIsEnumerable,p$s=(Z,X,K)=>X in Z?b$f(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,x$a=(Z,X)=>{for(var K in X||(X={}))T$7.call(X,K)&&p$s(Z,K,X[K]);if(n$o)for(var K of n$o(X))_$4.call(X,K)&&p$s(Z,K,X[K]);return Z},h$k=(Z,X)=>m$l(Z,f$n(X));let g$j=0;class TexturePoolClass{constructor(X){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=X||{},this.enableFullScreen=!1}createTexture(X,K,J){const Q=new TextureSource(h$k(x$a({},this.textureOptions),{width:X,height:K,resolution:1,antialias:J}));return new Texture({source:Q,label:`texturePool_${g$j++}`})}getOptimalTexture(X,K,J=1,Q){let ee=Math.ceil(X*J-1e-6),te=Math.ceil(K*J-1e-6);ee=nextPow2(ee),te=nextPow2(te);const re=(ee<<17)+(te<<1)+(Q?1:0);this._texturePool[re]||(this._texturePool[re]=[]);let ne=this._texturePool[re].pop();return ne||(ne=this.createTexture(ee,te,Q)),ne.source._resolution=J,ne.source.width=ee/J,ne.source.height=te/J,ne.source.pixelWidth=ee,ne.source.pixelHeight=te,ne.frame.x=0,ne.frame.y=0,ne.frame.width=X,ne.frame.height=K,ne.updateUvs(),this._poolKeyHash[ne.uid]=re,ne}getSameSizeTexture(X,K=!1){const J=X.source;return this.getOptimalTexture(X.width,X.height,J._resolution,K)}returnTexture(X){const K=this._poolKeyHash[X.uid];this._texturePool[K].push(X)}clear(X){if(X=X!==!1,X)for(const K in this._texturePool){const J=this._texturePool[K];if(J)for(let Q=0;Q<J.length;Q++)J[Q].destroy(!0)}this._texturePool={}}}const TexturePool=new TexturePoolClass;function g$i(Z,X,K){for(let J=0,Q=4*K*X;J<X;++J,Q+=4)if(Z[Q+3]!==0)return!1;return!0}function d$j(Z,X,K,J,Q){const ee=4*X;for(let te=J,re=J*ee+4*K;te<=Q;++te,re+=ee)if(Z[re+3]!==0)return!1;return!0}function getCanvasBoundingBox(Z,X=1){const{width:K,height:J}=Z,Q=Z.getContext("2d",{willReadFrequently:!0});if(Q===null)throw new TypeError("Failed to get canvas 2D context");const ee=Q.getImageData(0,0,K,J).data;let te=0,re=0,ne=K-1,ie=J-1;for(;re<J&&g$i(ee,K,re);)++re;if(re===J)return Rectangle.EMPTY;for(;g$i(ee,K,ie);)--ie;for(;d$j(ee,K,te,re,ie);)++te;for(;d$j(ee,K,ne,re,ie);)--ne;return++ne,++ie,new Rectangle(te/X,re/X,(ne-te)/X,(ie-re)/X)}const p$r=new Bounds;function getPo2TextureFromSource(Z,X,K,J){const Q=p$r;Q.minX=0,Q.minY=0,Q.maxX=Z.width/J|0,Q.maxY=Z.height/J|0;const ee=TexturePool.getOptimalTexture(Q.width,Q.height,J,!1);return ee.source.uploadMethodId="image",ee.source.resource=Z,ee.source.alphaMode="premultiply-alpha-on-upload",ee.frame.width=X/J,ee.frame.height=K/J,ee.source.update(),ee.updateUvs(),ee}const r$5=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function fontStringFromTextStyle(Z){const X=typeof Z.fontSize=="number"?`${Z.fontSize}px`:Z.fontSize;let K=Z.fontFamily;Array.isArray(Z.fontFamily)||(K=Z.fontFamily.split(","));for(let J=K.length-1;J>=0;J--){let Q=K[J].trim();!/([\"\'])[^\'\"]+\1/.test(Q)&&!r$5.includes(Q)&&(Q=`"${Q}"`),K[J]=Q}return`${Z.fontStyle} ${Z.fontVariant} ${Z.fontWeight} ${X} ${K.join(",")}`}const k={willReadFrequently:!0},n$n=class{static get experimentalLetterSpacingSupported(){let Z=n$n._experimentalLetterSpacingSupported;if(Z!==void 0){const X=DOMAdapter.get().getCanvasRenderingContext2D().prototype;Z=n$n._experimentalLetterSpacingSupported="letterSpacing"in X||"textLetterSpacing"in X}return Z}constructor(Z,X,K,J,Q,ee,te,re,ne){this.text=Z,this.style=X,this.width=K,this.height=J,this.lines=Q,this.lineWidths=ee,this.lineHeight=te,this.maxLineWidth=re,this.fontProperties=ne}static measureText(Z=" ",X,K=n$n._canvas,J=X.wordWrap){var Q;const ee=`${Z}:${X.styleKey}`;if(n$n._measurementCache[ee])return n$n._measurementCache[ee];const te=fontStringFromTextStyle(X),re=n$n.measureFont(te);re.fontSize===0&&(re.fontSize=X.fontSize,re.ascent=X.fontSize);const ne=n$n.__context;ne.font=te;const ie=(J?n$n._wordWrap(Z,X,K):Z).split(/(?:\r\n|\r|\n)/),se=new Array(ie.length);let oe=0;for(let he=0;he<ie.length;he++){const pe=n$n._measureText(ie[he],X.letterSpacing,ne);se[he]=pe,oe=Math.max(oe,pe)}const ae=((Q=X._stroke)==null?void 0:Q.width)||0;let le=oe+ae;X.dropShadow&&(le+=X.dropShadow.distance);const ce=X.lineHeight||re.fontSize+ae;let de=Math.max(ce,re.fontSize+ae*2)+(ie.length-1)*(ce+X.leading);return X.dropShadow&&(de+=X.dropShadow.distance),new n$n(Z,X,le,de,ie,se,ce+X.leading,oe,re)}static _measureText(Z,X,K){let J=!1;n$n.experimentalLetterSpacingSupported&&(n$n.experimentalLetterSpacing?(K.letterSpacing=`${X}px`,K.textLetterSpacing=`${X}px`,J=!0):(K.letterSpacing="0px",K.textLetterSpacing="0px"));let Q=K.measureText(Z).width;return Q>0&&(J?Q-=X:Q+=(n$n.graphemeSegmenter(Z).length-1)*X),Q}static _wordWrap(Z,X,K=n$n._canvas){const J=K.getContext("2d",k);let Q=0,ee="",te="";const re=Object.create(null),{letterSpacing:ne,whiteSpace:ie}=X,se=n$n._collapseSpaces(ie),oe=n$n._collapseNewlines(ie);let ae=!se;const le=X.wordWrapWidth+ne,ce=n$n._tokenize(Z);for(let de=0;de<ce.length;de++){let he=ce[de];if(n$n._isNewline(he)){if(!oe){te+=n$n._addLine(ee),ae=!se,ee="",Q=0;continue}he=" "}if(se){const fe=n$n.isBreakingSpace(he),ge=n$n.isBreakingSpace(ee[ee.length-1]);if(fe&&ge)continue}const pe=n$n._getFromCache(he,ne,re,J);if(pe>le)if(ee!==""&&(te+=n$n._addLine(ee),ee="",Q=0),n$n.canBreakWords(he,X.breakWords)){const fe=n$n.wordWrapSplit(he);for(let ge=0;ge<fe.length;ge++){let me=fe[ge],ye=me,_e=1;for(;fe[ge+_e];){const ve=fe[ge+_e];if(!n$n.canBreakChars(ye,ve,he,ge,X.breakWords))me+=ve;else break;ye=ve,_e++}ge+=_e-1;const Ae=n$n._getFromCache(me,ne,re,J);Ae+Q>le&&(te+=n$n._addLine(ee),ae=!1,ee="",Q=0),ee+=me,Q+=Ae}}else{ee.length>0&&(te+=n$n._addLine(ee),ee="",Q=0);const fe=de===ce.length-1;te+=n$n._addLine(he,!fe),ae=!1,ee="",Q=0}else pe+Q>le&&(ae=!1,te+=n$n._addLine(ee),ee="",Q=0),(ee.length>0||!n$n.isBreakingSpace(he)||ae)&&(ee+=he,Q+=pe)}return te+=n$n._addLine(ee,!1),te}static _addLine(Z,X=!0){return Z=n$n._trimRight(Z),Z=X?`${Z}
`:Z,Z}static _getFromCache(Z,X,K,J){let Q=K[Z];return typeof Q!="number"&&(Q=n$n._measureText(Z,X,J)+X,K[Z]=Q),Q}static _collapseSpaces(Z){return Z==="normal"||Z==="pre-line"}static _collapseNewlines(Z){return Z==="normal"}static _trimRight(Z){if(typeof Z!="string")return"";for(let X=Z.length-1;X>=0;X--){const K=Z[X];if(!n$n.isBreakingSpace(K))break;Z=Z.slice(0,-1)}return Z}static _isNewline(Z){return typeof Z!="string"?!1:n$n._newlines.includes(Z.charCodeAt(0))}static isBreakingSpace(Z,X){return typeof Z!="string"?!1:n$n._breakingSpaces.includes(Z.charCodeAt(0))}static _tokenize(Z){const X=[];let K="";if(typeof Z!="string")return X;for(let J=0;J<Z.length;J++){const Q=Z[J],ee=Z[J+1];if(n$n.isBreakingSpace(Q,ee)||n$n._isNewline(Q)){K!==""&&(X.push(K),K=""),X.push(Q);continue}K+=Q}return K!==""&&X.push(K),X}static canBreakWords(Z,X){return X}static canBreakChars(Z,X,K,J,Q){return!0}static wordWrapSplit(Z){return n$n.graphemeSegmenter(Z)}static measureFont(Z){if(n$n._fonts[Z])return n$n._fonts[Z];const X=n$n._context;X.font=Z;const K=X.measureText(n$n.METRICS_STRING+n$n.BASELINE_SYMBOL),J={ascent:K.actualBoundingBoxAscent,descent:K.actualBoundingBoxDescent,fontSize:K.actualBoundingBoxAscent+K.actualBoundingBoxDescent};return n$n._fonts[Z]=J,J}static clearMetrics(Z=""){Z?delete n$n._fonts[Z]:n$n._fonts={}}static get _canvas(){if(!n$n.__canvas){let Z;try{const X=new OffscreenCanvas(0,0),K=X.getContext("2d",k);if(K!=null&&K.measureText)return n$n.__canvas=X,X;Z=DOMAdapter.get().createCanvas()}catch(X){Z=DOMAdapter.get().createCanvas()}Z.width=Z.height=10,n$n.__canvas=Z}return n$n.__canvas}static get _context(){return n$n.__context||(n$n.__context=n$n._canvas.getContext("2d",k)),n$n.__context}};let CanvasTextMetrics=n$n;CanvasTextMetrics.METRICS_STRING="|\xC9q\xC5",CanvasTextMetrics.BASELINE_SYMBOL="M",CanvasTextMetrics.BASELINE_MULTIPLIER=1.4,CanvasTextMetrics.HEIGHT_MULTIPLIER=2,CanvasTextMetrics.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const Z=new Intl.Segmenter;return X=>[...Z.segment(X)].map(K=>K.segment)}return Z=>[...Z]})(),CanvasTextMetrics.experimentalLetterSpacing=!1,CanvasTextMetrics._fonts={},CanvasTextMetrics._newlines=[10,13],CanvasTextMetrics._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288],CanvasTextMetrics._measurementCache={};function getCanvasFillStyle(Z,X){if(Z.texture===Texture.WHITE&&!Z.fill)return Color.shared.setValue(Z.color).toHex();if(Z.fill){if(Z.fill instanceof FillPattern){const K=Z.fill,J=X.createPattern(K.texture.source.resource,"repeat"),Q=K.transform.copyTo(Matrix.shared);return Q.scale(K.texture.frame.width,K.texture.frame.height),J.setTransform(Q),J}else if(Z.fill instanceof FillGradient){const K=Z.fill;if(K.type==="linear"){const J=X.createLinearGradient(K.x0,K.y0,K.x1,K.y1);return K.gradientStops.forEach(Q=>{J.addColorStop(Q.offset,Color.shared.setValue(Q.color).toHex())}),J}}}else{const K=X.createPattern(Z.texture.source.resource,"repeat"),J=Z.matrix.copyTo(Matrix.shared);return J.scale(Z.texture.frame.width,Z.texture.frame.height),K.setTransform(J),K}return"red"}class CanvasTextSystem{constructor(){this._activeTextures={}}getTextureSize(X,K,J){const Q=CanvasTextMetrics.measureText(X||" ",J);let ee=Math.ceil(Math.ceil(Math.max(1,Q.width)+J.padding*2)*K),te=Math.ceil(Math.ceil(Math.max(1,Q.height)+J.padding*2)*K);return ee=Math.ceil(ee-1e-6),te=Math.ceil(te-1e-6),ee=nextPow2(ee),te=nextPow2(te),{width:ee,height:te}}getTexture(X,K,J,Q){if(this._activeTextures[Q])return this._increaseReferenceCount(Q),this._activeTextures[Q].texture;const ee=CanvasTextMetrics.measureText(X||" ",J),te=Math.ceil(Math.ceil(Math.max(1,ee.width)+J.padding*2)*K),re=Math.ceil(Math.ceil(Math.max(1,ee.height)+J.padding*2)*K),ne=CanvasPool.getOptimalCanvasAndContext(te,re),{canvas:ie}=ne;this.renderTextToCanvas(X,J,K,ne);const se=getPo2TextureFromSource(ie,te,re,K);if(J.trim){const oe=getCanvasBoundingBox(ie,K);se.frame.copyFrom(oe),se.updateUvs()}return this._activeTextures[Q]={canvasAndContext:ne,texture:se,usageCount:1},se}_increaseReferenceCount(X){this._activeTextures[X].usageCount++}decreaseReferenceCount(X){const K=this._activeTextures[X];if(K.usageCount--,K.usageCount===0){CanvasPool.returnCanvasAndContext(K.canvasAndContext),TexturePool.returnTexture(K.texture);const J=K.texture.source;J.resource=null,J.uploadMethodId="unknown",J.alphaMode="no-premultiply-alpha",this._activeTextures[X]=null}}getReferenceCount(X){return this._activeTextures[X].usageCount}renderTextToCanvas(X,K,J,Q){var ee,te,re,ne,ie,se;const{canvas:oe,context:ae}=Q,le=fontStringFromTextStyle(K),ce=CanvasTextMetrics.measureText(X||" ",K),de=ce.lines,he=ce.lineHeight,pe=ce.lineWidths,fe=ce.maxLineWidth,ge=ce.fontProperties,me=oe.height;if(ae.resetTransform(),ae.scale(J,J),ae.clearRect(0,0,ce.width+4,ce.height+4),(ee=K._stroke)!=null&&ee.width){const ve=K._stroke;ae.lineWidth=ve.width,ae.miterLimit=ve.miterLimit,ae.lineJoin=ve.join,ae.lineCap=ve.cap}ae.font=le;let ye,_e;const Ae=K.dropShadow?2:1;for(let ve=0;ve<Ae;++ve){const be=K.dropShadow&&ve===0,xe=be?Math.ceil(Math.max(1,me)+K.padding*2):0,Se=xe*J;if(be){ae.fillStyle="black",ae.strokeStyle="black";const Te=K.dropShadow,Ie=Te.color,we=Te.alpha;ae.shadowColor=Color.shared.setValue(Ie).setAlpha(we).toRgbaString();const Be=Te.blur*J,De=Te.distance*J;ae.shadowBlur=Be,ae.shadowOffsetX=Math.cos(Te.angle)*De,ae.shadowOffsetY=Math.sin(Te.angle)*De+Se}else ae.globalAlpha=(re=(te=K._fill)==null?void 0:te.alpha)!=null?re:1,ae.fillStyle=K._fill?getCanvasFillStyle(K._fill,ae):null,(ne=K._stroke)!=null&&ne.width&&(ae.strokeStyle=getCanvasFillStyle(K._stroke,ae)),ae.shadowColor="black";let $e=(he-ge.fontSize)/2;he-ge.fontSize<0&&($e=0);const Ce=(se=(ie=K._stroke)==null?void 0:ie.width)!=null?se:0;for(let Te=0;Te<de.length;Te++)ye=Ce/2,_e=Ce/2+Te*he+ge.ascent+$e,K.align==="right"?ye+=fe-pe[Te]:K.align==="center"&&(ye+=(fe-pe[Te])/2),K._stroke&&this._drawLetterSpacing(de[Te],K,Q,ye+K.padding,_e+K.padding-xe,!0),K._fill!==void 0&&this._drawLetterSpacing(de[Te],K,Q,ye+K.padding,_e+K.padding-xe)}}_drawLetterSpacing(X,K,J,Q,ee,te=!1){const{context:re}=J,ne=K.letterSpacing;let ie=!1;if(CanvasTextMetrics.experimentalLetterSpacingSupported&&(CanvasTextMetrics.experimentalLetterSpacing?(re.letterSpacing=`${ne}px`,re.textLetterSpacing=`${ne}px`,ie=!0):(re.letterSpacing="0px",re.textLetterSpacing="0px")),ne===0||ie){te?re.strokeText(X,Q,ee):re.fillText(X,Q,ee);return}let se=Q;const oe=CanvasTextMetrics.graphemeSegmenter(X);let ae=re.measureText(X).width,le=0;for(let ce=0;ce<oe.length;++ce){const de=oe[ce];te?re.strokeText(de,se,ee):re.fillText(de,se,ee);let he="";for(let pe=ce+1;pe<oe.length;++pe)he+=oe[pe];le=re.measureText(he).width,se+=ae-le+ne,ae=le}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"canvasText"},b$r.add(CanvasTextSystem),b$r.add(CanvasTextPipe);class ProxyRenderable extends eventemitter3{constructor({original:X,view:K}){super(),this.uid=uid("renderable"),this.didViewUpdate=!1,this.view=K,X&&this.init(X)}init(X){this._original=X,this.rgTransform=X.rgTransform}get rgColorAlpha(){return this._original.rgColorAlpha}get rgColor(){return this._original.rgColor}get rgAlpha(){return this._original.rgAlpha}get rgBlendMode(){return this._original.rgBlendMode}get rgVisibleRenderable(){return this._original.rgVisibleRenderable}get isRenderable(){return this._original.isRenderable}}class GraphicsView{constructor(X){this.uid=uid("graphicsView"),this.canBundle=!0,this.owner=emptyViewObserver,this.renderPipeId="graphics",this.roundPixels=0,X?this._context=X:this._context=this._ownedContext=new GraphicsContext,this._context.on("update",this.onGraphicsContextUpdate,this)}set context(X){X!==this._context&&(this._context.off("update",this.onGraphicsContextUpdate,this),this._context=X,this._context.on("update",this.onGraphicsContextUpdate,this),this.onGraphicsContextUpdate())}get context(){return this._context}addBounds(X){X.addBounds(this._context.bounds)}containsPoint(X){return this._context.containsPoint(X)}onGraphicsContextUpdate(){this._didUpdate=!0,this.owner.onViewUpdate()}destroy(X){this.owner=null,this._ownedContext&&X===!1?this._ownedContext.destroy(X):(X===!0||(X==null?void 0:X.context)===!0)&&this._context.destroy(X),this._ownedContext=null,this._context=null}}function ensurePrecision(Z,X,K){const J=K?X.maxSupportedFragmentPrecision:X.maxSupportedVertexPrecision;if(Z.substring(0,9)!=="precision"){let Q=K?X.requestedFragmentPrecision:X.requestedVertexPrecision;if(Q==="highp"&&J!=="highp"&&(Q="mediump"),Z.substring(0,8)!=="#version")return`precision ${Q} float;
${Z}`;const ee=Z.indexOf(`
`);return`${Z.substring(0,ee+1)}precision ${Q} float;
${Z.substring(ee+1)}`}else if(J!=="highp"&&Z.substring(0,15)==="precision highp")return Z.replace("precision highp","precision mediump");return Z}const t$9={};let e$2=t$9;function getTestContext(){return(e$2===t$9||e$2!=null&&e$2.isContextLost())&&(e$2=DOMAdapter.get().createCanvas().getContext("webgl2",{})),e$2}let t$8;function getMaxFragmentPrecision(){if(!t$8){t$8="mediump";const Z=getTestContext();Z&&Z.getShaderPrecisionFormat&&(t$8=Z.getShaderPrecisionFormat(Z.FRAGMENT_SHADER,Z.HIGH_FLOAT).precision?"highp":"mediump")}return t$8}const f$m={},g$h={};function setProgramName(Z,{name:X="pixi-program"},K=!0){X=X.replace(/\s+/g,"-"),X+=K?"-fragment":"-vertex";const J=K?f$m:g$h;if(J[X]?(J[X]++,X+=`-${J[X]}`):J[X]=1,Z.indexOf("#define SHADER_NAME")!==-1)return Z;const Q=`#define SHADER_NAME ${X}`;if(Z.substring(0,8)!=="#version")return`${Q}
${Z}`;const ee=Z.indexOf(`
`);return`${Z.substring(0,ee+1)}${Q}
${Z.substring(ee+1)}`}function setProgramVersion(Z,{version:X="300 es"}){return Z.substring(0,8)==="#version"?Z:`#version ${X}
${Z}`}var p$q=Object.defineProperty,g$g=Object.getOwnPropertySymbols,d$i=Object.prototype.hasOwnProperty,b$e=Object.prototype.propertyIsEnumerable,f$l=(Z,X,K)=>X in Z?p$q(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$i=(Z,X)=>{for(var K in X||(X={}))d$i.call(X,K)&&f$l(Z,K,X[K]);if(g$g)for(var K of g$g(X))b$e.call(X,K)&&f$l(Z,K,X[K]);return Z};const m$k={ensurePrecision,setProgramName,setProgramVersion},l$j=Object.create(null),i$g=class{constructor(Z){Z=o$i(o$i({},i$g.defaultOptions),Z);const X={ensurePrecision:{requestedFragmentPrecision:Z.preferredFragmentPrecision,requestedVertexPrecision:Z.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:getMaxFragmentPrecision()},setProgramName:{name:Z.name},setProgramVersion:{version:"300 es"}};let K=Z.fragment,J=Z.vertex;Object.keys(m$k).forEach(Q=>{var ee;const te=(ee=X[Q])!=null?ee:{};K=m$k[Q](K,te,!0),J=m$k[Q](J,te,!1)}),this.fragment=K,this.vertex=J,this._key=`${this.vertex}:${this.fragment}`}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(Z){const X=`${Z.vertex}:${Z.fragment}`;return l$j[X]||(l$j[X]=new i$g(Z)),l$j[X]}};let GlProgram=i$g;GlProgram.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};function extractStructAndGroups(Z){var X,K,J;const Q=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,ee=/@group\((\d+)\)/,te=/@binding\((\d+)\)/,re=/var(<[^>]+>)? (\w+)/,ne=/:\s*(\w+)/,ie=/struct\s+(\w+)\s*{([^}]+)}/g,se=/(\w+)\s*:\s*([\w\<\>]+)/g,oe=/struct\s+(\w+)/,ae=(X=Z.match(Q))==null?void 0:X.map(ce=>({group:parseInt(ce.match(ee)[1],10),binding:parseInt(ce.match(te)[1],10),name:ce.match(re)[2],isUniform:ce.match(re)[1]==="<uniform>",type:ce.match(ne)[1]}));if(!ae)return{groups:[],structs:[]};const le=(J=(K=Z.match(ie))==null?void 0:K.map(ce=>{const de=ce.match(oe)[1],he=ce.match(se).reduce((pe,fe)=>{const[ge,me]=fe.split(":");return pe[ge.trim()]=me.trim(),pe},{});return he?{name:de,members:he}:null}).filter(({name:ce})=>ae.some(de=>de.type===ce)))!=null?J:[];return{groups:ae,structs:le}}var ShaderStage=(Z=>(Z[Z.VERTEX=1]="VERTEX",Z[Z.FRAGMENT=2]="FRAGMENT",Z[Z.COMPUTE=4]="COMPUTE",Z))(ShaderStage||{});function generateGpuLayoutGroups({groups:Z}){const X=[];for(let K=0;K<Z.length;K++){const J=Z[K];X[J.group]||(X[J.group]=[]),J.isUniform?X[J.group].push({binding:J.binding,visibility:ShaderStage.VERTEX|ShaderStage.FRAGMENT,buffer:{type:"uniform"}}):J.type==="sampler"?X[J.group].push({binding:J.binding,visibility:ShaderStage.FRAGMENT,sampler:{type:"filtering"}}):J.type==="texture_2d"&&X[J.group].push({binding:J.binding,visibility:ShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return X}function generateLayoutHash({groups:Z}){const X=[];for(let K=0;K<Z.length;K++){const J=Z[K];X[J.group]||(X[J.group]={}),X[J.group][J.name]=J.binding}return X}function removeStructAndGroupDuplicates(Z,X){const K=new Set,J=new Set,Q=[...Z.structs,...X.structs].filter(te=>K.has(te.name)?!1:(K.add(te.name),!0)),ee=[...Z.groups,...X.groups].filter(te=>{const re=`${te.name}-${te.binding}`;return J.has(re)?!1:(J.add(re),!0)});return{structs:Q,groups:ee}}const a$q=Object.create(null);class GpuProgram{constructor(X){this._layoutKey=0;const{fragment:K,vertex:J,layout:Q,gpuLayout:ee,name:te}=X;if(this.name=te,this.fragment=K,this.vertex=J,K.source===J.source){const re=extractStructAndGroups(K.source);this.structsAndGroups=re}else{const re=extractStructAndGroups(J.source),ne=extractStructAndGroups(K.source);this.structsAndGroups=removeStructAndGroupDuplicates(re,ne)}this.layout=Q!=null?Q:generateLayoutHash(this.structsAndGroups),this.gpuLayout=ee!=null?ee:generateGpuLayoutGroups(this.structsAndGroups)}destroy(){this._gpuLayout=null,this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(X){const K=`${X.vertex.source}:${X.fragment.source}:${X.fragment.entryPoint}:${X.vertex.entryPoint}`;return a$q[K]||(a$q[K]=new GpuProgram(X)),a$q[K]}}function addBits(Z,X,K){if(Z)for(const J in Z){const Q=J.toLocaleLowerCase(),ee=X[Q];if(ee){let te=Z[J];J==="header"&&(te=te.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),K&&ee.push(`//----${K}----//`),ee.push(te)}}}const findHooksRx=/\{\{(.*?)\}\}/g;function compileHooks(Z){var X,K;const J={};return((K=(X=Z.match(findHooksRx))==null?void 0:X.map(Q=>Q.replace(/[{()}]/g,"")))!=null?K:[]).forEach(Q=>{J[Q]=[]}),J}function o$h(Z,X){let K;const J=/@in\s+([^;]+);/g;for(;(K=J.exec(Z))!==null;)X.push(K[1])}function compileInputs(Z,X,K=!1){const J=[];o$h(X,J),Z.forEach(re=>{re.header&&o$h(re.header,J)});const Q=J;K&&Q.sort();const ee=Q.map((re,ne)=>`       @location(${ne}) ${re},`).join(`
`);let te=X.replace(/@in\s+[^;]+;\s*/g,"");return te=te.replace("{{in}}",`
${ee}
`),te}function i$f(Z,X){let K;const J=/@out\s+([^;]+);/g;for(;(K=J.exec(Z))!==null;)X.push(K[1])}function l$i(Z){const X=/\b(\w+)\s*:/g.exec(Z);return X?X[1]:""}function p$p(Z){const X=/@.*?\s+/g;return Z.replace(X,"")}function compileOutputs(Z,X){const K=[];i$f(X,K),Z.forEach(ne=>{ne.header&&i$f(ne.header,K)});let J=0;const Q=K.sort().map(ne=>ne.indexOf("builtin")>-1?ne:`@location(${J++}) ${ne}`).join(`,
`),ee=K.sort().map(ne=>`       var ${p$p(ne)};`).join(`
`),te=`return VSOutput(
                ${K.sort().map(ne=>` ${l$i(ne)}`).join(`,
`)});`;let re=X.replace(/@out\s+[^;]+;\s*/g,"");return re=re.replace("{{struct}}",`
${Q}
`),re=re.replace("{{start}}",`
${ee}
`),re=re.replace("{{return}}",`
${te}
`),re}function injectBits(Z,X){let K=Z;for(const J in X){const Q=X[J];Q.join(`
`).length?K=K.replace(`{{${J}}}`,`//-----${J} START-----//
${Q.join(`
`)}
//----${J} FINISH----//`):K=K.replace(`{{${J}}}`,"")}return K}const o$g=Object.create(null),m$j=new Map;let S$5=0;function compileHighShader({template:Z,bits:X}){const K=f$k(Z,X);if(o$g[K])return o$g[K];const{vertex:J,fragment:Q}=H$2(Z,X);return o$g[K]=u$k(J,Q,X),o$g[K]}function compileHighShaderGl({template:Z,bits:X}){const K=f$k(Z,X);return o$g[K]||(o$g[K]=u$k(Z.vertex,Z.fragment,X)),o$g[K]}function H$2(Z,X){const K=X.map(te=>te.vertex).filter(te=>!!te),J=X.map(te=>te.fragment).filter(te=>!!te);let Q=compileInputs(K,Z.vertex);Q=compileOutputs(K,Q);const ee=compileInputs(J,Z.fragment,!0);return{vertex:Q,fragment:ee}}function f$k(Z,X){return X.map(K=>(m$j.has(K)||m$j.set(K,S$5++),m$j.get(K))).sort((K,J)=>K-J).join("-")+Z.vertex+Z.fragment}function u$k(Z,X,K){const J=compileHooks(Z),Q=compileHooks(X);return K.forEach(ee=>{addBits(ee.vertex,J,ee.name),addBits(ee.fragment,Q,ee.name)}),{vertex:injectBits(Z,J),fragment:injectBits(X,Q)}}const o$f=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.worldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);
        vUV = aUV;

        {{main}}

        var modelViewProjectionMatrix = globalUniforms.projectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.worldColorAlpha;

        {{end}}

        {{return}}
    };
`,r$4=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`,t$7=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = worldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;

        {{start}}
        
        vColor = vec4(1.);
        vUV = aUV;

        {{main}}

        mat3 modelViewProjectionMatrix = projectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= worldColorAlpha;

        {{end}}
    }
`,i$e=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`,globalUniformsBit={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            projectionMatrix:mat3x3<f32>,
            worldTransformMatrix:mat3x3<f32>,
            worldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},globalUniformsBitGl={name:"global-uniforms-bit",vertex:{header:`
          uniform globalUniforms {
            mat3 projectionMatrix;
            mat3 worldTransformMatrix;
            vec4 worldColorAlpha;
            vec2 uResolution;
          };
        `}};var a$p=Object.defineProperty,m$i=Object.getOwnPropertySymbols,n$m=Object.prototype.hasOwnProperty,p$o=Object.prototype.propertyIsEnumerable,i$d=(Z,X,K)=>X in Z?a$p(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$e=(Z,X)=>{for(var K in X||(X={}))n$m.call(X,K)&&i$d(Z,K,X[K]);if(m$i)for(var K of m$i(X))p$o.call(X,K)&&i$d(Z,K,X[K]);return Z};function compileHighShaderGpuProgram({bits:Z,name:X}){const K=compileHighShader({template:{fragment:r$4,vertex:o$f},bits:[globalUniformsBit,...Z]});return new GpuProgram({name:X,vertex:{source:K.vertex,entryPoint:"main"},fragment:{source:K.fragment,entryPoint:"main"}})}function compileHighShaderGlProgram({bits:Z,name:X}){return new GlProgram(o$e({name:X},compileHighShaderGl({template:{vertex:t$7,fragment:i$e},bits:[globalUniformsBitGl,...Z]})))}const colorBit={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},colorBitGl={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},n$l={};function o$d(Z){const X=[];if(Z===1)X.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),X.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let K=0;for(let J=0;J<Z;J++)X.push(`@group(1) @binding(${K++}) var textureSource${J+1}: texture_2d<f32>;`),X.push(`@group(1) @binding(${K++}) var textureSampler${J+1}: sampler;`)}return X.join(`
`)}function a$o(Z){const X=[];if(Z===1)X.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{X.push("switch vTextureId {");for(let K=0;K<Z;K++)K===Z-1?X.push("  default:{"):X.push(`  case ${K}:{`),X.push(`      outColor = textureSampleGrad(textureSource${K+1}, textureSampler${K+1}, vUV, uvDx, uvDy);`),X.push("      break;}");X.push("}")}return X.join(`
`)}function generateTextureBatchBit(Z){return n$l[Z]||(n$l[Z]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;
    
                ${o$d(16)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${a$o(16)}
            `}}),n$l[Z]}const i$c={};function d$h(Z){const X=[];for(let K=0;K<Z;K++)K>0&&X.push("else"),K<Z-1&&X.push(`if(vTextureId < ${K}.5)`),X.push("{"),X.push(`	outColor = texture(uSamplers[${K}], vUV);`),X.push("}");return X.join(`
`)}function generateTextureBatchBitGl(Z){return i$c[Z]||(i$c[Z]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;
    
                uniform sampler2D uSamplers[${Z}];
              
            `,main:`
    
                ${d$h(16)}
            `}}),i$c[Z]}const roundPixelsBit={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `}},roundPixelsBitGl={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `}},o$c=new Int32Array(MAX_TEXTURES);for(let Z=0;Z<MAX_TEXTURES;Z++)o$c[Z]=Z;const batchSamplersUniformGroup=new UniformGroup({uSamplers:{value:o$c,type:"u32",size:MAX_TEXTURES}},{isStatic:!0});var RendererType=(Z=>(Z[Z.WEBGL=1]="WEBGL",Z[Z.WEBGPU=2]="WEBGPU",Z))(RendererType||{});class Shader extends eventemitter3{constructor({gpuProgram:X,glProgram:K,groups:J,resources:Q,groupMap:ee,compatibleRenderers:te}){super(),this._uniformBindMap=Object.create(null),this.gpuProgram=X,this.glProgram=K,te===void 0&&(te=0,X&&(te|=RendererType.WEBGPU),K&&(te|=RendererType.WEBGL)),this.compatibleRenderers=te;const re={};if(Q&&J)throw new Error("[Shader] Cannot have both resources and groups");if(!Q&&!J)throw new Error("[Shader] Must provide either resources or groups descriptor");if(!X&&J&&!ee)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!X&&J&&ee)for(const ne in ee)for(const ie in ee[ne]){const se=ee[ne][ie];re[se]={group:ne,binding:ie,name:se}}else if(X&&J&&!ee){const ne=X.structsAndGroups.groups;ee={},ne.forEach(ie=>{ee[ie.group]=ee[ie.group]||{},ee[ie.group][ie.binding]=ie.name,re[ie.name]=ie})}else if(Q){if(X){const ne=X.structsAndGroups.groups;ee={},ne.forEach(ie=>{ee[ie.group]=ee[ie.group]||{},ee[ie.group][ie.binding]=ie.name,re[ie.name]=ie})}else{ee={},J={99:new BindGroup};let ne=0;for(const ie in Q)re[ie]={group:99,binding:ne,name:ie},ee[99]=ee[99]||{},ee[99][ne]=ie,ne++}J={};for(const ne in Q){const ie=ne;let se=Q[ne];!se.source&&!se._resourceType&&(se=new UniformGroup(se));const oe=re[ie];oe&&(J[oe.group]=J[oe.group]||new BindGroup,J[oe.group].setResource(se,oe.binding))}}this.groups=J,this._uniformBindMap=ee,this.resources=this._buildResourceAccessor(J,re)}addResource(X,K,J){var Q,ee;(Q=this._uniformBindMap)[K]||(Q[K]={}),(ee=this._uniformBindMap[K])[J]||(ee[J]=X)}_buildResourceAccessor(X,K){const J={};for(const Q in K){const ee=K[Q];Object.defineProperty(J,ee.name,{get(){return X[ee.group].getResource(ee.binding)},set(te){X[ee.group].setResource(te,ee.binding)}})}return J}destroy(X=!1){var K,J;this.emit("destroy",this),X&&((K=this.gpuProgram)==null||K.destroy(),(J=this.glProgram)==null||J.destroy()),this.gpuProgram=null,this.glProgram=null,this.groups=null,this.removeAllListeners(),this._uniformBindMap=null,this.resources=null}}const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `}},mSDFBit={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}},mSDFBitGl={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}};class SdfShader extends Shader{constructor(){const X=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),K=compileHighShaderGpuProgram({name:"sdf-shader",bits:[colorBit,generateTextureBatchBit(MAX_TEXTURES),localUniformMSDFBit,mSDFBit,roundPixelsBit]}),J=compileHighShaderGlProgram({name:"sdf-shader",bits:[colorBitGl,generateTextureBatchBitGl(MAX_TEXTURES),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBitGl]});super({glProgram:J,gpuProgram:K,resources:{localUniforms:X,batchSamplers:batchSamplersUniformGroup}})}}const n$k=["_fontFamily","_fontStyle","_fontSize","_fontVariant","_fontWeight","_breakWords","_align","_leading","_letterSpacing","_lineHeight","_textBaseline","_whiteSpace","_wordWrap","_wordWrapWidth","_padding","_cssOverrides","_trim"];function generateTextStyleKey(Z){const X=[];let K=0;for(let J=0;J<n$k.length;J++){const Q=n$k[J];X[K++]=Z[Q]}return K=o$b(Z._fill,X,K),K=l$h(Z._stroke,X,K),X.join("-")}function o$b(Z,X,K){var J;return Z&&(X[K++]=Z.color,X[K++]=Z.alpha,X[K++]=(J=Z.fill)==null?void 0:J.uid),K}function l$h(Z,X,K){return Z&&(K=o$b(Z,X,K),X[K++]=Z.width,X[K++]=Z.alignment,X[K++]=Z.cap,X[K++]=Z.join,X[K++]=Z.miterLimit),K}var c$i=Object.defineProperty,y$9=Object.getOwnPropertySymbols,m$h=Object.prototype.hasOwnProperty,_$3=Object.prototype.propertyIsEnumerable,g$f=(Z,X,K)=>X in Z?c$i(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$j=(Z,X)=>{for(var K in X||(X={}))m$h.call(X,K)&&g$f(Z,K,X[K]);if(y$9)for(var K of y$9(X))_$3.call(X,K)&&g$f(Z,K,X[K]);return Z};const o$a=class extends eventemitter3{constructor(Z={}){super(),W$2(Z);const X=h$j(h$j({},o$a.defaultTextStyle),Z);for(const K in o$a.defaultTextStyle){const J=K;this[J]=X[K]}this.dropShadow=null,typeof X.fill=="string"?this.fontSize=parseInt(X.fontSize,10):this.fontSize=X.fontSize,Z.dropShadow&&(Z.dropShadow instanceof Boolean?Z.dropShadow===!0&&(this.dropShadow=h$j({},o$a.defaultTextStyle.dropShadow)):this.dropShadow=h$j(h$j({},o$a.defaultTextStyle.dropShadow),Z.dropShadow)),this.update()}get align(){return this._align}set align(Z){this._align=Z,this.update()}get breakWords(){return this._breakWords}set breakWords(Z){this._breakWords=Z,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(Z){this._dropShadow=Z,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(Z){this._fontFamily=Z,this.update()}get fontSize(){return this._fontSize}set fontSize(Z){this._fontSize=Z,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(Z){this._fontStyle=Z,this.update()}get fontVariant(){return this._fontVariant}set fontVariant(Z){this._fontVariant=Z,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(Z){this._fontWeight=Z,this.update()}get leading(){return this._leading}set leading(Z){this._leading=Z,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(Z){this._letterSpacing=Z,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(Z){this._lineHeight=Z,this.update()}get padding(){return this._padding}set padding(Z){this._padding=Z,this.update()}get trim(){return this._trim}set trim(Z){this._trim=Z,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(Z){this._textBaseline=Z,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(Z){this._whiteSpace=Z,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(Z){this._wordWrap=Z,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(Z){this._wordWrapWidth=Z,this.update()}get fill(){return this._originalFill}set fill(Z){Z!==this._originalFill&&(this._originalFill=Z,this._fill=convertFillInputToFillStyle(Z,GraphicsContext.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(Z){Z!==this._originalFill&&(this._originalFill=Z,this._stroke=convertFillInputToFillStyle(Z,GraphicsContext.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=generateTextStyleKey(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}reset(){const Z=o$a.defaultTextStyle;for(const X in Z)this[X]=Z[X]}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new o$a({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(Z=!1){var X,K,J,Q;if(this.removeAllListeners(),typeof Z=="boolean"?Z:Z==null?void 0:Z.texture){const ee=typeof Z=="boolean"?Z:Z==null?void 0:Z.textureSource;(X=this._fill)!=null&&X.texture&&this._fill.texture.destroy(ee),(K=this._originalFill)!=null&&K.texture&&this._originalFill.texture.destroy(ee),(J=this._stroke)!=null&&J.texture&&this._stroke.texture.destroy(ee),(Q=this._originalStroke)!=null&&Q.texture&&this._originalStroke.texture.destroy(ee)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}};let TextStyle=o$a;TextStyle.defaultTextStyle={align:"left",breakWords:!1,dropShadow:{alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5},fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};function W$2(Z){var X,K;const J=Z;if(typeof J.dropShadow=="boolean"&&(deprecation(v8_0_0,"dropShadow is now an object, not a boolean"),Z.dropShadow={alpha:(X=J.dropShadowAlpha)!=null?X:1,angle:J.dropShadowAngle,blur:(K=J.dropShadowBlur)!=null?K:0,color:J.dropShadowColor,distance:J.dropShadowDistance}),J.strokeThickness){deprecation(v8_0_0,"strokeThickness is now a part of stroke");const Q=J.stroke;Z.stroke={color:Q,width:J.strokeThickness}}if(Array.isArray(J.fill)){deprecation(v8_0_0,"gradient fill is now a fill pattern: `new FillGradient(...)`");const Q=new FillGradient(0,0,0,Z.fontSize*1.7),ee=J.fill.map(te=>Color.shared.setValue(te).toNumber());ee.forEach((te,re)=>{var ne;const ie=(ne=J.fillGradientStops[re])!=null?ne:re/ee.length;Q.addColorStop(ie,te)}),Z.fill={fill:Q}}}function resolveCharacters(Z){if(Z==="")return[];typeof Z=="string"&&(Z=[Z]);const X=[];for(let K=0,J=Z.length;K<J;K++){const Q=Z[K];if(Array.isArray(Q)){if(Q.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${Q.length}.`);if(Q[0].length===0||Q[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const ee=Q[0].charCodeAt(0),te=Q[1].charCodeAt(0);if(te<ee)throw new Error("[BitmapFont]: Invalid character range.");for(let re=ee,ne=te;re<=ne;re++)X.push(String.fromCharCode(re))}else X.push(...Array.from(Q))}if(X.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return X}class DynamicBitmapFont extends AbstractBitmapFont{constructor(X){var K,J,Q;super(),this.resolution=1,this.pages=[],this._padding=4,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const ee=X,te=ee.style.clone();te.fontSize=this.baseMeasurementFontSize,ee.overrideFill&&(te._fill.color=16777215,te._fill.alpha=1,te._fill.texture=Texture.WHITE,te._fill.fill=null),this._style=te,this._skipKerning=(K=ee.skipKerning)!=null?K:!1,this.resolution=(J=ee.resolution)!=null?J:1,this._padding=(Q=ee.padding)!=null?Q:4;const re=fontStringFromTextStyle(te);this.fontMetrics=CanvasTextMetrics.measureFont(re),this.lineHeight=te.lineHeight||this.fontMetrics.fontSize||te.fontSize}ensureCharacters(X){var K,J,Q,ee;const te=resolveCharacters(X).filter(ge=>!this._currentChars.includes(ge)).filter((ge,me,ye)=>ye.indexOf(ge)===me);if(!te.length)return;this._currentChars=[...this._currentChars,...te];let re;this._currentPageIndex===-1?re=this._nextPage():re=this.pages[this._currentPageIndex];let{canvas:ne,context:ie}=re.canvasAndContext,se=re.texture.source;const oe=this._style;let ae=this._currentX,le=this._currentY;const ce=this.baseRenderedFontSize/this.baseMeasurementFontSize,de=this._padding*ce,he=oe.fontStyle==="italic"?2:1;let pe=0,fe=!1;for(let ge=0;ge<te.length;ge++){const me=te[ge],ye=CanvasTextMetrics.measureText(me,oe,ne,!1);ye.lineHeight=ye.height;const _e=he*ye.width*ce,Ae=ye.height*ce,ve=_e+de*2,be=Ae+de*2;if(fe=!1,me!==`
`&&me!=="\r"&&me!=="	"&&me!==" "&&(fe=!0,pe=Math.ceil(Math.max(be,pe))),ae+ve>512&&(le+=pe,pe=be,ae=0,le+pe>512)){se.update();const Se=this._nextPage();ne=Se.canvasAndContext.canvas,ie=Se.canvasAndContext.context,se=Se.texture.source,le=0}const xe=_e/ce-((J=(K=oe.dropShadow)==null?void 0:K.distance)!=null?J:0)-((ee=(Q=oe._stroke)==null?void 0:Q.width)!=null?ee:0);if(this.chars[me]={id:me.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:xe,kerning:{}},fe){this._drawGlyph(ie,ye,ae+de,le+de,ce,oe);const Se=se.width*ce,$e=se.height*ce,Ce=new Rectangle(ae/Se*se.width,le/$e*se.height,ve/Se*se.width,be/$e*se.height);this.chars[me].texture=new Texture({source:se,frame:Ce}),ae+=Math.ceil(ve)}}se.update(),this._currentX=ae,this._currentY=le,this._skipKerning&&this._applyKerning(te,ie)}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(X,K){const J=this._measureCache;for(let Q=0;Q<X.length;Q++){const ee=X[Q];for(let te=0;te<this._currentChars.length;te++){const re=this._currentChars[te];let ne=J[ee];ne||(ne=J[ee]=K.measureText(ee).width);let ie=J[re];ie||(ie=J[re]=K.measureText(re).width);let se=K.measureText(ee+re).width,oe=se-(ne+ie);oe&&(this.chars[ee].kerning[re]=oe),se=K.measureText(ee+re).width,oe=se-(ne+ie),oe&&(this.chars[re].kerning[ee]=oe)}}}_nextPage(){this._currentPageIndex++;const X=this.resolution,K=CanvasPool.getOptimalCanvasAndContext(512,512,X);this._setupContext(K.context,this._style,X);const J=X*(this.baseRenderedFontSize/this.baseMeasurementFontSize),Q=new Texture({source:new ImageSource({resource:K.canvas,resolution:J,alphaMode:"premultiply-alpha-on-upload"})}),ee={canvasAndContext:K,texture:Q};return this.pages[this._currentPageIndex]=ee,ee}_setupContext(X,K,J){var Q;K.fontSize=this.baseRenderedFontSize,X.scale(J,J),X.font=fontStringFromTextStyle(K),K.fontSize=this.baseMeasurementFontSize,X.textBaseline=K.textBaseline;const ee=K._stroke,te=(Q=ee==null?void 0:ee.width)!=null?Q:0;if(ee&&(X.lineWidth=te,X.lineJoin=ee.join,X.miterLimit=ee.miterLimit,X.strokeStyle=getCanvasFillStyle(ee,X)),K._fill&&(X.fillStyle=getCanvasFillStyle(K._fill,X)),K.dropShadow){const re=K.dropShadow,ne=Color.shared.setValue(re.color).toArray(),ie=re.blur*J,se=re.distance*J;X.shadowColor=`rgba(${ne[0]*255},${ne[1]*255},${ne[2]*255},${re.alpha})`,X.shadowBlur=ie,X.shadowOffsetX=Math.cos(re.angle)*se,X.shadowOffsetY=Math.sin(re.angle)*se}else X.shadowColor="black",X.shadowBlur=0,X.shadowOffsetX=0,X.shadowOffsetY=0}_drawGlyph(X,K,J,Q,ee,te){var re;const ne=K.text,ie=K.fontProperties,se=te._stroke,oe=((re=se==null?void 0:se.width)!=null?re:0)*ee,ae=J+oe/2,le=Q-oe/2,ce=ie.descent*ee,de=K.lineHeight*ee;te.stroke&&oe&&X.strokeText(ne,ae,le+de-ce),te._fill&&X.fillText(ne,ae,le+de-ce)}destroy(){super.destroy();for(let X=0;X<this.pages.length;X++){const{canvasAndContext:K,texture:J}=this.pages[X];CanvasPool.returnCanvasAndContext(K),J.destroy(!0)}this.pages=null}}function getBitmapTextLayout(Z,X,K){const J={width:0,height:0,offsetY:0,scale:X.fontSize/K.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};J.offsetY=K.baseLineOffset;let Q=J.lines[0],ee=null,te=!0;const re={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},ne=le=>{const ce=Q.width;for(let de=0;de<re.index;de++){const he=le.positions[de];Q.chars.push(le.chars[de]),Q.charPositions.push(he+ce)}Q.width+=le.width,te=!1,re.width=0,re.index=0,re.chars.length=0},ie=()=>{let le=Q.chars.length-1,ce=Q.chars[le];for(;ce===" ";)Q.width-=K.chars[ce].xAdvance,ce=Q.chars[--le];J.width=Math.max(J.width,Q.width),Q={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},te=!0,J.lines.push(Q),J.height+=K.lineHeight},se=K.baseMeasurementFontSize/X.fontSize,oe=X.letterSpacing*se,ae=X.wordWrapWidth*se;for(let le=0;le<Z.length+1;le++){let ce;const de=le===Z.length;de||(ce=Z[le]);const he=K.chars[ce]||K.chars[" "];if(/(?:\s)/.test(ce)||ce==="\r"||ce===`
`||de){if(!te&&X.wordWrap&&Q.width+re.width-oe>ae?(ie(),ne(re),de||Q.charPositions.push(0)):(re.start=Q.width,ne(re),de||Q.charPositions.push(0)),ce==="\r"||ce===`
`)Q.width!==0&&ie();else if(!de){const pe=he.xAdvance+(he.kerning[ee]||0)+oe;Q.width+=pe,Q.spaceWidth=pe,Q.spacesIndex.push(Q.charPositions.length),Q.chars.push(ce)}}else{const pe=he.kerning[ee]||0,fe=he.xAdvance+pe+oe;re.positions[re.index++]=re.width+pe,re.chars.push(ce),re.width+=fe}ee=ce}return ie(),X.align==="center"?b$d(J):X.align==="right"?m$g(J):X.align==="justify"&&S$4(J),J}function b$d(Z){for(let X=0;X<Z.lines.length;X++){const K=Z.lines[X],J=Z.width/2-K.width/2;for(let Q=0;Q<K.charPositions.length;Q++)K.charPositions[Q]+=J}}function m$g(Z){for(let X=0;X<Z.lines.length;X++){const K=Z.lines[X],J=Z.width-K.width;for(let Q=0;Q<K.charPositions.length;Q++)K.charPositions[Q]+=J}}function S$4(Z){const X=Z.width;for(let K=0;K<Z.lines.length;K++){const J=Z.lines[K];let Q=0,ee=J.spacesIndex[Q++],te=0;const re=J.spacesIndex.length,ne=(X-J.width)/re;for(let ie=0;ie<J.charPositions.length;ie++)ie===ee&&(ee=J.spacesIndex[Q++],te+=ne),J.charPositions[ie]+=te}}var y$8=Object.defineProperty,m$f=Object.getOwnPropertySymbols,g$e=Object.prototype.hasOwnProperty,d$g=Object.prototype.propertyIsEnumerable,u$j=(Z,X,K)=>X in Z?y$8(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$n=(Z,X)=>{for(var K in X||(X={}))g$e.call(X,K)&&u$j(Z,K,X[K]);if(m$f)for(var K of m$f(X))d$g.call(X,K)&&u$j(Z,K,X[K]);return Z};class h$i{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(X,K){var J;let Q=`${K.fontFamily}-bitmap`,ee=!0;if(K._fill.fill&&(Q+=K._fill.fill.uid,ee=!1),!Cache.has(Q)){const re=new DynamicBitmapFont(p$n({style:K,overrideFill:ee},this.defaultOptions));re.once("destroy",()=>Cache.remove(Q)),Cache.set(Q,re)}const te=Cache.get(Q);return(J=te.ensureCharacters)==null||J.call(te,X),te}getLayout(X,K){const J=this.getFont(X,K);return getBitmapTextLayout(X.split(""),K,J)}measureText(X,K){return this.getLayout(X,K)}install(X,K,J){if(!X)throw new Error("[BitmapFontManager] Property `name` is required.");J=p$n(p$n({},this.defaultOptions),J);const Q=K instanceof TextStyle?K:new TextStyle(K),ee=Q._fill.fill!==null&&Q._fill.fill!==void 0,te=new DynamicBitmapFont({style:Q,overrideFill:ee,skipKerning:J.skipKerning,padding:J.padding,resolution:J.resolution}),re=resolveCharacters(J.chars);return te.ensureCharacters(re.join("")),Cache.set(`${X}-bitmap`,te),te.once("destroy",()=>Cache.remove(`${X}-bitmap`)),te}uninstall(X){const K=`${X}-bitmap`,J=Cache.get(K);J&&(Cache.remove(K),J.destroy())}}const BitmapFontManager=new h$i;class P$5 extends ProxyRenderable{constructor(){super({view:new GraphicsView})}}class BitmapTextPipe{constructor(X){this._gpuBitmapText={},this._renderer=X}validateRenderable(X){const K=this._getGpuBitmapText(X);return X.view._didUpdate&&(X.view._didUpdate=!1,this._updateContext(X,K.view.context)),this._renderer.renderPipes.graphics.validateRenderable(K)}addRenderable(X,K){const J=this._getGpuBitmapText(X);X.view._didUpdate&&(X.view._didUpdate=!1,this._updateContext(X,J.view.context)),this._renderer.renderPipes.graphics.addRenderable(J,K),J.view.context.customShader&&this._updateDistanceField(X)}destroyRenderable(X){this._destroyRenderableByUid(X.uid)}_destroyRenderableByUid(X){BigPool.return(this._gpuBitmapText[X]),this._gpuBitmapText[X]=null}updateRenderable(X){const K=this._getGpuBitmapText(X);this._renderer.renderPipes.graphics.updateRenderable(K),K.view.context.customShader&&this._updateDistanceField(X)}_updateContext(X,K){var J;const Q=X.view,ee=BitmapFontManager.getFont(Q.text,Q._style);K.clear(),ee.distanceField.type!=="none"&&(K.customShader||(this._sdfShader||(this._sdfShader=new SdfShader),K.customShader=this._sdfShader));const te=Array.from(Q.text),re=Q._style;let ne=(((J=re._stroke)==null?void 0:J.width)||0)/2;ne+=ee.baseLineOffset;const ie=getBitmapTextLayout(te,re,ee);let se=0;const oe=re.padding,ae=ie.scale;K.translate(-Q.anchor._x*ie.width-oe,-Q.anchor._y*(ie.height+ie.offsetY)-oe).scale(ae,ae);const le=re._fill.color;for(let ce=0;ce<ie.lines.length;ce++){const de=ie.lines[ce];for(let he=0;he<de.charPositions.length;he++){const pe=te[se++],fe=ee.chars[pe];fe!=null&&fe.texture&&K.texture(fe.texture,le,Math.round(de.charPositions[he]+fe.xOffset),Math.round(ne+fe.yOffset))}ne+=ee.lineHeight}}_getGpuBitmapText(X){return this._gpuBitmapText[X.uid]||this.initGpuText(X)}initGpuText(X){const K=BigPool.get(P$5,X);return this._gpuBitmapText[X.uid]=K,K.view.roundPixels=this._renderer._roundPixels|X.view.roundPixels,this._updateContext(X,K.view.context),X.on("destroyed",()=>{this.destroyRenderable(X)}),this._gpuBitmapText[X.uid]}_updateDistanceField(X){var K;const J=this._getGpuBitmapText(X).view.context,Q=X.view,ee=Q._style.fontFamily,te=Cache.get(`${ee}-bitmap`),{a:re,b:ne,c:ie,d:se}=X.rgTransform,oe=Math.sqrt(re*re+ne*ne),ae=Math.sqrt(ie*ie+se*se),le=(Math.abs(oe)+Math.abs(ae))/2,ce=te.baseRenderedFontSize/Q._style.fontSize,de=(K=Q.resolution)!=null?K:this._renderer.resolution,he=le*te.distanceField.range*(1/ce)*de;J.customShader.resources.localUniforms.uniforms.uDistance=he}destroy(){var X;for(const K in this._gpuBitmapText)this._destroyRenderableByUid(K);this._gpuBitmapText=null,(X=this._sdfShader)==null||X.destroy(!0),this._sdfShader=null,this._renderer=null}}BitmapTextPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"bitmapText"},b$r.add(BitmapTextPipe);class HTMLTextPipe{constructor(X){this._gpuText=Object.create(null),this._renderer=X}validateRenderable(X){const K=this._getGpuText(X),J=X.view._getKey();return K.textureNeedsUploading?(K.textureNeedsUploading=!1,!0):K.currentKey!==J}addRenderable(X){const K=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),this._renderer.renderPipes.batch.addToBatch(K)}updateRenderable(X){const K=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),K.batcher.updateElement(K)}destroyRenderable(X){this._destroyRenderableById(X.uid)}_destroyRenderableById(X){const K=this._gpuText[X];this._renderer.htmlText.decreaseReferenceCount(K.currentKey),BigPool.return(K.batchableSprite),this._gpuText[X]=null}_updateText(X){const K=X.view._getKey(),J=this._getGpuText(X),Q=J.batchableSprite;J.currentKey!==K&&this._updateGpuText(X).catch(te=>{console.error(te)}),X.view._didUpdate=!1;const ee=X.view._style.padding;updateQuadBounds(Q.bounds,X.view.anchor,Q.texture,ee)}async _updateGpuText(X){var K;X.view._didUpdate=!1;const J=this._getGpuText(X);if(J.generatingTexture)return;const Q=X.view._getKey();this._renderer.htmlText.decreaseReferenceCount(J.currentKey),J.generatingTexture=!0,J.currentKey=Q;const ee=X.view,te=(K=ee.resolution)!=null?K:this._renderer.resolution,re=await this._renderer.htmlText.getManagedTexture(ee.text,te,ee._style,ee._getKey()),ne=J.batchableSprite;ne.texture=J.texture=re,J.generatingTexture=!1,J.textureNeedsUploading=!0,X.view.onUpdate();const ie=X.view._style.padding;updateQuadBounds(ne.bounds,X.view.anchor,ne.texture,ie)}_getGpuText(X){return this._gpuText[X.uid]||this.initGpuText(X)}initGpuText(X){const K={texture:Texture.EMPTY,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite),textureNeedsUploading:!1,generatingTexture:!1},J=K.batchableSprite;return J.renderable=X,J.texture=Texture.EMPTY,J.bounds={left:0,right:1,top:0,bottom:0},J.roundPixels=this._renderer._roundPixels|X.view.roundPixels,this._gpuText[X.uid]=K,X.on("destroyed",()=>{this.destroyRenderable(X)}),K}destroy(){for(const X in this._gpuText)this._destroyRenderableById(X);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"htmlText"};function isSafari(){const{userAgent:Z}=DOMAdapter.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(Z)}function extractFontFamilies(Z,X){const K=X.fontFamily,J=[],Q={},ee=/font-family:([^;"\s]+)/g,te=Z.match(ee);function re(ne){Q[ne]||(J.push(ne),Q[ne]=!0)}if(Array.isArray(K))for(let ne=0;ne<K.length;ne++)re(K[ne]);else re(K);te&&te.forEach(ne=>{const ie=ne.split(":")[1].trim();re(ie)});for(const ne in X.tagStyles){const ie=X.tagStyles[ne].fontFamily;re(ie)}return J}async function loadFontAsBase64(Z){const X=await(await DOMAdapter.get().fetch(Z)).blob(),K=new FileReader;return await new Promise((J,Q)=>{K.onloadend=()=>J(K.result),K.onerror=Q,K.readAsDataURL(X)})}async function loadFontCSS(Z,X){const K=await loadFontAsBase64(X);return`@font-face {
        font-family: "${Z.fontFamily}";
        src: url('${K}');
        font-weight: ${Z.fontWeight};
        font-style: ${Z.fontStyle};
    }`}var c$h=Object.defineProperty,f$j=Object.defineProperties,u$i=Object.getOwnPropertyDescriptors,i$b=Object.getOwnPropertySymbols,x$9=Object.prototype.hasOwnProperty,g$d=Object.prototype.propertyIsEnumerable,m$e=(Z,X,K)=>X in Z?c$h(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$m=(Z,X)=>{for(var K in X||(X={}))x$9.call(X,K)&&m$e(Z,K,X[K]);if(i$b)for(var K of i$b(X))g$d.call(X,K)&&m$e(Z,K,X[K]);return Z},l$g=(Z,X)=>f$j(Z,u$i(X));async function getFontCss(Z,X){const K=Z.filter(J=>Cache.has(J)).map((J,Q)=>{if(!FontStylePromiseCache.has(J)){const{url:ee}=Cache.get(J);Q===0?FontStylePromiseCache.set(J,loadFontCSS(X,ee)):FontStylePromiseCache.set(J,loadFontCSS(l$g(p$m({},HTMLTextSystem.defaultFontOptions),{fontFamily:J}),ee))}return FontStylePromiseCache.get(J)});return(await Promise.all(K)).join(`
`)}function getSVGUrl(Z,X,K,J,Q){const{domElement:ee,styleElement:te,svgRoot:re}=Q;ee.innerHTML=`<style>${X.cssStyle}</style><div>${Z}</div>`,ee.setAttribute("style",`transform: scale(${K});transform-origin: top left; display: inline-block`),te.textContent=J;const{width:ne,height:ie}=Q.image;return re.setAttribute("width",ne.toString()),re.setAttribute("height",ie.toString()),new XMLSerializer().serializeToString(re)}function getTemporaryCanvasFromImage(Z,X){const K=CanvasPool.getOptimalCanvasAndContext(Z.width,Z.height,X),{context:J}=K;return J.clearRect(0,0,Z.width,Z.height),J.drawImage(Z,0,0),CanvasPool.returnCanvasAndContext(K),K.canvas}function loadSVGImage(Z,X,K){return new Promise(async J=>{K&&await new Promise(Q=>setTimeout(Q,100)),Z.onload=()=>{J()},Z.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(X)}`,Z.crossOrigin="anonymous"})}let s$m;function measureHtmlText(Z,X,K,J){J=J||s$m||(s$m=new HTMLTextRenderData);const{domElement:Q,styleElement:ee,svgRoot:te}=J;Q.innerHTML=`<style>${X.cssStyle}</style><div>${Z}</div>`,Q.setAttribute("style","transform-origin: top left; display: inline-block"),K&&(ee.textContent=K),document.body.appendChild(te);const re=Q.getBoundingClientRect();te.remove();const ne=CanvasTextMetrics.measureFont(X.fontStyle).descent;return{width:re.width,height:re.height+ne}}const p$l="http://www.w3.org/2000/svg",d$f="http://www.w3.org/1999/xhtml",FontStylePromiseCache=new Map;class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(p$l,"svg"),this.foreignObject=document.createElementNS(p$l,"foreignObject"),this.domElement=document.createElementNS(d$f,"div"),this.styleElement=document.createElementNS(d$f,"style"),this.image=new Image;const{foreignObject:X,svgRoot:K,styleElement:J,domElement:Q}=this;X.setAttribute("width","10000"),X.setAttribute("height","10000"),X.style.overflow="hidden",K.appendChild(X),X.appendChild(J),X.appendChild(Q)}}class HTMLTextSystem{constructor(X){this._activeTextures={},this._renderer=X,this._createCanvas=X.type===RendererType.WEBGPU}getTexture(X){return this._buildTexturePromise(X.text,X.resolution,X.style)}getManagedTexture(X,K,J,Q){if(this._activeTextures[Q])return this._increaseReferenceCount(Q),this._activeTextures[Q].promise;const ee=this._buildTexturePromise(X,K,J).then(te=>(this._activeTextures[Q].texture=te,te));return this._activeTextures[Q]={texture:null,promise:ee,usageCount:1},ee}async _buildTexturePromise(X,K,J){const Q=BigPool.get(HTMLTextRenderData),ee=extractFontFamilies(X,J),te=await getFontCss(ee,J),re=measureHtmlText(X,J,te,Q),ne=Math.ceil(Math.ceil(Math.max(1,re.width)+J.padding*2)*K),ie=Math.ceil(Math.ceil(Math.max(1,re.height)+J.padding*2)*K),se=Q.image;se.width=ne|0,se.height=ie|0;const oe=getSVGUrl(X,J,K,te,Q);await loadSVGImage(se,oe,isSafari()&&ee.length>0);let ae=se;this._createCanvas&&(ae=getTemporaryCanvasFromImage(se,K));const le=getPo2TextureFromSource(ae,se.width,se.height,K);return this._createCanvas&&this._renderer.texture.initSource(le.source),BigPool.return(Q),le}_increaseReferenceCount(X){this._activeTextures[X].usageCount++}decreaseReferenceCount(X){const K=this._activeTextures[X];K&&(K.usageCount--,K.usageCount===0&&(K.texture?this._cleanUp(K):K.promise.then(J=>{K.texture=J,this._cleanUp(K)}).catch(()=>{}),this._activeTextures[X]=null))}_cleanUp(X){TexturePool.returnTexture(X.texture),X.texture.source.resource=null,X.texture.source.uploadMethodId="unknown"}getReferenceCount(X){return this._activeTextures[X].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"htmlText"},HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"},b$r.add(HTMLTextSystem),b$r.add(HTMLTextPipe);const u$h=new Polygon;class MeshView{constructor(X){this.uid=uid("meshView"),this.renderPipeId="mesh",this.canBundle=!0,this.owner=emptyViewObserver,this.state=State.for2d(),this.roundPixels=0;var K,J,Q;this.shader=X.shader,this.texture=(Q=(J=X.texture)!=null?J:(K=this.shader)==null?void 0:K.texture)!=null?Q:Texture.WHITE,this._geometry=X.geometry,this._geometry.on("update",this.onUpdate,this)}set shader(X){this._shader!==X&&(this._shader=X,this.onUpdate())}get shader(){return this._shader}set geometry(X){var K;this._geometry!==X&&((K=this._geometry)==null||K.off("update",this.onUpdate,this),X.on("update",this.onUpdate,this),this._geometry=X,this.onUpdate())}get geometry(){return this._geometry}set texture(X){this._texture!==X&&(this.shader&&(this.shader.texture=X),this._texture=X,this.onUpdate())}get texture(){return this._texture}get batched(){return this._shader?!1:this._geometry.batchMode==="auto"?this._geometry.positions.length/2<=100:this._geometry.batchMode==="batch"}addBounds(X){X.addVertexData(this.geometry.positions,0,this.geometry.positions.length)}containsPoint(X){const{x:K,y:J}=X,Q=this.geometry.getBuffer("aPosition").data,ee=u$h.points,te=this.geometry.getIndex().data,re=te.length,ne=this.geometry.topology==="triangle-strip"?3:1;for(let ie=0;ie+2<re;ie+=ne){const se=te[ie]*2,oe=te[ie+1]*2,ae=te[ie+2]*2;if(ee[0]=Q[se],ee[1]=Q[se+1],ee[2]=Q[oe],ee[3]=Q[oe+1],ee[4]=Q[ae],ee[5]=Q[ae+1],u$h.contains(K,J))return!0}return!1}onUpdate(){this.owner.onViewUpdate()}destroy(X=!1){var K;if(typeof X=="boolean"?X:X!=null&&X.texture){const J=typeof X=="boolean"?X:X==null?void 0:X.textureSource;this._texture.destroy(J)}(K=this._geometry)==null||K.off("update",this.onUpdate,this),this._texture=null,this._geometry=null,this._shader=null}}var b$c=Object.defineProperty,p$k=Object.getOwnPropertySymbols,F$1=Object.prototype.hasOwnProperty,g$c=Object.prototype.propertyIsEnumerable,l$f=(Z,X,K)=>X in Z?b$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$n=(Z,X)=>{for(var K in X||(X={}))F$1.call(X,K)&&l$f(Z,K,X[K]);if(p$k)for(var K of p$k(X))g$c.call(X,K)&&l$f(Z,K,X[K]);return Z};const f$i=class extends Geometry{constructor(...Z){var X;let K=(X=Z[0])!=null?X:{};K instanceof Float32Array&&(deprecation(v8_0_0,"use new MeshGeometry({ positions, uvs, indices }) instead"),K={positions:K,uvs:Z[1],indices:Z[2]}),K=a$n(a$n({},f$i.defaultOptions),K);const J=K.positions||new Float32Array([0,0,1,0,1,1,0,1]),Q=K.uvs||new Float32Array([0,0,1,0,1,1,0,1]),ee=K.indices||new Uint32Array([0,1,2,0,2,3]),te=K.shrinkBuffersToFit,re=new Buffer({data:J,label:"attribute-mesh-positions",shrinkToFit:te,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ne=new Buffer({data:Q,label:"attribute-mesh-uvs",shrinkToFit:te,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ie=new Buffer({data:ee,label:"index-mesh-buffer",shrinkToFit:te,usage:BufferUsage.INDEX|BufferUsage.COPY_DST});super({attributes:{aPosition:{buffer:re,shaderLocation:0,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:ne,shaderLocation:1,format:"float32x2",stride:2*4,offset:0}},indexBuffer:ie,topology:K.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(Z){this.attributes.aPosition.buffer.data=Z}get uvs(){return this.attributes.aUV.buffer.data}set uvs(Z){this.attributes.aUV.buffer.data=Z}get indices(){return this.indexBuffer.data}set indices(Z){this.indexBuffer.data=Z}};let MeshGeometry=f$i;MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};class QuadGeometry extends MeshGeometry{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}var t$6=Object.defineProperty,u$g=Object.defineProperties,m$d=Object.getOwnPropertyDescriptors,e$1=Object.getOwnPropertySymbols,f$h=Object.prototype.hasOwnProperty,s$l=Object.prototype.propertyIsEnumerable,a$m=(Z,X,K)=>X in Z?t$6(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$j=(Z,X)=>{for(var K in X||(X={}))f$h.call(X,K)&&a$m(Z,K,X[K]);if(e$1)for(var K of e$1(X))s$l.call(X,K)&&a$m(Z,K,X[K]);return Z},l$e=(Z,X)=>u$g(Z,m$d(X));const localUniformBit={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}},localUniformBitGroup2=l$e(n$j({},localUniformBit),{vertex:l$e(n$j({},localUniformBit.vertex),{header:localUniformBit.vertex.header.replace("group(1)","group(2)")})}),localUniformBitGl={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}},tilingBit={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},tilingBitGl={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0
    
        `}};let r$3,t$5;class TilingSpriteShader extends Shader{constructor(X){r$3!=null||(r$3=compileHighShaderGpuProgram({name:"tiling-sprite-shader",bits:[localUniformBit,tilingBit,roundPixelsBit]})),t$5!=null||(t$5=compileHighShaderGlProgram({name:"tiling-sprite-shader",bits:[localUniformBitGl,tilingBitGl,roundPixelsBitGl]}));const K=new UniformGroup({uMapCoord:{value:new Matrix,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,200,.5,.5]),type:"vec4<f32>"}});super({glProgram:t$5,gpuProgram:r$3,resources:{tilingUniforms:K,uTexture:X.texture.source,uSampler:X.texture.source.style}})}get texture(){return this._texture}set texture(X){this._texture!==X&&(this._texture=X,this.resources.uTexture=X.source,this.resources.uSampler=X.source.style)}}const T$6=new QuadGeometry;class TilingSpritePipe{constructor(X){this._renderableHash=Object.create(null),this._renderer=X}validateRenderable(X){const K=X.view.texture.textureMatrix;let J=!1;const Q=this._getRenderableData(X);return Q.batched!==K.isSimple&&(Q.batched=K.isSimple,J=!0),J}addRenderable(X,K){X.view._didUpdate&&(X.view._didUpdate=!1,this._rebuild(X));const{batched:J}=this._getRenderableData(X);if(J){const Q=this._getBatchedTilingSprite(X);this._renderer.renderPipes.mesh.addRenderable(Q,K)}else{const Q=this._getGpuTilingSprite(X);this._renderer.renderPipes.mesh.addRenderable(Q.meshRenderable,K)}}updateRenderable(X){X.view._didUpdate&&(X.view._didUpdate=!1,this._rebuild(X));const{batched:K}=this._getRenderableData(X);if(K){const J=this._getBatchedTilingSprite(X);this._renderer.renderPipes.mesh.updateRenderable(J)}else{const J=this._getGpuTilingSprite(X);this._renderer.renderPipes.mesh.updateRenderable(J.meshRenderable)}}destroyRenderable(X){var K,J;const Q=this._renderableHash[X.uid];(K=Q.batchedMesh)==null||K.view.destroy(),(J=Q.gpuTilingSprite)==null||J.meshRenderable.view.destroy(),this._renderableHash[X.uid]=null,X.off("destroyed",this.destroyRenderable,this)}_getRenderableData(X){return this._renderableHash[X.uid]||this._initRenderableData(X)}_initRenderableData(X){const K={batched:!0,renderable:X};return this._renderableHash[X.uid]=K,this.validateRenderable(X),X.on("destroyed",()=>{this.destroyRenderable(X)}),K}_rebuild(X){const K=this._getRenderableData(X),J=X.view,Q=J.texture.textureMatrix;if(K.batched){const ee=this._getBatchedTilingSprite(X);ee.view.texture=J.texture;const te=J.texture.source.style;te.addressMode!=="repeat"&&(te.addressMode="repeat",te.update()),this._updateBatchPositions(X),this._updateBatchUvs(X)}else{const ee=this._getGpuTilingSprite(X),{meshRenderable:te}=ee,re=te.view;re.shader.texture=J.texture;const ne=re.shader.resources.tilingUniforms,ie=J.width,se=J.height,oe=J.texture.width,ae=J.texture.height,le=J._tileTransform.matrix,ce=ne.uniforms.uTextureTransform;ce.set(le.a*oe/ie,le.b*oe/se,le.c*ae/ie,le.d*ae/se,le.tx/ie,le.ty/se),ce.invert(),ne.uniforms.uMapCoord=Q.mapCoord,ne.uniforms.uClampFrame=Q.uClampFrame,ne.uniforms.uClampOffset=Q.uClampOffset,ne.uniforms.uTextureTransform=ce,ne.uniforms.uSizeAnchor[0]=ie,ne.uniforms.uSizeAnchor[1]=se,ne.uniforms.uSizeAnchor[2]=X.view.anchor.x,ne.uniforms.uSizeAnchor[3]=X.view.anchor.y,ne.update()}}_getGpuTilingSprite(X){return this._renderableHash[X.uid].gpuTilingSprite||this._initGpuTilingSprite(X)}_initGpuTilingSprite(X){const K=X.view,J=K.texture.source.style;J.addressMode="repeat",J.update();const Q=new MeshView({geometry:T$6,shader:new TilingSpriteShader({texture:K.texture})}),ee=new ProxyRenderable({original:X,view:Q}),te=new Matrix,re={meshRenderable:ee,textureMatrix:te};return this._renderableHash[X.uid].gpuTilingSprite=re,re}_getBatchedTilingSprite(X){return this._renderableHash[X.uid].batchedMesh||this._initBatchedTilingSprite(X)}_initBatchedTilingSprite(X){const K=new MeshView({geometry:new QuadGeometry,texture:X.view.texture});K.roundPixels=this._renderer._roundPixels|X.view.roundPixels;const J=new ProxyRenderable({original:X,view:K});return this._renderableHash[X.uid].batchedMesh=J,J}_updateBatchPositions(X){const K=this._getBatchedTilingSprite(X),J=X.view,Q=K.view.geometry.getBuffer("aPosition").data,ee=J.anchor.x,te=J.anchor.y;Q[0]=-ee*J.width,Q[1]=-te*J.height,Q[2]=(1-ee)*J.width,Q[3]=-te*J.height,Q[4]=(1-ee)*J.width,Q[5]=(1-te)*J.height,Q[6]=-ee*J.width,Q[7]=(1-te)*J.height}_updateBatchUvs(X){const K=X.view,J=K.texture.frame.width,Q=K.texture.frame.height,ee=this._getBatchedTilingSprite(X).view.geometry.getBuffer("aUV").data;let te=0,re=0;K._applyAnchorToTexture&&(te=K.anchor.x,re=K.anchor.y),ee[0]=ee[6]=-te,ee[2]=ee[4]=1-te,ee[1]=ee[3]=-re,ee[5]=ee[7]=1-re;const ne=Matrix.shared;ne.copyFrom(K._tileTransform.matrix),ne.tx/=K.width,ne.ty/=K.height,ne.invert(),ne.scale(K.width/J,K.height/Q),S$3(ee,2,0,ne)}destroy(){for(const X in this._renderableHash)this.destroyRenderable(this._renderableHash[X].renderable);this._renderableHash=null,this._renderer=null}}TilingSpritePipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"tilingSprite"};function S$3(Z,X,K,J){let Q=0;const ee=Z.length/(X||2),te=J.a,re=J.b,ne=J.c,ie=J.d,se=J.tx,oe=J.ty;for(K*=X;Q<ee;){const ae=Z[K],le=Z[K+1];Z[K]=te*ae+ne*le+se,Z[K+1]=re*ae+ie*le+oe,K+=X,Q++}}b$r.add(TilingSpritePipe);class FilterPipe{constructor(X){this._renderer=X}push(X,K,J){this._renderer.renderPipes.batch.break(J),J.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:K,filterEffect:X})}pop(X,K,J){this._renderer.renderPipes.batch.break(J),J.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(X){X.action==="pushFilter"?this._renderer.filter.push(X):X.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"filter"};function getGlobalRenderableBounds(Z,X){X.clear();const K=X.matrix;for(let J=0;J<Z.length;J++){const Q=Z[J];Q.rgVisibleRenderable<3||(X.matrix=Q.worldTransform,Q.view.addBounds(X))}return X.matrix=K,X}const A$3=new Geometry({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),shaderLocation:0,format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(X){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup({inputSize:{value:new Float32Array(4),type:"vec4<f32>"},inputPixel:{value:new Float32Array(4),type:"vec4<f32>"},inputClamp:{value:new Float32Array(4),type:"vec4<f32>"},outputFrame:{value:new Float32Array(4),type:"vec4<f32>"},globalFrame:{value:new Float32Array(4),type:"vec4<f32>"},outputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup({}),this.renderer=X}push(X){var K,J;const Q=this.renderer,ee=X.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const te=this._filterStack[this._filterStackIndex];this._filterStackIndex++;const re=te.bounds;if(X.renderables?getGlobalRenderableBounds(X.renderables,re):X.filterEffect.filterArea?(re.addRect(X.filterEffect.filterArea),re.applyMatrix(X.container.worldTransform)):getGlobalBounds(X.container,!0,re),ee.length===0){te.skip=!0;return}let ne=Q.renderTarget.rootRenderTarget.colorTexture.source._resolution,ie=0,se=Q.renderTarget.rootRenderTarget.colorTexture.source.antialias,oe=!1,ae=!1;for(let le=0;le<ee.length;le++){const ce=ee[le];if(ne=Math.min(ne,ce.resolution),ie+=ce.padding,ce.antialias!=="inherit"&&(ce.antialias==="on"?se=!0:se=!1),!(ce.compatibleRenderers&Q.type)){ae=!1;break}if(ce.blendRequired&&!((J=(K=Q.backBuffer)==null?void 0:K.useBackBuffer)==null||J)){ae=!1;break}ae=ce.enabled||ae,oe=oe||ce.blendRequired}if(!ae){te.skip=!0;return}if(re.scale(ne).fit(Q.renderTarget.rootViewPort).scale(1/ne).pad(ie).ceil(),!re.isPositive){te.skip=!0;return}te.skip=!1,te.bounds=re,te.blendRequired=oe,te.container=X.container,te.filterEffect=X.filterEffect,te.previousRenderSurface=Q.renderTarget.renderTarget,te.inputTexture=TexturePool.getOptimalTexture(re.width,re.height,ne,se),Q.renderTarget.bind(te.inputTexture,!0),Q.globalUniforms.push({offset:re})}pop(){const X=this.renderer;this._filterStackIndex--;const K=this._filterStack[this._filterStackIndex];if(K.skip)return;this._activeFilterData=K;const J=K.inputTexture,Q=K.bounds;let ee=Texture.EMPTY;if(X.renderTarget.finishRenderPass(),K.blendRequired){const re=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null;ee=this.getBackTexture(K.previousRenderSurface,Q,re)}K.backTexture=ee;const te=K.filterEffect.filters;if(this._globalFilterBindGroup.setResource(J.source.style,2),this._globalFilterBindGroup.setResource(ee.source,3),X.globalUniforms.pop(),te.length===1)te[0].apply(this,J,K.previousRenderSurface,!1),TexturePool.returnTexture(J);else{let re=K.inputTexture,ne=TexturePool.getOptimalTexture(Q.width,Q.height,re.source._resolution,!1),ie=0;for(ie=0;ie<te.length-1;++ie){te[ie].apply(this,re,ne,!0);const se=re;re=ne,ne=se}te[ie].apply(this,re,K.previousRenderSurface,!1),TexturePool.returnTexture(re),TexturePool.returnTexture(ne)}K.blendRequired&&TexturePool.returnTexture(ee)}getBackTexture(X,K,J){const Q=X.colorTexture.source._resolution,ee=TexturePool.getOptimalTexture(K.width,K.height,Q,!1);let te=K.minX,re=K.minY;J&&(te-=J.minX,re-=J.minY),te=Math.floor(te*Q),re=Math.floor(re*Q);const ne=Math.ceil(K.width*Q),ie=Math.ceil(K.height*Q);return this.renderer.renderTarget.copyToTexture(X,ee,{x:te,y:re},{width:ne,height:ie}),ee}applyFilter(X,K,J,Q){const ee=this.renderer,te=this._filterStack[this._filterStackIndex],re=te.bounds,ne=Point.shared,ie=te.previousRenderSurface===this.renderer.renderTarget.getRenderTarget(J);let se=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,oe=this._filterStackIndex-1;for(;oe>0&&this._filterStack[oe].skip;)--oe;oe>0&&(se=this._filterStack[oe].inputTexture.source._resolution);const ae=this._filterGlobalUniforms,le=ae.uniforms,ce=le.outputFrame,de=le.inputSize,he=le.inputPixel,pe=le.inputClamp,fe=le.globalFrame,ge=le.outputTexture;ie?(this._filterStackIndex>0&&(ne.x=this._filterStack[this._filterStackIndex-1].bounds.minX,ne.y=this._filterStack[this._filterStackIndex-1].bounds.minY),ce[0]=re.minX-ne.x,ce[1]=re.minY-ne.y):(ce[0]=0,ce[1]=0),ce[2]=K.frame.width,ce[3]=K.frame.height,de[0]=K.source.width,de[1]=K.source.height,de[2]=1/de[0],de[3]=1/de[1],he[0]=K.source.pixelWidth,he[1]=K.source.pixelHeight,he[2]=1/he[0],he[3]=1/he[1],pe[0]=.5*he[2],pe[1]=.5*he[3],pe[2]=K.frame.width*de[2]-.5*he[2],pe[3]=K.frame.height*de[3]-.5*he[3];const me=this.renderer.renderTarget.rootRenderTarget.colorTexture;fe[0]=ne.x*se,fe[1]=ne.y*se,fe[2]=me.source.width*se,fe[3]=me.source.height*se;const ye=this.renderer.renderTarget.getRenderTarget(J);if(ee.renderTarget.bind(J,!!Q),J instanceof Texture?(ge[0]=J.frame.width,ge[1]=J.frame.height):(ge[0]=ye.width,ge[1]=ye.height),ge[2]=ye.isRoot?-1:1,ae.update(),ee.renderPipes.uniformBatch){const _e=ee.renderPipes.uniformBatch.getUniformBufferResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(_e,0)}else this._globalFilterBindGroup.setResource(ae,0);this._globalFilterBindGroup.setResource(K.source,1),this._globalFilterBindGroup.setResource(K.source.style,2),X.groups[0]=this._globalFilterBindGroup,ee.encoder.draw({geometry:A$3,shader:X,state:X._state,topology:"triangle-list"})}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(X,K){const J=this._activeFilterData,Q=X.set(J.inputTexture._source.width,0,0,J.inputTexture._source.height,J.bounds.minX,J.bounds.minY),ee=K.worldTransform.copyTo(Matrix.shared);return ee.invert(),Q.prepend(ee),Q.scale(1/K.texture.frame.width,1/K.texture.frame.height),Q.translate(K.anchor.x,K.anchor.y),Q}}FilterSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem],name:"filter"},b$r.add(FilterSystem),b$r.add(FilterPipe);var browserAll={__proto__:null};function find$1(Z,X,K){if(K===void 0&&(K=Array.prototype),Z&&typeof K.find=="function")return K.find.call(Z,X);for(var J=0;J<Z.length;J++)if(Object.prototype.hasOwnProperty.call(Z,J)){var Q=Z[J];if(X.call(void 0,Q,J,Z))return Q}}function freeze(Z,X){return X===void 0&&(X=Object),X&&typeof X.freeze=="function"?X.freeze(Z):Z}function assign(Z,X){if(Z===null||typeof Z!="object")throw new TypeError("target is not an object");for(var K in X)Object.prototype.hasOwnProperty.call(X,K)&&(Z[K]=X[K]);return Z}var MIME_TYPE=freeze({HTML:"text/html",isHTML:function(Z){return Z===MIME_TYPE.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),NAMESPACE$3=freeze({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(Z){return Z===NAMESPACE$3.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"}),assign_1=assign,find_1=find$1,freeze_1=freeze,MIME_TYPE_1=MIME_TYPE,NAMESPACE_1=NAMESPACE$3,conventions={assign:assign_1,find:find_1,freeze:freeze_1,MIME_TYPE:MIME_TYPE_1,NAMESPACE:NAMESPACE_1},find=conventions.find,NAMESPACE$2=conventions.NAMESPACE;function notEmptyString(Z){return Z!==""}function splitOnASCIIWhitespace(Z){return Z?Z.split(/[\t\n\f\r ]+/).filter(notEmptyString):[]}function orderedSetReducer(Z,X){return Z.hasOwnProperty(X)||(Z[X]=!0),Z}function toOrderedSet(Z){if(!Z)return[];var X=splitOnASCIIWhitespace(Z);return Object.keys(X.reduce(orderedSetReducer,{}))}function arrayIncludes(Z){return function(X){return Z&&Z.indexOf(X)!==-1}}function copy(Z,X){for(var K in Z)Object.prototype.hasOwnProperty.call(Z,K)&&(X[K]=Z[K])}function _extends(Z,X){var K=Z.prototype;if(!(K instanceof X)){let J=function(){};J.prototype=X.prototype,J=new J,copy(K,J),Z.prototype=K=J}K.constructor!=Z&&(typeof Z!="function"&&console.error("unknown Class:"+Z),K.constructor=Z)}var NodeType={},ELEMENT_NODE=NodeType.ELEMENT_NODE=1,ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2,TEXT_NODE=NodeType.TEXT_NODE=3,CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4,ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5,ENTITY_NODE=NodeType.ENTITY_NODE=6,PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7,COMMENT_NODE=NodeType.COMMENT_NODE=8,DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9,DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10,DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11,NOTATION_NODE=NodeType.NOTATION_NODE=12,ExceptionCode={},ExceptionMessage={},INDEX_SIZE_ERR=ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]="Index size error",1),DOMSTRING_SIZE_ERR=ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]="DOMString size error",2),HIERARCHY_REQUEST_ERR=ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]="Hierarchy request error",3),WRONG_DOCUMENT_ERR=ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]="Wrong document",4),INVALID_CHARACTER_ERR=ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]="Invalid character",5),NO_DATA_ALLOWED_ERR=ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]="No data allowed",6),NO_MODIFICATION_ALLOWED_ERR=ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]="No modification allowed",7),NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]="Not found",8),NOT_SUPPORTED_ERR=ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]="Not supported",9),INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]="Attribute in use",10),INVALID_STATE_ERR=ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]="Invalid state",11),SYNTAX_ERR=ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]="Syntax error",12),INVALID_MODIFICATION_ERR=ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]="Invalid modification",13),NAMESPACE_ERR=ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]="Invalid namespace",14),INVALID_ACCESS_ERR=ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]="Invalid access",15);function DOMException(Z,X){if(X instanceof Error)var K=X;else K=this,Error.call(this,ExceptionMessage[Z]),this.message=ExceptionMessage[Z],Error.captureStackTrace&&Error.captureStackTrace(this,DOMException);return K.code=Z,X&&(this.message=this.message+": "+X),K}DOMException.prototype=Error.prototype,copy(ExceptionCode,DOMException);function NodeList(){}NodeList.prototype={length:0,item:function(Z){return Z>=0&&Z<this.length?this[Z]:null},toString:function(Z,X){for(var K=[],J=0;J<this.length;J++)serializeToString(this[J],K,Z,X);return K.join("")},filter:function(Z){return Array.prototype.filter.call(this,Z)},indexOf:function(Z){return Array.prototype.indexOf.call(this,Z)}};function LiveNodeList(Z,X){this._node=Z,this._refresh=X,_updateLiveList(this)}function _updateLiveList(Z){var X=Z._node._inc||Z._node.ownerDocument._inc;if(Z._inc!==X){var K=Z._refresh(Z._node);if(__set__(Z,"length",K.length),!Z.$$length||K.length<Z.$$length)for(var J=K.length;J in Z;J++)Object.prototype.hasOwnProperty.call(Z,J)&&delete Z[J];copy(K,Z),Z._inc=X}}LiveNodeList.prototype.item=function(Z){return _updateLiveList(this),this[Z]||null},_extends(LiveNodeList,NodeList);function NamedNodeMap(){}function _findNodeIndex(Z,X){for(var K=Z.length;K--;)if(Z[K]===X)return K}function _addNamedNode(Z,X,K,J){if(J?X[_findNodeIndex(X,J)]=K:X[X.length++]=K,Z){K.ownerElement=Z;var Q=Z.ownerDocument;Q&&(J&&_onRemoveAttribute(Q,Z,J),_onAddAttribute(Q,Z,K))}}function _removeNamedNode(Z,X,K){var J=_findNodeIndex(X,K);if(J>=0){for(var Q=X.length-1;J<Q;)X[J]=X[++J];if(X.length=Q,Z){var ee=Z.ownerDocument;ee&&(_onRemoveAttribute(ee,Z,K),K.ownerElement=null)}}else throw new DOMException(NOT_FOUND_ERR,new Error(Z.tagName+"@"+K))}NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(Z){for(var X=this.length;X--;){var K=this[X];if(K.nodeName==Z)return K}},setNamedItem:function(Z){var X=Z.ownerElement;if(X&&X!=this._ownerElement)throw new DOMException(INUSE_ATTRIBUTE_ERR);var K=this.getNamedItem(Z.nodeName);return _addNamedNode(this._ownerElement,this,Z,K),K},setNamedItemNS:function(Z){var X=Z.ownerElement,K;if(X&&X!=this._ownerElement)throw new DOMException(INUSE_ATTRIBUTE_ERR);return K=this.getNamedItemNS(Z.namespaceURI,Z.localName),_addNamedNode(this._ownerElement,this,Z,K),K},removeNamedItem:function(Z){var X=this.getNamedItem(Z);return _removeNamedNode(this._ownerElement,this,X),X},removeNamedItemNS:function(Z,X){var K=this.getNamedItemNS(Z,X);return _removeNamedNode(this._ownerElement,this,K),K},getNamedItemNS:function(Z,X){for(var K=this.length;K--;){var J=this[K];if(J.localName==X&&J.namespaceURI==Z)return J}return null}};function DOMImplementation$2(){}DOMImplementation$2.prototype={hasFeature:function(Z,X){return!0},createDocument:function(Z,X,K){var J=new Document;if(J.implementation=this,J.childNodes=new NodeList,J.doctype=K||null,K&&J.appendChild(K),X){var Q=J.createElementNS(Z,X);J.appendChild(Q)}return J},createDocumentType:function(Z,X,K){var J=new DocumentType;return J.name=Z,J.nodeName=Z,J.publicId=X||"",J.systemId=K||"",J}};function Node(){}Node.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(Z,X){return _insertBefore(this,Z,X)},replaceChild:function(Z,X){_insertBefore(this,Z,X,assertPreReplacementValidityInDocument),X&&this.removeChild(X)},removeChild:function(Z){return _removeChild(this,Z)},appendChild:function(Z){return this.insertBefore(Z,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(Z){return cloneNode(this.ownerDocument||this,this,Z)},normalize:function(){for(var Z=this.firstChild;Z;){var X=Z.nextSibling;X&&X.nodeType==TEXT_NODE&&Z.nodeType==TEXT_NODE?(this.removeChild(X),Z.appendData(X.data)):(Z.normalize(),Z=X)}},isSupported:function(Z,X){return this.ownerDocument.implementation.hasFeature(Z,X)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(Z){for(var X=this;X;){var K=X._nsMap;if(K){for(var J in K)if(Object.prototype.hasOwnProperty.call(K,J)&&K[J]===Z)return J}X=X.nodeType==ATTRIBUTE_NODE?X.ownerDocument:X.parentNode}return null},lookupNamespaceURI:function(Z){for(var X=this;X;){var K=X._nsMap;if(K&&Object.prototype.hasOwnProperty.call(K,Z))return K[Z];X=X.nodeType==ATTRIBUTE_NODE?X.ownerDocument:X.parentNode}return null},isDefaultNamespace:function(Z){var X=this.lookupPrefix(Z);return X==null}};function _xmlEncoder(Z){return Z=="<"&&"&lt;"||Z==">"&&"&gt;"||Z=="&"&&"&amp;"||Z=='"'&&"&quot;"||"&#"+Z.charCodeAt()+";"}copy(NodeType,Node),copy(NodeType,Node.prototype);function _visitNode(Z,X){if(X(Z))return!0;if(Z=Z.firstChild)do if(_visitNode(Z,X))return!0;while(Z=Z.nextSibling)}function Document(){this.ownerDocument=this}function _onAddAttribute(Z,X,K){Z&&Z._inc++;var J=K.namespaceURI;J===NAMESPACE$2.XMLNS&&(X._nsMap[K.prefix?K.localName:""]=K.value)}function _onRemoveAttribute(Z,X,K,J){Z&&Z._inc++;var Q=K.namespaceURI;Q===NAMESPACE$2.XMLNS&&delete X._nsMap[K.prefix?K.localName:""]}function _onUpdateChild(Z,X,K){if(Z&&Z._inc){Z._inc++;var J=X.childNodes;if(K)J[J.length++]=K;else{for(var Q=X.firstChild,ee=0;Q;)J[ee++]=Q,Q=Q.nextSibling;J.length=ee,delete J[J.length]}}}function _removeChild(Z,X){var K=X.previousSibling,J=X.nextSibling;return K?K.nextSibling=J:Z.firstChild=J,J?J.previousSibling=K:Z.lastChild=K,X.parentNode=null,X.previousSibling=null,X.nextSibling=null,_onUpdateChild(Z.ownerDocument,Z),X}function hasValidParentNodeType(Z){return Z&&(Z.nodeType===Node.DOCUMENT_NODE||Z.nodeType===Node.DOCUMENT_FRAGMENT_NODE||Z.nodeType===Node.ELEMENT_NODE)}function hasInsertableNodeType(Z){return Z&&(isElementNode(Z)||isTextNode(Z)||isDocTypeNode(Z)||Z.nodeType===Node.DOCUMENT_FRAGMENT_NODE||Z.nodeType===Node.COMMENT_NODE||Z.nodeType===Node.PROCESSING_INSTRUCTION_NODE)}function isDocTypeNode(Z){return Z&&Z.nodeType===Node.DOCUMENT_TYPE_NODE}function isElementNode(Z){return Z&&Z.nodeType===Node.ELEMENT_NODE}function isTextNode(Z){return Z&&Z.nodeType===Node.TEXT_NODE}function isElementInsertionPossible(Z,X){var K=Z.childNodes||[];if(find(K,isElementNode)||isDocTypeNode(X))return!1;var J=find(K,isDocTypeNode);return!(X&&J&&K.indexOf(J)>K.indexOf(X))}function isElementReplacementPossible(Z,X){var K=Z.childNodes||[];function J(ee){return isElementNode(ee)&&ee!==X}if(find(K,J))return!1;var Q=find(K,isDocTypeNode);return!(X&&Q&&K.indexOf(Q)>K.indexOf(X))}function assertPreInsertionValidity1to5(Z,X,K){if(!hasValidParentNodeType(Z))throw new DOMException(HIERARCHY_REQUEST_ERR,"Unexpected parent node type "+Z.nodeType);if(K&&K.parentNode!==Z)throw new DOMException(NOT_FOUND_ERR,"child not in parent");if(!hasInsertableNodeType(X)||isDocTypeNode(X)&&Z.nodeType!==Node.DOCUMENT_NODE)throw new DOMException(HIERARCHY_REQUEST_ERR,"Unexpected node type "+X.nodeType+" for parent node type "+Z.nodeType)}function assertPreInsertionValidityInDocument(Z,X,K){var J=Z.childNodes||[],Q=X.childNodes||[];if(X.nodeType===Node.DOCUMENT_FRAGMENT_NODE){var ee=Q.filter(isElementNode);if(ee.length>1||find(Q,isTextNode))throw new DOMException(HIERARCHY_REQUEST_ERR,"More than one element or text in fragment");if(ee.length===1&&!isElementInsertionPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Element in fragment can not be inserted before doctype")}if(isElementNode(X)&&!isElementInsertionPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one element can be added and only after doctype");if(isDocTypeNode(X)){if(find(J,isDocTypeNode))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one doctype is allowed");var te=find(J,isElementNode);if(K&&J.indexOf(te)<J.indexOf(K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Doctype can only be inserted before an element");if(!K&&te)throw new DOMException(HIERARCHY_REQUEST_ERR,"Doctype can not be appended since element is present")}}function assertPreReplacementValidityInDocument(Z,X,K){var J=Z.childNodes||[],Q=X.childNodes||[];if(X.nodeType===Node.DOCUMENT_FRAGMENT_NODE){var ee=Q.filter(isElementNode);if(ee.length>1||find(Q,isTextNode))throw new DOMException(HIERARCHY_REQUEST_ERR,"More than one element or text in fragment");if(ee.length===1&&!isElementReplacementPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Element in fragment can not be inserted before doctype")}if(isElementNode(X)&&!isElementReplacementPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one element can be added and only after doctype");if(isDocTypeNode(X)){if(find(J,function(ne){return isDocTypeNode(ne)&&ne!==K}))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one doctype is allowed");var te=find(J,isElementNode);if(K&&J.indexOf(te)<J.indexOf(K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Doctype can only be inserted before an element")}}function _insertBefore(Z,X,K,J){assertPreInsertionValidity1to5(Z,X,K),Z.nodeType===Node.DOCUMENT_NODE&&(J||assertPreInsertionValidityInDocument)(Z,X,K);var Q=X.parentNode;if(Q&&Q.removeChild(X),X.nodeType===DOCUMENT_FRAGMENT_NODE){var ee=X.firstChild;if(ee==null)return X;var te=X.lastChild}else ee=te=X;var re=K?K.previousSibling:Z.lastChild;ee.previousSibling=re,te.nextSibling=K,re?re.nextSibling=ee:Z.firstChild=ee,K==null?Z.lastChild=te:K.previousSibling=te;do ee.parentNode=Z;while(ee!==te&&(ee=ee.nextSibling));return _onUpdateChild(Z.ownerDocument||Z,Z),X.nodeType==DOCUMENT_FRAGMENT_NODE&&(X.firstChild=X.lastChild=null),X}function _appendSingleChild(Z,X){return X.parentNode&&X.parentNode.removeChild(X),X.parentNode=Z,X.previousSibling=Z.lastChild,X.nextSibling=null,X.previousSibling?X.previousSibling.nextSibling=X:Z.firstChild=X,Z.lastChild=X,_onUpdateChild(Z.ownerDocument,Z,X),X}Document.prototype={nodeName:"#document",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(Z,X){if(Z.nodeType==DOCUMENT_FRAGMENT_NODE){for(var K=Z.firstChild;K;){var J=K.nextSibling;this.insertBefore(K,X),K=J}return Z}return _insertBefore(this,Z,X),Z.ownerDocument=this,this.documentElement===null&&Z.nodeType===ELEMENT_NODE&&(this.documentElement=Z),Z},removeChild:function(Z){return this.documentElement==Z&&(this.documentElement=null),_removeChild(this,Z)},replaceChild:function(Z,X){_insertBefore(this,Z,X,assertPreReplacementValidityInDocument),Z.ownerDocument=this,X&&this.removeChild(X),isElementNode(Z)&&(this.documentElement=Z)},importNode:function(Z,X){return importNode(this,Z,X)},getElementById:function(Z){var X=null;return _visitNode(this.documentElement,function(K){if(K.nodeType==ELEMENT_NODE&&K.getAttribute("id")==Z)return X=K,!0}),X},getElementsByClassName:function(Z){var X=toOrderedSet(Z);return new LiveNodeList(this,function(K){var J=[];return X.length>0&&_visitNode(K.documentElement,function(Q){if(Q!==K&&Q.nodeType===ELEMENT_NODE){var ee=Q.getAttribute("class");if(ee){var te=Z===ee;if(!te){var re=toOrderedSet(ee);te=X.every(arrayIncludes(re))}te&&J.push(Q)}}}),J})},createElement:function(Z){var X=new Element;X.ownerDocument=this,X.nodeName=Z,X.tagName=Z,X.localName=Z,X.childNodes=new NodeList;var K=X.attributes=new NamedNodeMap;return K._ownerElement=X,X},createDocumentFragment:function(){var Z=new DocumentFragment;return Z.ownerDocument=this,Z.childNodes=new NodeList,Z},createTextNode:function(Z){var X=new Text$1;return X.ownerDocument=this,X.appendData(Z),X},createComment:function(Z){var X=new Comment;return X.ownerDocument=this,X.appendData(Z),X},createCDATASection:function(Z){var X=new CDATASection;return X.ownerDocument=this,X.appendData(Z),X},createProcessingInstruction:function(Z,X){var K=new ProcessingInstruction;return K.ownerDocument=this,K.tagName=K.nodeName=K.target=Z,K.nodeValue=K.data=X,K},createAttribute:function(Z){var X=new Attr;return X.ownerDocument=this,X.name=Z,X.nodeName=Z,X.localName=Z,X.specified=!0,X},createEntityReference:function(Z){var X=new EntityReference;return X.ownerDocument=this,X.nodeName=Z,X},createElementNS:function(Z,X){var K=new Element,J=X.split(":"),Q=K.attributes=new NamedNodeMap;return K.childNodes=new NodeList,K.ownerDocument=this,K.nodeName=X,K.tagName=X,K.namespaceURI=Z,J.length==2?(K.prefix=J[0],K.localName=J[1]):K.localName=X,Q._ownerElement=K,K},createAttributeNS:function(Z,X){var K=new Attr,J=X.split(":");return K.ownerDocument=this,K.nodeName=X,K.name=X,K.namespaceURI=Z,K.specified=!0,J.length==2?(K.prefix=J[0],K.localName=J[1]):K.localName=X,K}},_extends(Document,Node);function Element(){this._nsMap={}}Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(Z){return this.getAttributeNode(Z)!=null},getAttribute:function(Z){var X=this.getAttributeNode(Z);return X&&X.value||""},getAttributeNode:function(Z){return this.attributes.getNamedItem(Z)},setAttribute:function(Z,X){var K=this.ownerDocument.createAttribute(Z);K.value=K.nodeValue=""+X,this.setAttributeNode(K)},removeAttribute:function(Z){var X=this.getAttributeNode(Z);X&&this.removeAttributeNode(X)},appendChild:function(Z){return Z.nodeType===DOCUMENT_FRAGMENT_NODE?this.insertBefore(Z,null):_appendSingleChild(this,Z)},setAttributeNode:function(Z){return this.attributes.setNamedItem(Z)},setAttributeNodeNS:function(Z){return this.attributes.setNamedItemNS(Z)},removeAttributeNode:function(Z){return this.attributes.removeNamedItem(Z.nodeName)},removeAttributeNS:function(Z,X){var K=this.getAttributeNodeNS(Z,X);K&&this.removeAttributeNode(K)},hasAttributeNS:function(Z,X){return this.getAttributeNodeNS(Z,X)!=null},getAttributeNS:function(Z,X){var K=this.getAttributeNodeNS(Z,X);return K&&K.value||""},setAttributeNS:function(Z,X,K){var J=this.ownerDocument.createAttributeNS(Z,X);J.value=J.nodeValue=""+K,this.setAttributeNode(J)},getAttributeNodeNS:function(Z,X){return this.attributes.getNamedItemNS(Z,X)},getElementsByTagName:function(Z){return new LiveNodeList(this,function(X){var K=[];return _visitNode(X,function(J){J!==X&&J.nodeType==ELEMENT_NODE&&(Z==="*"||J.tagName==Z)&&K.push(J)}),K})},getElementsByTagNameNS:function(Z,X){return new LiveNodeList(this,function(K){var J=[];return _visitNode(K,function(Q){Q!==K&&Q.nodeType===ELEMENT_NODE&&(Z==="*"||Q.namespaceURI===Z)&&(X==="*"||Q.localName==X)&&J.push(Q)}),J})}},Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName,Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS,_extends(Element,Node);function Attr(){}Attr.prototype.nodeType=ATTRIBUTE_NODE,_extends(Attr,Node);function CharacterData(){}CharacterData.prototype={data:"",substringData:function(Z,X){return this.data.substring(Z,Z+X)},appendData:function(Z){Z=this.data+Z,this.nodeValue=this.data=Z,this.length=Z.length},insertData:function(Z,X){this.replaceData(Z,0,X)},appendChild:function(Z){throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])},deleteData:function(Z,X){this.replaceData(Z,X,"")},replaceData:function(Z,X,K){var J=this.data.substring(0,Z),Q=this.data.substring(Z+X);K=J+K+Q,this.nodeValue=this.data=K,this.length=K.length}},_extends(CharacterData,Node);function Text$1(){}Text$1.prototype={nodeName:"#text",nodeType:TEXT_NODE,splitText:function(Z){var X=this.data,K=X.substring(Z);X=X.substring(0,Z),this.data=this.nodeValue=X,this.length=X.length;var J=this.ownerDocument.createTextNode(K);return this.parentNode&&this.parentNode.insertBefore(J,this.nextSibling),J}},_extends(Text$1,CharacterData);function Comment(){}Comment.prototype={nodeName:"#comment",nodeType:COMMENT_NODE},_extends(Comment,CharacterData);function CDATASection(){}CDATASection.prototype={nodeName:"#cdata-section",nodeType:CDATA_SECTION_NODE},_extends(CDATASection,CharacterData);function DocumentType(){}DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE,_extends(DocumentType,Node);function Notation(){}Notation.prototype.nodeType=NOTATION_NODE,_extends(Notation,Node);function Entity(){}Entity.prototype.nodeType=ENTITY_NODE,_extends(Entity,Node);function EntityReference(){}EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE,_extends(EntityReference,Node);function DocumentFragment(){}DocumentFragment.prototype.nodeName="#document-fragment",DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE,_extends(DocumentFragment,Node);function ProcessingInstruction(){}ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE,_extends(ProcessingInstruction,Node);function XMLSerializer$2(){}XMLSerializer$2.prototype.serializeToString=function(Z,X,K){return nodeSerializeToString.call(Z,X,K)},Node.prototype.toString=nodeSerializeToString;function nodeSerializeToString(Z,X){var K=[],J=this.nodeType==9&&this.documentElement||this,Q=J.prefix,ee=J.namespaceURI;if(ee&&Q==null){var Q=J.lookupPrefix(ee);if(Q==null)var te=[{namespace:ee,prefix:null}]}return serializeToString(this,K,Z,X,te),K.join("")}function needNamespaceDefine(Z,X,K){var J=Z.prefix||"",Q=Z.namespaceURI;if(!Q||J==="xml"&&Q===NAMESPACE$2.XML||Q===NAMESPACE$2.XMLNS)return!1;for(var ee=K.length;ee--;){var te=K[ee];if(te.prefix===J)return te.namespace!==Q}return!0}function addSerializedAttribute(Z,X,K){Z.push(" ",X,'="',K.replace(/[<>&"\t\n\r]/g,_xmlEncoder),'"')}function serializeToString(Z,X,K,J,Q){if(Q||(Q=[]),J)if(Z=J(Z),Z){if(typeof Z=="string"){X.push(Z);return}}else return;switch(Z.nodeType){case ELEMENT_NODE:var ee=Z.attributes,te=ee.length,pe=Z.firstChild,re=Z.tagName;K=NAMESPACE$2.isHTML(Z.namespaceURI)||K;var ne=re;if(!K&&!Z.prefix&&Z.namespaceURI){for(var ie,se=0;se<ee.length;se++)if(ee.item(se).name==="xmlns"){ie=ee.item(se).value;break}if(!ie)for(var oe=Q.length-1;oe>=0;oe--){var ae=Q[oe];if(ae.prefix===""&&ae.namespace===Z.namespaceURI){ie=ae.namespace;break}}if(ie!==Z.namespaceURI)for(var oe=Q.length-1;oe>=0;oe--){var ae=Q[oe];if(ae.namespace===Z.namespaceURI){ae.prefix&&(ne=ae.prefix+":"+re);break}}}X.push("<",ne);for(var le=0;le<te;le++){var ce=ee.item(le);ce.prefix=="xmlns"?Q.push({prefix:ce.localName,namespace:ce.value}):ce.nodeName=="xmlns"&&Q.push({prefix:"",namespace:ce.value})}for(var le=0;le<te;le++){var ce=ee.item(le);if(needNamespaceDefine(ce,K,Q)){var de=ce.prefix||"",he=ce.namespaceURI;addSerializedAttribute(X,de?"xmlns:"+de:"xmlns",he),Q.push({prefix:de,namespace:he})}serializeToString(ce,X,K,J,Q)}if(re===ne&&needNamespaceDefine(Z,K,Q)){var de=Z.prefix||"",he=Z.namespaceURI;addSerializedAttribute(X,de?"xmlns:"+de:"xmlns",he),Q.push({prefix:de,namespace:he})}if(pe||K&&!/^(?:meta|link|img|br|hr|input)$/i.test(re)){if(X.push(">"),K&&/^script$/i.test(re))for(;pe;)pe.data?X.push(pe.data):serializeToString(pe,X,K,J,Q.slice()),pe=pe.nextSibling;else for(;pe;)serializeToString(pe,X,K,J,Q.slice()),pe=pe.nextSibling;X.push("</",ne,">")}else X.push("/>");return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:for(var pe=Z.firstChild;pe;)serializeToString(pe,X,K,J,Q.slice()),pe=pe.nextSibling;return;case ATTRIBUTE_NODE:return addSerializedAttribute(X,Z.name,Z.value);case TEXT_NODE:return X.push(Z.data.replace(/[<&>]/g,_xmlEncoder));case CDATA_SECTION_NODE:return X.push("<![CDATA[",Z.data,"]]>");case COMMENT_NODE:return X.push("<!--",Z.data,"-->");case DOCUMENT_TYPE_NODE:var fe=Z.publicId,ge=Z.systemId;if(X.push("<!DOCTYPE ",Z.name),fe)X.push(" PUBLIC ",fe),ge&&ge!="."&&X.push(" ",ge),X.push(">");else if(ge&&ge!=".")X.push(" SYSTEM ",ge,">");else{var me=Z.internalSubset;me&&X.push(" [",me,"]"),X.push(">")}return;case PROCESSING_INSTRUCTION_NODE:return X.push("<?",Z.target," ",Z.data,"?>");case ENTITY_REFERENCE_NODE:return X.push("&",Z.nodeName,";");default:X.push("??",Z.nodeName)}}function importNode(Z,X,K){var J;switch(X.nodeType){case ELEMENT_NODE:J=X.cloneNode(!1),J.ownerDocument=Z;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:K=!0;break}if(J||(J=X.cloneNode(!1)),J.ownerDocument=Z,J.parentNode=null,K)for(var Q=X.firstChild;Q;)J.appendChild(importNode(Z,Q,K)),Q=Q.nextSibling;return J}function cloneNode(Z,X,K){var J=new X.constructor;for(var Q in X)if(Object.prototype.hasOwnProperty.call(X,Q)){var ee=X[Q];typeof ee!="object"&&ee!=J[Q]&&(J[Q]=ee)}switch(X.childNodes&&(J.childNodes=new NodeList),J.ownerDocument=Z,J.nodeType){case ELEMENT_NODE:var te=X.attributes,re=J.attributes=new NamedNodeMap,ne=te.length;re._ownerElement=J;for(var ie=0;ie<ne;ie++)J.setAttributeNode(cloneNode(Z,te.item(ie),!0));break;case ATTRIBUTE_NODE:K=!0}if(K)for(var se=X.firstChild;se;)J.appendChild(cloneNode(Z,se,K)),se=se.nextSibling;return J}function __set__(Z,X,K){Z[X]=K}try{if(Object.defineProperty){let Z=function(X){switch(X.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var K=[];for(X=X.firstChild;X;)X.nodeType!==7&&X.nodeType!==8&&K.push(Z(X)),X=X.nextSibling;return K.join("");default:return X.nodeValue}};Object.defineProperty(LiveNodeList.prototype,"length",{get:function(){return _updateLiveList(this),this.$$length}}),Object.defineProperty(Node.prototype,"textContent",{get:function(){return Z(this)},set:function(X){switch(this.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:for(;this.firstChild;)this.removeChild(this.firstChild);(X||String(X))&&this.appendChild(this.ownerDocument.createTextNode(X));break;default:this.data=X,this.value=X,this.nodeValue=X}}}),__set__=function(X,K,J){X["$$"+K]=J}}}catch(Z){}var DocumentType_1=DocumentType,DOMException_1=DOMException,DOMImplementation_1=DOMImplementation$2,Element_1=Element,Node_1=Node,NodeList_1=NodeList,XMLSerializer_1=XMLSerializer$2,dom={DocumentType:DocumentType_1,DOMException:DOMException_1,DOMImplementation:DOMImplementation_1,Element:Element_1,Node:Node_1,NodeList:NodeList_1,XMLSerializer:XMLSerializer_1},entities=createCommonjsModule(function(Z,X){"use strict";var K=conventions.freeze;X.XML_ENTITIES=K({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}),X.HTML_ENTITIES=K({Aacute:"\xC1",aacute:"\xE1",Abreve:"\u0102",abreve:"\u0103",ac:"\u223E",acd:"\u223F",acE:"\u223E\u0333",Acirc:"\xC2",acirc:"\xE2",acute:"\xB4",Acy:"\u0410",acy:"\u0430",AElig:"\xC6",aelig:"\xE6",af:"\u2061",Afr:"\u{1D504}",afr:"\u{1D51E}",Agrave:"\xC0",agrave:"\xE0",alefsym:"\u2135",aleph:"\u2135",Alpha:"\u0391",alpha:"\u03B1",Amacr:"\u0100",amacr:"\u0101",amalg:"\u2A3F",AMP:"&",amp:"&",And:"\u2A53",and:"\u2227",andand:"\u2A55",andd:"\u2A5C",andslope:"\u2A58",andv:"\u2A5A",ang:"\u2220",ange:"\u29A4",angle:"\u2220",angmsd:"\u2221",angmsdaa:"\u29A8",angmsdab:"\u29A9",angmsdac:"\u29AA",angmsdad:"\u29AB",angmsdae:"\u29AC",angmsdaf:"\u29AD",angmsdag:"\u29AE",angmsdah:"\u29AF",angrt:"\u221F",angrtvb:"\u22BE",angrtvbd:"\u299D",angsph:"\u2222",angst:"\xC5",angzarr:"\u237C",Aogon:"\u0104",aogon:"\u0105",Aopf:"\u{1D538}",aopf:"\u{1D552}",ap:"\u2248",apacir:"\u2A6F",apE:"\u2A70",ape:"\u224A",apid:"\u224B",apos:"'",ApplyFunction:"\u2061",approx:"\u2248",approxeq:"\u224A",Aring:"\xC5",aring:"\xE5",Ascr:"\u{1D49C}",ascr:"\u{1D4B6}",Assign:"\u2254",ast:"*",asymp:"\u2248",asympeq:"\u224D",Atilde:"\xC3",atilde:"\xE3",Auml:"\xC4",auml:"\xE4",awconint:"\u2233",awint:"\u2A11",backcong:"\u224C",backepsilon:"\u03F6",backprime:"\u2035",backsim:"\u223D",backsimeq:"\u22CD",Backslash:"\u2216",Barv:"\u2AE7",barvee:"\u22BD",Barwed:"\u2306",barwed:"\u2305",barwedge:"\u2305",bbrk:"\u23B5",bbrktbrk:"\u23B6",bcong:"\u224C",Bcy:"\u0411",bcy:"\u0431",bdquo:"\u201E",becaus:"\u2235",Because:"\u2235",because:"\u2235",bemptyv:"\u29B0",bepsi:"\u03F6",bernou:"\u212C",Bernoullis:"\u212C",Beta:"\u0392",beta:"\u03B2",beth:"\u2136",between:"\u226C",Bfr:"\u{1D505}",bfr:"\u{1D51F}",bigcap:"\u22C2",bigcirc:"\u25EF",bigcup:"\u22C3",bigodot:"\u2A00",bigoplus:"\u2A01",bigotimes:"\u2A02",bigsqcup:"\u2A06",bigstar:"\u2605",bigtriangledown:"\u25BD",bigtriangleup:"\u25B3",biguplus:"\u2A04",bigvee:"\u22C1",bigwedge:"\u22C0",bkarow:"\u290D",blacklozenge:"\u29EB",blacksquare:"\u25AA",blacktriangle:"\u25B4",blacktriangledown:"\u25BE",blacktriangleleft:"\u25C2",blacktriangleright:"\u25B8",blank:"\u2423",blk12:"\u2592",blk14:"\u2591",blk34:"\u2593",block:"\u2588",bne:"=\u20E5",bnequiv:"\u2261\u20E5",bNot:"\u2AED",bnot:"\u2310",Bopf:"\u{1D539}",bopf:"\u{1D553}",bot:"\u22A5",bottom:"\u22A5",bowtie:"\u22C8",boxbox:"\u29C9",boxDL:"\u2557",boxDl:"\u2556",boxdL:"\u2555",boxdl:"\u2510",boxDR:"\u2554",boxDr:"\u2553",boxdR:"\u2552",boxdr:"\u250C",boxH:"\u2550",boxh:"\u2500",boxHD:"\u2566",boxHd:"\u2564",boxhD:"\u2565",boxhd:"\u252C",boxHU:"\u2569",boxHu:"\u2567",boxhU:"\u2568",boxhu:"\u2534",boxminus:"\u229F",boxplus:"\u229E",boxtimes:"\u22A0",boxUL:"\u255D",boxUl:"\u255C",boxuL:"\u255B",boxul:"\u2518",boxUR:"\u255A",boxUr:"\u2559",boxuR:"\u2558",boxur:"\u2514",boxV:"\u2551",boxv:"\u2502",boxVH:"\u256C",boxVh:"\u256B",boxvH:"\u256A",boxvh:"\u253C",boxVL:"\u2563",boxVl:"\u2562",boxvL:"\u2561",boxvl:"\u2524",boxVR:"\u2560",boxVr:"\u255F",boxvR:"\u255E",boxvr:"\u251C",bprime:"\u2035",Breve:"\u02D8",breve:"\u02D8",brvbar:"\xA6",Bscr:"\u212C",bscr:"\u{1D4B7}",bsemi:"\u204F",bsim:"\u223D",bsime:"\u22CD",bsol:"\\",bsolb:"\u29C5",bsolhsub:"\u27C8",bull:"\u2022",bullet:"\u2022",bump:"\u224E",bumpE:"\u2AAE",bumpe:"\u224F",Bumpeq:"\u224E",bumpeq:"\u224F",Cacute:"\u0106",cacute:"\u0107",Cap:"\u22D2",cap:"\u2229",capand:"\u2A44",capbrcup:"\u2A49",capcap:"\u2A4B",capcup:"\u2A47",capdot:"\u2A40",CapitalDifferentialD:"\u2145",caps:"\u2229\uFE00",caret:"\u2041",caron:"\u02C7",Cayleys:"\u212D",ccaps:"\u2A4D",Ccaron:"\u010C",ccaron:"\u010D",Ccedil:"\xC7",ccedil:"\xE7",Ccirc:"\u0108",ccirc:"\u0109",Cconint:"\u2230",ccups:"\u2A4C",ccupssm:"\u2A50",Cdot:"\u010A",cdot:"\u010B",cedil:"\xB8",Cedilla:"\xB8",cemptyv:"\u29B2",cent:"\xA2",CenterDot:"\xB7",centerdot:"\xB7",Cfr:"\u212D",cfr:"\u{1D520}",CHcy:"\u0427",chcy:"\u0447",check:"\u2713",checkmark:"\u2713",Chi:"\u03A7",chi:"\u03C7",cir:"\u25CB",circ:"\u02C6",circeq:"\u2257",circlearrowleft:"\u21BA",circlearrowright:"\u21BB",circledast:"\u229B",circledcirc:"\u229A",circleddash:"\u229D",CircleDot:"\u2299",circledR:"\xAE",circledS:"\u24C8",CircleMinus:"\u2296",CirclePlus:"\u2295",CircleTimes:"\u2297",cirE:"\u29C3",cire:"\u2257",cirfnint:"\u2A10",cirmid:"\u2AEF",cirscir:"\u29C2",ClockwiseContourIntegral:"\u2232",CloseCurlyDoubleQuote:"\u201D",CloseCurlyQuote:"\u2019",clubs:"\u2663",clubsuit:"\u2663",Colon:"\u2237",colon:":",Colone:"\u2A74",colone:"\u2254",coloneq:"\u2254",comma:",",commat:"@",comp:"\u2201",compfn:"\u2218",complement:"\u2201",complexes:"\u2102",cong:"\u2245",congdot:"\u2A6D",Congruent:"\u2261",Conint:"\u222F",conint:"\u222E",ContourIntegral:"\u222E",Copf:"\u2102",copf:"\u{1D554}",coprod:"\u2210",Coproduct:"\u2210",COPY:"\xA9",copy:"\xA9",copysr:"\u2117",CounterClockwiseContourIntegral:"\u2233",crarr:"\u21B5",Cross:"\u2A2F",cross:"\u2717",Cscr:"\u{1D49E}",cscr:"\u{1D4B8}",csub:"\u2ACF",csube:"\u2AD1",csup:"\u2AD0",csupe:"\u2AD2",ctdot:"\u22EF",cudarrl:"\u2938",cudarrr:"\u2935",cuepr:"\u22DE",cuesc:"\u22DF",cularr:"\u21B6",cularrp:"\u293D",Cup:"\u22D3",cup:"\u222A",cupbrcap:"\u2A48",CupCap:"\u224D",cupcap:"\u2A46",cupcup:"\u2A4A",cupdot:"\u228D",cupor:"\u2A45",cups:"\u222A\uFE00",curarr:"\u21B7",curarrm:"\u293C",curlyeqprec:"\u22DE",curlyeqsucc:"\u22DF",curlyvee:"\u22CE",curlywedge:"\u22CF",curren:"\xA4",curvearrowleft:"\u21B6",curvearrowright:"\u21B7",cuvee:"\u22CE",cuwed:"\u22CF",cwconint:"\u2232",cwint:"\u2231",cylcty:"\u232D",Dagger:"\u2021",dagger:"\u2020",daleth:"\u2138",Darr:"\u21A1",dArr:"\u21D3",darr:"\u2193",dash:"\u2010",Dashv:"\u2AE4",dashv:"\u22A3",dbkarow:"\u290F",dblac:"\u02DD",Dcaron:"\u010E",dcaron:"\u010F",Dcy:"\u0414",dcy:"\u0434",DD:"\u2145",dd:"\u2146",ddagger:"\u2021",ddarr:"\u21CA",DDotrahd:"\u2911",ddotseq:"\u2A77",deg:"\xB0",Del:"\u2207",Delta:"\u0394",delta:"\u03B4",demptyv:"\u29B1",dfisht:"\u297F",Dfr:"\u{1D507}",dfr:"\u{1D521}",dHar:"\u2965",dharl:"\u21C3",dharr:"\u21C2",DiacriticalAcute:"\xB4",DiacriticalDot:"\u02D9",DiacriticalDoubleAcute:"\u02DD",DiacriticalGrave:"`",DiacriticalTilde:"\u02DC",diam:"\u22C4",Diamond:"\u22C4",diamond:"\u22C4",diamondsuit:"\u2666",diams:"\u2666",die:"\xA8",DifferentialD:"\u2146",digamma:"\u03DD",disin:"\u22F2",div:"\xF7",divide:"\xF7",divideontimes:"\u22C7",divonx:"\u22C7",DJcy:"\u0402",djcy:"\u0452",dlcorn:"\u231E",dlcrop:"\u230D",dollar:"$",Dopf:"\u{1D53B}",dopf:"\u{1D555}",Dot:"\xA8",dot:"\u02D9",DotDot:"\u20DC",doteq:"\u2250",doteqdot:"\u2251",DotEqual:"\u2250",dotminus:"\u2238",dotplus:"\u2214",dotsquare:"\u22A1",doublebarwedge:"\u2306",DoubleContourIntegral:"\u222F",DoubleDot:"\xA8",DoubleDownArrow:"\u21D3",DoubleLeftArrow:"\u21D0",DoubleLeftRightArrow:"\u21D4",DoubleLeftTee:"\u2AE4",DoubleLongLeftArrow:"\u27F8",DoubleLongLeftRightArrow:"\u27FA",DoubleLongRightArrow:"\u27F9",DoubleRightArrow:"\u21D2",DoubleRightTee:"\u22A8",DoubleUpArrow:"\u21D1",DoubleUpDownArrow:"\u21D5",DoubleVerticalBar:"\u2225",DownArrow:"\u2193",Downarrow:"\u21D3",downarrow:"\u2193",DownArrowBar:"\u2913",DownArrowUpArrow:"\u21F5",DownBreve:"\u0311",downdownarrows:"\u21CA",downharpoonleft:"\u21C3",downharpoonright:"\u21C2",DownLeftRightVector:"\u2950",DownLeftTeeVector:"\u295E",DownLeftVector:"\u21BD",DownLeftVectorBar:"\u2956",DownRightTeeVector:"\u295F",DownRightVector:"\u21C1",DownRightVectorBar:"\u2957",DownTee:"\u22A4",DownTeeArrow:"\u21A7",drbkarow:"\u2910",drcorn:"\u231F",drcrop:"\u230C",Dscr:"\u{1D49F}",dscr:"\u{1D4B9}",DScy:"\u0405",dscy:"\u0455",dsol:"\u29F6",Dstrok:"\u0110",dstrok:"\u0111",dtdot:"\u22F1",dtri:"\u25BF",dtrif:"\u25BE",duarr:"\u21F5",duhar:"\u296F",dwangle:"\u29A6",DZcy:"\u040F",dzcy:"\u045F",dzigrarr:"\u27FF",Eacute:"\xC9",eacute:"\xE9",easter:"\u2A6E",Ecaron:"\u011A",ecaron:"\u011B",ecir:"\u2256",Ecirc:"\xCA",ecirc:"\xEA",ecolon:"\u2255",Ecy:"\u042D",ecy:"\u044D",eDDot:"\u2A77",Edot:"\u0116",eDot:"\u2251",edot:"\u0117",ee:"\u2147",efDot:"\u2252",Efr:"\u{1D508}",efr:"\u{1D522}",eg:"\u2A9A",Egrave:"\xC8",egrave:"\xE8",egs:"\u2A96",egsdot:"\u2A98",el:"\u2A99",Element:"\u2208",elinters:"\u23E7",ell:"\u2113",els:"\u2A95",elsdot:"\u2A97",Emacr:"\u0112",emacr:"\u0113",empty:"\u2205",emptyset:"\u2205",EmptySmallSquare:"\u25FB",emptyv:"\u2205",EmptyVerySmallSquare:"\u25AB",emsp:"\u2003",emsp13:"\u2004",emsp14:"\u2005",ENG:"\u014A",eng:"\u014B",ensp:"\u2002",Eogon:"\u0118",eogon:"\u0119",Eopf:"\u{1D53C}",eopf:"\u{1D556}",epar:"\u22D5",eparsl:"\u29E3",eplus:"\u2A71",epsi:"\u03B5",Epsilon:"\u0395",epsilon:"\u03B5",epsiv:"\u03F5",eqcirc:"\u2256",eqcolon:"\u2255",eqsim:"\u2242",eqslantgtr:"\u2A96",eqslantless:"\u2A95",Equal:"\u2A75",equals:"=",EqualTilde:"\u2242",equest:"\u225F",Equilibrium:"\u21CC",equiv:"\u2261",equivDD:"\u2A78",eqvparsl:"\u29E5",erarr:"\u2971",erDot:"\u2253",Escr:"\u2130",escr:"\u212F",esdot:"\u2250",Esim:"\u2A73",esim:"\u2242",Eta:"\u0397",eta:"\u03B7",ETH:"\xD0",eth:"\xF0",Euml:"\xCB",euml:"\xEB",euro:"\u20AC",excl:"!",exist:"\u2203",Exists:"\u2203",expectation:"\u2130",ExponentialE:"\u2147",exponentiale:"\u2147",fallingdotseq:"\u2252",Fcy:"\u0424",fcy:"\u0444",female:"\u2640",ffilig:"\uFB03",fflig:"\uFB00",ffllig:"\uFB04",Ffr:"\u{1D509}",ffr:"\u{1D523}",filig:"\uFB01",FilledSmallSquare:"\u25FC",FilledVerySmallSquare:"\u25AA",fjlig:"fj",flat:"\u266D",fllig:"\uFB02",fltns:"\u25B1",fnof:"\u0192",Fopf:"\u{1D53D}",fopf:"\u{1D557}",ForAll:"\u2200",forall:"\u2200",fork:"\u22D4",forkv:"\u2AD9",Fouriertrf:"\u2131",fpartint:"\u2A0D",frac12:"\xBD",frac13:"\u2153",frac14:"\xBC",frac15:"\u2155",frac16:"\u2159",frac18:"\u215B",frac23:"\u2154",frac25:"\u2156",frac34:"\xBE",frac35:"\u2157",frac38:"\u215C",frac45:"\u2158",frac56:"\u215A",frac58:"\u215D",frac78:"\u215E",frasl:"\u2044",frown:"\u2322",Fscr:"\u2131",fscr:"\u{1D4BB}",gacute:"\u01F5",Gamma:"\u0393",gamma:"\u03B3",Gammad:"\u03DC",gammad:"\u03DD",gap:"\u2A86",Gbreve:"\u011E",gbreve:"\u011F",Gcedil:"\u0122",Gcirc:"\u011C",gcirc:"\u011D",Gcy:"\u0413",gcy:"\u0433",Gdot:"\u0120",gdot:"\u0121",gE:"\u2267",ge:"\u2265",gEl:"\u2A8C",gel:"\u22DB",geq:"\u2265",geqq:"\u2267",geqslant:"\u2A7E",ges:"\u2A7E",gescc:"\u2AA9",gesdot:"\u2A80",gesdoto:"\u2A82",gesdotol:"\u2A84",gesl:"\u22DB\uFE00",gesles:"\u2A94",Gfr:"\u{1D50A}",gfr:"\u{1D524}",Gg:"\u22D9",gg:"\u226B",ggg:"\u22D9",gimel:"\u2137",GJcy:"\u0403",gjcy:"\u0453",gl:"\u2277",gla:"\u2AA5",glE:"\u2A92",glj:"\u2AA4",gnap:"\u2A8A",gnapprox:"\u2A8A",gnE:"\u2269",gne:"\u2A88",gneq:"\u2A88",gneqq:"\u2269",gnsim:"\u22E7",Gopf:"\u{1D53E}",gopf:"\u{1D558}",grave:"`",GreaterEqual:"\u2265",GreaterEqualLess:"\u22DB",GreaterFullEqual:"\u2267",GreaterGreater:"\u2AA2",GreaterLess:"\u2277",GreaterSlantEqual:"\u2A7E",GreaterTilde:"\u2273",Gscr:"\u{1D4A2}",gscr:"\u210A",gsim:"\u2273",gsime:"\u2A8E",gsiml:"\u2A90",Gt:"\u226B",GT:">",gt:">",gtcc:"\u2AA7",gtcir:"\u2A7A",gtdot:"\u22D7",gtlPar:"\u2995",gtquest:"\u2A7C",gtrapprox:"\u2A86",gtrarr:"\u2978",gtrdot:"\u22D7",gtreqless:"\u22DB",gtreqqless:"\u2A8C",gtrless:"\u2277",gtrsim:"\u2273",gvertneqq:"\u2269\uFE00",gvnE:"\u2269\uFE00",Hacek:"\u02C7",hairsp:"\u200A",half:"\xBD",hamilt:"\u210B",HARDcy:"\u042A",hardcy:"\u044A",hArr:"\u21D4",harr:"\u2194",harrcir:"\u2948",harrw:"\u21AD",Hat:"^",hbar:"\u210F",Hcirc:"\u0124",hcirc:"\u0125",hearts:"\u2665",heartsuit:"\u2665",hellip:"\u2026",hercon:"\u22B9",Hfr:"\u210C",hfr:"\u{1D525}",HilbertSpace:"\u210B",hksearow:"\u2925",hkswarow:"\u2926",hoarr:"\u21FF",homtht:"\u223B",hookleftarrow:"\u21A9",hookrightarrow:"\u21AA",Hopf:"\u210D",hopf:"\u{1D559}",horbar:"\u2015",HorizontalLine:"\u2500",Hscr:"\u210B",hscr:"\u{1D4BD}",hslash:"\u210F",Hstrok:"\u0126",hstrok:"\u0127",HumpDownHump:"\u224E",HumpEqual:"\u224F",hybull:"\u2043",hyphen:"\u2010",Iacute:"\xCD",iacute:"\xED",ic:"\u2063",Icirc:"\xCE",icirc:"\xEE",Icy:"\u0418",icy:"\u0438",Idot:"\u0130",IEcy:"\u0415",iecy:"\u0435",iexcl:"\xA1",iff:"\u21D4",Ifr:"\u2111",ifr:"\u{1D526}",Igrave:"\xCC",igrave:"\xEC",ii:"\u2148",iiiint:"\u2A0C",iiint:"\u222D",iinfin:"\u29DC",iiota:"\u2129",IJlig:"\u0132",ijlig:"\u0133",Im:"\u2111",Imacr:"\u012A",imacr:"\u012B",image:"\u2111",ImaginaryI:"\u2148",imagline:"\u2110",imagpart:"\u2111",imath:"\u0131",imof:"\u22B7",imped:"\u01B5",Implies:"\u21D2",in:"\u2208",incare:"\u2105",infin:"\u221E",infintie:"\u29DD",inodot:"\u0131",Int:"\u222C",int:"\u222B",intcal:"\u22BA",integers:"\u2124",Integral:"\u222B",intercal:"\u22BA",Intersection:"\u22C2",intlarhk:"\u2A17",intprod:"\u2A3C",InvisibleComma:"\u2063",InvisibleTimes:"\u2062",IOcy:"\u0401",iocy:"\u0451",Iogon:"\u012E",iogon:"\u012F",Iopf:"\u{1D540}",iopf:"\u{1D55A}",Iota:"\u0399",iota:"\u03B9",iprod:"\u2A3C",iquest:"\xBF",Iscr:"\u2110",iscr:"\u{1D4BE}",isin:"\u2208",isindot:"\u22F5",isinE:"\u22F9",isins:"\u22F4",isinsv:"\u22F3",isinv:"\u2208",it:"\u2062",Itilde:"\u0128",itilde:"\u0129",Iukcy:"\u0406",iukcy:"\u0456",Iuml:"\xCF",iuml:"\xEF",Jcirc:"\u0134",jcirc:"\u0135",Jcy:"\u0419",jcy:"\u0439",Jfr:"\u{1D50D}",jfr:"\u{1D527}",jmath:"\u0237",Jopf:"\u{1D541}",jopf:"\u{1D55B}",Jscr:"\u{1D4A5}",jscr:"\u{1D4BF}",Jsercy:"\u0408",jsercy:"\u0458",Jukcy:"\u0404",jukcy:"\u0454",Kappa:"\u039A",kappa:"\u03BA",kappav:"\u03F0",Kcedil:"\u0136",kcedil:"\u0137",Kcy:"\u041A",kcy:"\u043A",Kfr:"\u{1D50E}",kfr:"\u{1D528}",kgreen:"\u0138",KHcy:"\u0425",khcy:"\u0445",KJcy:"\u040C",kjcy:"\u045C",Kopf:"\u{1D542}",kopf:"\u{1D55C}",Kscr:"\u{1D4A6}",kscr:"\u{1D4C0}",lAarr:"\u21DA",Lacute:"\u0139",lacute:"\u013A",laemptyv:"\u29B4",lagran:"\u2112",Lambda:"\u039B",lambda:"\u03BB",Lang:"\u27EA",lang:"\u27E8",langd:"\u2991",langle:"\u27E8",lap:"\u2A85",Laplacetrf:"\u2112",laquo:"\xAB",Larr:"\u219E",lArr:"\u21D0",larr:"\u2190",larrb:"\u21E4",larrbfs:"\u291F",larrfs:"\u291D",larrhk:"\u21A9",larrlp:"\u21AB",larrpl:"\u2939",larrsim:"\u2973",larrtl:"\u21A2",lat:"\u2AAB",lAtail:"\u291B",latail:"\u2919",late:"\u2AAD",lates:"\u2AAD\uFE00",lBarr:"\u290E",lbarr:"\u290C",lbbrk:"\u2772",lbrace:"{",lbrack:"[",lbrke:"\u298B",lbrksld:"\u298F",lbrkslu:"\u298D",Lcaron:"\u013D",lcaron:"\u013E",Lcedil:"\u013B",lcedil:"\u013C",lceil:"\u2308",lcub:"{",Lcy:"\u041B",lcy:"\u043B",ldca:"\u2936",ldquo:"\u201C",ldquor:"\u201E",ldrdhar:"\u2967",ldrushar:"\u294B",ldsh:"\u21B2",lE:"\u2266",le:"\u2264",LeftAngleBracket:"\u27E8",LeftArrow:"\u2190",Leftarrow:"\u21D0",leftarrow:"\u2190",LeftArrowBar:"\u21E4",LeftArrowRightArrow:"\u21C6",leftarrowtail:"\u21A2",LeftCeiling:"\u2308",LeftDoubleBracket:"\u27E6",LeftDownTeeVector:"\u2961",LeftDownVector:"\u21C3",LeftDownVectorBar:"\u2959",LeftFloor:"\u230A",leftharpoondown:"\u21BD",leftharpoonup:"\u21BC",leftleftarrows:"\u21C7",LeftRightArrow:"\u2194",Leftrightarrow:"\u21D4",leftrightarrow:"\u2194",leftrightarrows:"\u21C6",leftrightharpoons:"\u21CB",leftrightsquigarrow:"\u21AD",LeftRightVector:"\u294E",LeftTee:"\u22A3",LeftTeeArrow:"\u21A4",LeftTeeVector:"\u295A",leftthreetimes:"\u22CB",LeftTriangle:"\u22B2",LeftTriangleBar:"\u29CF",LeftTriangleEqual:"\u22B4",LeftUpDownVector:"\u2951",LeftUpTeeVector:"\u2960",LeftUpVector:"\u21BF",LeftUpVectorBar:"\u2958",LeftVector:"\u21BC",LeftVectorBar:"\u2952",lEg:"\u2A8B",leg:"\u22DA",leq:"\u2264",leqq:"\u2266",leqslant:"\u2A7D",les:"\u2A7D",lescc:"\u2AA8",lesdot:"\u2A7F",lesdoto:"\u2A81",lesdotor:"\u2A83",lesg:"\u22DA\uFE00",lesges:"\u2A93",lessapprox:"\u2A85",lessdot:"\u22D6",lesseqgtr:"\u22DA",lesseqqgtr:"\u2A8B",LessEqualGreater:"\u22DA",LessFullEqual:"\u2266",LessGreater:"\u2276",lessgtr:"\u2276",LessLess:"\u2AA1",lesssim:"\u2272",LessSlantEqual:"\u2A7D",LessTilde:"\u2272",lfisht:"\u297C",lfloor:"\u230A",Lfr:"\u{1D50F}",lfr:"\u{1D529}",lg:"\u2276",lgE:"\u2A91",lHar:"\u2962",lhard:"\u21BD",lharu:"\u21BC",lharul:"\u296A",lhblk:"\u2584",LJcy:"\u0409",ljcy:"\u0459",Ll:"\u22D8",ll:"\u226A",llarr:"\u21C7",llcorner:"\u231E",Lleftarrow:"\u21DA",llhard:"\u296B",lltri:"\u25FA",Lmidot:"\u013F",lmidot:"\u0140",lmoust:"\u23B0",lmoustache:"\u23B0",lnap:"\u2A89",lnapprox:"\u2A89",lnE:"\u2268",lne:"\u2A87",lneq:"\u2A87",lneqq:"\u2268",lnsim:"\u22E6",loang:"\u27EC",loarr:"\u21FD",lobrk:"\u27E6",LongLeftArrow:"\u27F5",Longleftarrow:"\u27F8",longleftarrow:"\u27F5",LongLeftRightArrow:"\u27F7",Longleftrightarrow:"\u27FA",longleftrightarrow:"\u27F7",longmapsto:"\u27FC",LongRightArrow:"\u27F6",Longrightarrow:"\u27F9",longrightarrow:"\u27F6",looparrowleft:"\u21AB",looparrowright:"\u21AC",lopar:"\u2985",Lopf:"\u{1D543}",lopf:"\u{1D55D}",loplus:"\u2A2D",lotimes:"\u2A34",lowast:"\u2217",lowbar:"_",LowerLeftArrow:"\u2199",LowerRightArrow:"\u2198",loz:"\u25CA",lozenge:"\u25CA",lozf:"\u29EB",lpar:"(",lparlt:"\u2993",lrarr:"\u21C6",lrcorner:"\u231F",lrhar:"\u21CB",lrhard:"\u296D",lrm:"\u200E",lrtri:"\u22BF",lsaquo:"\u2039",Lscr:"\u2112",lscr:"\u{1D4C1}",Lsh:"\u21B0",lsh:"\u21B0",lsim:"\u2272",lsime:"\u2A8D",lsimg:"\u2A8F",lsqb:"[",lsquo:"\u2018",lsquor:"\u201A",Lstrok:"\u0141",lstrok:"\u0142",Lt:"\u226A",LT:"<",lt:"<",ltcc:"\u2AA6",ltcir:"\u2A79",ltdot:"\u22D6",lthree:"\u22CB",ltimes:"\u22C9",ltlarr:"\u2976",ltquest:"\u2A7B",ltri:"\u25C3",ltrie:"\u22B4",ltrif:"\u25C2",ltrPar:"\u2996",lurdshar:"\u294A",luruhar:"\u2966",lvertneqq:"\u2268\uFE00",lvnE:"\u2268\uFE00",macr:"\xAF",male:"\u2642",malt:"\u2720",maltese:"\u2720",Map:"\u2905",map:"\u21A6",mapsto:"\u21A6",mapstodown:"\u21A7",mapstoleft:"\u21A4",mapstoup:"\u21A5",marker:"\u25AE",mcomma:"\u2A29",Mcy:"\u041C",mcy:"\u043C",mdash:"\u2014",mDDot:"\u223A",measuredangle:"\u2221",MediumSpace:"\u205F",Mellintrf:"\u2133",Mfr:"\u{1D510}",mfr:"\u{1D52A}",mho:"\u2127",micro:"\xB5",mid:"\u2223",midast:"*",midcir:"\u2AF0",middot:"\xB7",minus:"\u2212",minusb:"\u229F",minusd:"\u2238",minusdu:"\u2A2A",MinusPlus:"\u2213",mlcp:"\u2ADB",mldr:"\u2026",mnplus:"\u2213",models:"\u22A7",Mopf:"\u{1D544}",mopf:"\u{1D55E}",mp:"\u2213",Mscr:"\u2133",mscr:"\u{1D4C2}",mstpos:"\u223E",Mu:"\u039C",mu:"\u03BC",multimap:"\u22B8",mumap:"\u22B8",nabla:"\u2207",Nacute:"\u0143",nacute:"\u0144",nang:"\u2220\u20D2",nap:"\u2249",napE:"\u2A70\u0338",napid:"\u224B\u0338",napos:"\u0149",napprox:"\u2249",natur:"\u266E",natural:"\u266E",naturals:"\u2115",nbsp:"\xA0",nbump:"\u224E\u0338",nbumpe:"\u224F\u0338",ncap:"\u2A43",Ncaron:"\u0147",ncaron:"\u0148",Ncedil:"\u0145",ncedil:"\u0146",ncong:"\u2247",ncongdot:"\u2A6D\u0338",ncup:"\u2A42",Ncy:"\u041D",ncy:"\u043D",ndash:"\u2013",ne:"\u2260",nearhk:"\u2924",neArr:"\u21D7",nearr:"\u2197",nearrow:"\u2197",nedot:"\u2250\u0338",NegativeMediumSpace:"\u200B",NegativeThickSpace:"\u200B",NegativeThinSpace:"\u200B",NegativeVeryThinSpace:"\u200B",nequiv:"\u2262",nesear:"\u2928",nesim:"\u2242\u0338",NestedGreaterGreater:"\u226B",NestedLessLess:"\u226A",NewLine:`
`,nexist:"\u2204",nexists:"\u2204",Nfr:"\u{1D511}",nfr:"\u{1D52B}",ngE:"\u2267\u0338",nge:"\u2271",ngeq:"\u2271",ngeqq:"\u2267\u0338",ngeqslant:"\u2A7E\u0338",nges:"\u2A7E\u0338",nGg:"\u22D9\u0338",ngsim:"\u2275",nGt:"\u226B\u20D2",ngt:"\u226F",ngtr:"\u226F",nGtv:"\u226B\u0338",nhArr:"\u21CE",nharr:"\u21AE",nhpar:"\u2AF2",ni:"\u220B",nis:"\u22FC",nisd:"\u22FA",niv:"\u220B",NJcy:"\u040A",njcy:"\u045A",nlArr:"\u21CD",nlarr:"\u219A",nldr:"\u2025",nlE:"\u2266\u0338",nle:"\u2270",nLeftarrow:"\u21CD",nleftarrow:"\u219A",nLeftrightarrow:"\u21CE",nleftrightarrow:"\u21AE",nleq:"\u2270",nleqq:"\u2266\u0338",nleqslant:"\u2A7D\u0338",nles:"\u2A7D\u0338",nless:"\u226E",nLl:"\u22D8\u0338",nlsim:"\u2274",nLt:"\u226A\u20D2",nlt:"\u226E",nltri:"\u22EA",nltrie:"\u22EC",nLtv:"\u226A\u0338",nmid:"\u2224",NoBreak:"\u2060",NonBreakingSpace:"\xA0",Nopf:"\u2115",nopf:"\u{1D55F}",Not:"\u2AEC",not:"\xAC",NotCongruent:"\u2262",NotCupCap:"\u226D",NotDoubleVerticalBar:"\u2226",NotElement:"\u2209",NotEqual:"\u2260",NotEqualTilde:"\u2242\u0338",NotExists:"\u2204",NotGreater:"\u226F",NotGreaterEqual:"\u2271",NotGreaterFullEqual:"\u2267\u0338",NotGreaterGreater:"\u226B\u0338",NotGreaterLess:"\u2279",NotGreaterSlantEqual:"\u2A7E\u0338",NotGreaterTilde:"\u2275",NotHumpDownHump:"\u224E\u0338",NotHumpEqual:"\u224F\u0338",notin:"\u2209",notindot:"\u22F5\u0338",notinE:"\u22F9\u0338",notinva:"\u2209",notinvb:"\u22F7",notinvc:"\u22F6",NotLeftTriangle:"\u22EA",NotLeftTriangleBar:"\u29CF\u0338",NotLeftTriangleEqual:"\u22EC",NotLess:"\u226E",NotLessEqual:"\u2270",NotLessGreater:"\u2278",NotLessLess:"\u226A\u0338",NotLessSlantEqual:"\u2A7D\u0338",NotLessTilde:"\u2274",NotNestedGreaterGreater:"\u2AA2\u0338",NotNestedLessLess:"\u2AA1\u0338",notni:"\u220C",notniva:"\u220C",notnivb:"\u22FE",notnivc:"\u22FD",NotPrecedes:"\u2280",NotPrecedesEqual:"\u2AAF\u0338",NotPrecedesSlantEqual:"\u22E0",NotReverseElement:"\u220C",NotRightTriangle:"\u22EB",NotRightTriangleBar:"\u29D0\u0338",NotRightTriangleEqual:"\u22ED",NotSquareSubset:"\u228F\u0338",NotSquareSubsetEqual:"\u22E2",NotSquareSuperset:"\u2290\u0338",NotSquareSupersetEqual:"\u22E3",NotSubset:"\u2282\u20D2",NotSubsetEqual:"\u2288",NotSucceeds:"\u2281",NotSucceedsEqual:"\u2AB0\u0338",NotSucceedsSlantEqual:"\u22E1",NotSucceedsTilde:"\u227F\u0338",NotSuperset:"\u2283\u20D2",NotSupersetEqual:"\u2289",NotTilde:"\u2241",NotTildeEqual:"\u2244",NotTildeFullEqual:"\u2247",NotTildeTilde:"\u2249",NotVerticalBar:"\u2224",npar:"\u2226",nparallel:"\u2226",nparsl:"\u2AFD\u20E5",npart:"\u2202\u0338",npolint:"\u2A14",npr:"\u2280",nprcue:"\u22E0",npre:"\u2AAF\u0338",nprec:"\u2280",npreceq:"\u2AAF\u0338",nrArr:"\u21CF",nrarr:"\u219B",nrarrc:"\u2933\u0338",nrarrw:"\u219D\u0338",nRightarrow:"\u21CF",nrightarrow:"\u219B",nrtri:"\u22EB",nrtrie:"\u22ED",nsc:"\u2281",nsccue:"\u22E1",nsce:"\u2AB0\u0338",Nscr:"\u{1D4A9}",nscr:"\u{1D4C3}",nshortmid:"\u2224",nshortparallel:"\u2226",nsim:"\u2241",nsime:"\u2244",nsimeq:"\u2244",nsmid:"\u2224",nspar:"\u2226",nsqsube:"\u22E2",nsqsupe:"\u22E3",nsub:"\u2284",nsubE:"\u2AC5\u0338",nsube:"\u2288",nsubset:"\u2282\u20D2",nsubseteq:"\u2288",nsubseteqq:"\u2AC5\u0338",nsucc:"\u2281",nsucceq:"\u2AB0\u0338",nsup:"\u2285",nsupE:"\u2AC6\u0338",nsupe:"\u2289",nsupset:"\u2283\u20D2",nsupseteq:"\u2289",nsupseteqq:"\u2AC6\u0338",ntgl:"\u2279",Ntilde:"\xD1",ntilde:"\xF1",ntlg:"\u2278",ntriangleleft:"\u22EA",ntrianglelefteq:"\u22EC",ntriangleright:"\u22EB",ntrianglerighteq:"\u22ED",Nu:"\u039D",nu:"\u03BD",num:"#",numero:"\u2116",numsp:"\u2007",nvap:"\u224D\u20D2",nVDash:"\u22AF",nVdash:"\u22AE",nvDash:"\u22AD",nvdash:"\u22AC",nvge:"\u2265\u20D2",nvgt:">\u20D2",nvHarr:"\u2904",nvinfin:"\u29DE",nvlArr:"\u2902",nvle:"\u2264\u20D2",nvlt:"<\u20D2",nvltrie:"\u22B4\u20D2",nvrArr:"\u2903",nvrtrie:"\u22B5\u20D2",nvsim:"\u223C\u20D2",nwarhk:"\u2923",nwArr:"\u21D6",nwarr:"\u2196",nwarrow:"\u2196",nwnear:"\u2927",Oacute:"\xD3",oacute:"\xF3",oast:"\u229B",ocir:"\u229A",Ocirc:"\xD4",ocirc:"\xF4",Ocy:"\u041E",ocy:"\u043E",odash:"\u229D",Odblac:"\u0150",odblac:"\u0151",odiv:"\u2A38",odot:"\u2299",odsold:"\u29BC",OElig:"\u0152",oelig:"\u0153",ofcir:"\u29BF",Ofr:"\u{1D512}",ofr:"\u{1D52C}",ogon:"\u02DB",Ograve:"\xD2",ograve:"\xF2",ogt:"\u29C1",ohbar:"\u29B5",ohm:"\u03A9",oint:"\u222E",olarr:"\u21BA",olcir:"\u29BE",olcross:"\u29BB",oline:"\u203E",olt:"\u29C0",Omacr:"\u014C",omacr:"\u014D",Omega:"\u03A9",omega:"\u03C9",Omicron:"\u039F",omicron:"\u03BF",omid:"\u29B6",ominus:"\u2296",Oopf:"\u{1D546}",oopf:"\u{1D560}",opar:"\u29B7",OpenCurlyDoubleQuote:"\u201C",OpenCurlyQuote:"\u2018",operp:"\u29B9",oplus:"\u2295",Or:"\u2A54",or:"\u2228",orarr:"\u21BB",ord:"\u2A5D",order:"\u2134",orderof:"\u2134",ordf:"\xAA",ordm:"\xBA",origof:"\u22B6",oror:"\u2A56",orslope:"\u2A57",orv:"\u2A5B",oS:"\u24C8",Oscr:"\u{1D4AA}",oscr:"\u2134",Oslash:"\xD8",oslash:"\xF8",osol:"\u2298",Otilde:"\xD5",otilde:"\xF5",Otimes:"\u2A37",otimes:"\u2297",otimesas:"\u2A36",Ouml:"\xD6",ouml:"\xF6",ovbar:"\u233D",OverBar:"\u203E",OverBrace:"\u23DE",OverBracket:"\u23B4",OverParenthesis:"\u23DC",par:"\u2225",para:"\xB6",parallel:"\u2225",parsim:"\u2AF3",parsl:"\u2AFD",part:"\u2202",PartialD:"\u2202",Pcy:"\u041F",pcy:"\u043F",percnt:"%",period:".",permil:"\u2030",perp:"\u22A5",pertenk:"\u2031",Pfr:"\u{1D513}",pfr:"\u{1D52D}",Phi:"\u03A6",phi:"\u03C6",phiv:"\u03D5",phmmat:"\u2133",phone:"\u260E",Pi:"\u03A0",pi:"\u03C0",pitchfork:"\u22D4",piv:"\u03D6",planck:"\u210F",planckh:"\u210E",plankv:"\u210F",plus:"+",plusacir:"\u2A23",plusb:"\u229E",pluscir:"\u2A22",plusdo:"\u2214",plusdu:"\u2A25",pluse:"\u2A72",PlusMinus:"\xB1",plusmn:"\xB1",plussim:"\u2A26",plustwo:"\u2A27",pm:"\xB1",Poincareplane:"\u210C",pointint:"\u2A15",Popf:"\u2119",popf:"\u{1D561}",pound:"\xA3",Pr:"\u2ABB",pr:"\u227A",prap:"\u2AB7",prcue:"\u227C",prE:"\u2AB3",pre:"\u2AAF",prec:"\u227A",precapprox:"\u2AB7",preccurlyeq:"\u227C",Precedes:"\u227A",PrecedesEqual:"\u2AAF",PrecedesSlantEqual:"\u227C",PrecedesTilde:"\u227E",preceq:"\u2AAF",precnapprox:"\u2AB9",precneqq:"\u2AB5",precnsim:"\u22E8",precsim:"\u227E",Prime:"\u2033",prime:"\u2032",primes:"\u2119",prnap:"\u2AB9",prnE:"\u2AB5",prnsim:"\u22E8",prod:"\u220F",Product:"\u220F",profalar:"\u232E",profline:"\u2312",profsurf:"\u2313",prop:"\u221D",Proportion:"\u2237",Proportional:"\u221D",propto:"\u221D",prsim:"\u227E",prurel:"\u22B0",Pscr:"\u{1D4AB}",pscr:"\u{1D4C5}",Psi:"\u03A8",psi:"\u03C8",puncsp:"\u2008",Qfr:"\u{1D514}",qfr:"\u{1D52E}",qint:"\u2A0C",Qopf:"\u211A",qopf:"\u{1D562}",qprime:"\u2057",Qscr:"\u{1D4AC}",qscr:"\u{1D4C6}",quaternions:"\u210D",quatint:"\u2A16",quest:"?",questeq:"\u225F",QUOT:'"',quot:'"',rAarr:"\u21DB",race:"\u223D\u0331",Racute:"\u0154",racute:"\u0155",radic:"\u221A",raemptyv:"\u29B3",Rang:"\u27EB",rang:"\u27E9",rangd:"\u2992",range:"\u29A5",rangle:"\u27E9",raquo:"\xBB",Rarr:"\u21A0",rArr:"\u21D2",rarr:"\u2192",rarrap:"\u2975",rarrb:"\u21E5",rarrbfs:"\u2920",rarrc:"\u2933",rarrfs:"\u291E",rarrhk:"\u21AA",rarrlp:"\u21AC",rarrpl:"\u2945",rarrsim:"\u2974",Rarrtl:"\u2916",rarrtl:"\u21A3",rarrw:"\u219D",rAtail:"\u291C",ratail:"\u291A",ratio:"\u2236",rationals:"\u211A",RBarr:"\u2910",rBarr:"\u290F",rbarr:"\u290D",rbbrk:"\u2773",rbrace:"}",rbrack:"]",rbrke:"\u298C",rbrksld:"\u298E",rbrkslu:"\u2990",Rcaron:"\u0158",rcaron:"\u0159",Rcedil:"\u0156",rcedil:"\u0157",rceil:"\u2309",rcub:"}",Rcy:"\u0420",rcy:"\u0440",rdca:"\u2937",rdldhar:"\u2969",rdquo:"\u201D",rdquor:"\u201D",rdsh:"\u21B3",Re:"\u211C",real:"\u211C",realine:"\u211B",realpart:"\u211C",reals:"\u211D",rect:"\u25AD",REG:"\xAE",reg:"\xAE",ReverseElement:"\u220B",ReverseEquilibrium:"\u21CB",ReverseUpEquilibrium:"\u296F",rfisht:"\u297D",rfloor:"\u230B",Rfr:"\u211C",rfr:"\u{1D52F}",rHar:"\u2964",rhard:"\u21C1",rharu:"\u21C0",rharul:"\u296C",Rho:"\u03A1",rho:"\u03C1",rhov:"\u03F1",RightAngleBracket:"\u27E9",RightArrow:"\u2192",Rightarrow:"\u21D2",rightarrow:"\u2192",RightArrowBar:"\u21E5",RightArrowLeftArrow:"\u21C4",rightarrowtail:"\u21A3",RightCeiling:"\u2309",RightDoubleBracket:"\u27E7",RightDownTeeVector:"\u295D",RightDownVector:"\u21C2",RightDownVectorBar:"\u2955",RightFloor:"\u230B",rightharpoondown:"\u21C1",rightharpoonup:"\u21C0",rightleftarrows:"\u21C4",rightleftharpoons:"\u21CC",rightrightarrows:"\u21C9",rightsquigarrow:"\u219D",RightTee:"\u22A2",RightTeeArrow:"\u21A6",RightTeeVector:"\u295B",rightthreetimes:"\u22CC",RightTriangle:"\u22B3",RightTriangleBar:"\u29D0",RightTriangleEqual:"\u22B5",RightUpDownVector:"\u294F",RightUpTeeVector:"\u295C",RightUpVector:"\u21BE",RightUpVectorBar:"\u2954",RightVector:"\u21C0",RightVectorBar:"\u2953",ring:"\u02DA",risingdotseq:"\u2253",rlarr:"\u21C4",rlhar:"\u21CC",rlm:"\u200F",rmoust:"\u23B1",rmoustache:"\u23B1",rnmid:"\u2AEE",roang:"\u27ED",roarr:"\u21FE",robrk:"\u27E7",ropar:"\u2986",Ropf:"\u211D",ropf:"\u{1D563}",roplus:"\u2A2E",rotimes:"\u2A35",RoundImplies:"\u2970",rpar:")",rpargt:"\u2994",rppolint:"\u2A12",rrarr:"\u21C9",Rrightarrow:"\u21DB",rsaquo:"\u203A",Rscr:"\u211B",rscr:"\u{1D4C7}",Rsh:"\u21B1",rsh:"\u21B1",rsqb:"]",rsquo:"\u2019",rsquor:"\u2019",rthree:"\u22CC",rtimes:"\u22CA",rtri:"\u25B9",rtrie:"\u22B5",rtrif:"\u25B8",rtriltri:"\u29CE",RuleDelayed:"\u29F4",ruluhar:"\u2968",rx:"\u211E",Sacute:"\u015A",sacute:"\u015B",sbquo:"\u201A",Sc:"\u2ABC",sc:"\u227B",scap:"\u2AB8",Scaron:"\u0160",scaron:"\u0161",sccue:"\u227D",scE:"\u2AB4",sce:"\u2AB0",Scedil:"\u015E",scedil:"\u015F",Scirc:"\u015C",scirc:"\u015D",scnap:"\u2ABA",scnE:"\u2AB6",scnsim:"\u22E9",scpolint:"\u2A13",scsim:"\u227F",Scy:"\u0421",scy:"\u0441",sdot:"\u22C5",sdotb:"\u22A1",sdote:"\u2A66",searhk:"\u2925",seArr:"\u21D8",searr:"\u2198",searrow:"\u2198",sect:"\xA7",semi:";",seswar:"\u2929",setminus:"\u2216",setmn:"\u2216",sext:"\u2736",Sfr:"\u{1D516}",sfr:"\u{1D530}",sfrown:"\u2322",sharp:"\u266F",SHCHcy:"\u0429",shchcy:"\u0449",SHcy:"\u0428",shcy:"\u0448",ShortDownArrow:"\u2193",ShortLeftArrow:"\u2190",shortmid:"\u2223",shortparallel:"\u2225",ShortRightArrow:"\u2192",ShortUpArrow:"\u2191",shy:"\xAD",Sigma:"\u03A3",sigma:"\u03C3",sigmaf:"\u03C2",sigmav:"\u03C2",sim:"\u223C",simdot:"\u2A6A",sime:"\u2243",simeq:"\u2243",simg:"\u2A9E",simgE:"\u2AA0",siml:"\u2A9D",simlE:"\u2A9F",simne:"\u2246",simplus:"\u2A24",simrarr:"\u2972",slarr:"\u2190",SmallCircle:"\u2218",smallsetminus:"\u2216",smashp:"\u2A33",smeparsl:"\u29E4",smid:"\u2223",smile:"\u2323",smt:"\u2AAA",smte:"\u2AAC",smtes:"\u2AAC\uFE00",SOFTcy:"\u042C",softcy:"\u044C",sol:"/",solb:"\u29C4",solbar:"\u233F",Sopf:"\u{1D54A}",sopf:"\u{1D564}",spades:"\u2660",spadesuit:"\u2660",spar:"\u2225",sqcap:"\u2293",sqcaps:"\u2293\uFE00",sqcup:"\u2294",sqcups:"\u2294\uFE00",Sqrt:"\u221A",sqsub:"\u228F",sqsube:"\u2291",sqsubset:"\u228F",sqsubseteq:"\u2291",sqsup:"\u2290",sqsupe:"\u2292",sqsupset:"\u2290",sqsupseteq:"\u2292",squ:"\u25A1",Square:"\u25A1",square:"\u25A1",SquareIntersection:"\u2293",SquareSubset:"\u228F",SquareSubsetEqual:"\u2291",SquareSuperset:"\u2290",SquareSupersetEqual:"\u2292",SquareUnion:"\u2294",squarf:"\u25AA",squf:"\u25AA",srarr:"\u2192",Sscr:"\u{1D4AE}",sscr:"\u{1D4C8}",ssetmn:"\u2216",ssmile:"\u2323",sstarf:"\u22C6",Star:"\u22C6",star:"\u2606",starf:"\u2605",straightepsilon:"\u03F5",straightphi:"\u03D5",strns:"\xAF",Sub:"\u22D0",sub:"\u2282",subdot:"\u2ABD",subE:"\u2AC5",sube:"\u2286",subedot:"\u2AC3",submult:"\u2AC1",subnE:"\u2ACB",subne:"\u228A",subplus:"\u2ABF",subrarr:"\u2979",Subset:"\u22D0",subset:"\u2282",subseteq:"\u2286",subseteqq:"\u2AC5",SubsetEqual:"\u2286",subsetneq:"\u228A",subsetneqq:"\u2ACB",subsim:"\u2AC7",subsub:"\u2AD5",subsup:"\u2AD3",succ:"\u227B",succapprox:"\u2AB8",succcurlyeq:"\u227D",Succeeds:"\u227B",SucceedsEqual:"\u2AB0",SucceedsSlantEqual:"\u227D",SucceedsTilde:"\u227F",succeq:"\u2AB0",succnapprox:"\u2ABA",succneqq:"\u2AB6",succnsim:"\u22E9",succsim:"\u227F",SuchThat:"\u220B",Sum:"\u2211",sum:"\u2211",sung:"\u266A",Sup:"\u22D1",sup:"\u2283",sup1:"\xB9",sup2:"\xB2",sup3:"\xB3",supdot:"\u2ABE",supdsub:"\u2AD8",supE:"\u2AC6",supe:"\u2287",supedot:"\u2AC4",Superset:"\u2283",SupersetEqual:"\u2287",suphsol:"\u27C9",suphsub:"\u2AD7",suplarr:"\u297B",supmult:"\u2AC2",supnE:"\u2ACC",supne:"\u228B",supplus:"\u2AC0",Supset:"\u22D1",supset:"\u2283",supseteq:"\u2287",supseteqq:"\u2AC6",supsetneq:"\u228B",supsetneqq:"\u2ACC",supsim:"\u2AC8",supsub:"\u2AD4",supsup:"\u2AD6",swarhk:"\u2926",swArr:"\u21D9",swarr:"\u2199",swarrow:"\u2199",swnwar:"\u292A",szlig:"\xDF",Tab:"	",target:"\u2316",Tau:"\u03A4",tau:"\u03C4",tbrk:"\u23B4",Tcaron:"\u0164",tcaron:"\u0165",Tcedil:"\u0162",tcedil:"\u0163",Tcy:"\u0422",tcy:"\u0442",tdot:"\u20DB",telrec:"\u2315",Tfr:"\u{1D517}",tfr:"\u{1D531}",there4:"\u2234",Therefore:"\u2234",therefore:"\u2234",Theta:"\u0398",theta:"\u03B8",thetasym:"\u03D1",thetav:"\u03D1",thickapprox:"\u2248",thicksim:"\u223C",ThickSpace:"\u205F\u200A",thinsp:"\u2009",ThinSpace:"\u2009",thkap:"\u2248",thksim:"\u223C",THORN:"\xDE",thorn:"\xFE",Tilde:"\u223C",tilde:"\u02DC",TildeEqual:"\u2243",TildeFullEqual:"\u2245",TildeTilde:"\u2248",times:"\xD7",timesb:"\u22A0",timesbar:"\u2A31",timesd:"\u2A30",tint:"\u222D",toea:"\u2928",top:"\u22A4",topbot:"\u2336",topcir:"\u2AF1",Topf:"\u{1D54B}",topf:"\u{1D565}",topfork:"\u2ADA",tosa:"\u2929",tprime:"\u2034",TRADE:"\u2122",trade:"\u2122",triangle:"\u25B5",triangledown:"\u25BF",triangleleft:"\u25C3",trianglelefteq:"\u22B4",triangleq:"\u225C",triangleright:"\u25B9",trianglerighteq:"\u22B5",tridot:"\u25EC",trie:"\u225C",triminus:"\u2A3A",TripleDot:"\u20DB",triplus:"\u2A39",trisb:"\u29CD",tritime:"\u2A3B",trpezium:"\u23E2",Tscr:"\u{1D4AF}",tscr:"\u{1D4C9}",TScy:"\u0426",tscy:"\u0446",TSHcy:"\u040B",tshcy:"\u045B",Tstrok:"\u0166",tstrok:"\u0167",twixt:"\u226C",twoheadleftarrow:"\u219E",twoheadrightarrow:"\u21A0",Uacute:"\xDA",uacute:"\xFA",Uarr:"\u219F",uArr:"\u21D1",uarr:"\u2191",Uarrocir:"\u2949",Ubrcy:"\u040E",ubrcy:"\u045E",Ubreve:"\u016C",ubreve:"\u016D",Ucirc:"\xDB",ucirc:"\xFB",Ucy:"\u0423",ucy:"\u0443",udarr:"\u21C5",Udblac:"\u0170",udblac:"\u0171",udhar:"\u296E",ufisht:"\u297E",Ufr:"\u{1D518}",ufr:"\u{1D532}",Ugrave:"\xD9",ugrave:"\xF9",uHar:"\u2963",uharl:"\u21BF",uharr:"\u21BE",uhblk:"\u2580",ulcorn:"\u231C",ulcorner:"\u231C",ulcrop:"\u230F",ultri:"\u25F8",Umacr:"\u016A",umacr:"\u016B",uml:"\xA8",UnderBar:"_",UnderBrace:"\u23DF",UnderBracket:"\u23B5",UnderParenthesis:"\u23DD",Union:"\u22C3",UnionPlus:"\u228E",Uogon:"\u0172",uogon:"\u0173",Uopf:"\u{1D54C}",uopf:"\u{1D566}",UpArrow:"\u2191",Uparrow:"\u21D1",uparrow:"\u2191",UpArrowBar:"\u2912",UpArrowDownArrow:"\u21C5",UpDownArrow:"\u2195",Updownarrow:"\u21D5",updownarrow:"\u2195",UpEquilibrium:"\u296E",upharpoonleft:"\u21BF",upharpoonright:"\u21BE",uplus:"\u228E",UpperLeftArrow:"\u2196",UpperRightArrow:"\u2197",Upsi:"\u03D2",upsi:"\u03C5",upsih:"\u03D2",Upsilon:"\u03A5",upsilon:"\u03C5",UpTee:"\u22A5",UpTeeArrow:"\u21A5",upuparrows:"\u21C8",urcorn:"\u231D",urcorner:"\u231D",urcrop:"\u230E",Uring:"\u016E",uring:"\u016F",urtri:"\u25F9",Uscr:"\u{1D4B0}",uscr:"\u{1D4CA}",utdot:"\u22F0",Utilde:"\u0168",utilde:"\u0169",utri:"\u25B5",utrif:"\u25B4",uuarr:"\u21C8",Uuml:"\xDC",uuml:"\xFC",uwangle:"\u29A7",vangrt:"\u299C",varepsilon:"\u03F5",varkappa:"\u03F0",varnothing:"\u2205",varphi:"\u03D5",varpi:"\u03D6",varpropto:"\u221D",vArr:"\u21D5",varr:"\u2195",varrho:"\u03F1",varsigma:"\u03C2",varsubsetneq:"\u228A\uFE00",varsubsetneqq:"\u2ACB\uFE00",varsupsetneq:"\u228B\uFE00",varsupsetneqq:"\u2ACC\uFE00",vartheta:"\u03D1",vartriangleleft:"\u22B2",vartriangleright:"\u22B3",Vbar:"\u2AEB",vBar:"\u2AE8",vBarv:"\u2AE9",Vcy:"\u0412",vcy:"\u0432",VDash:"\u22AB",Vdash:"\u22A9",vDash:"\u22A8",vdash:"\u22A2",Vdashl:"\u2AE6",Vee:"\u22C1",vee:"\u2228",veebar:"\u22BB",veeeq:"\u225A",vellip:"\u22EE",Verbar:"\u2016",verbar:"|",Vert:"\u2016",vert:"|",VerticalBar:"\u2223",VerticalLine:"|",VerticalSeparator:"\u2758",VerticalTilde:"\u2240",VeryThinSpace:"\u200A",Vfr:"\u{1D519}",vfr:"\u{1D533}",vltri:"\u22B2",vnsub:"\u2282\u20D2",vnsup:"\u2283\u20D2",Vopf:"\u{1D54D}",vopf:"\u{1D567}",vprop:"\u221D",vrtri:"\u22B3",Vscr:"\u{1D4B1}",vscr:"\u{1D4CB}",vsubnE:"\u2ACB\uFE00",vsubne:"\u228A\uFE00",vsupnE:"\u2ACC\uFE00",vsupne:"\u228B\uFE00",Vvdash:"\u22AA",vzigzag:"\u299A",Wcirc:"\u0174",wcirc:"\u0175",wedbar:"\u2A5F",Wedge:"\u22C0",wedge:"\u2227",wedgeq:"\u2259",weierp:"\u2118",Wfr:"\u{1D51A}",wfr:"\u{1D534}",Wopf:"\u{1D54E}",wopf:"\u{1D568}",wp:"\u2118",wr:"\u2240",wreath:"\u2240",Wscr:"\u{1D4B2}",wscr:"\u{1D4CC}",xcap:"\u22C2",xcirc:"\u25EF",xcup:"\u22C3",xdtri:"\u25BD",Xfr:"\u{1D51B}",xfr:"\u{1D535}",xhArr:"\u27FA",xharr:"\u27F7",Xi:"\u039E",xi:"\u03BE",xlArr:"\u27F8",xlarr:"\u27F5",xmap:"\u27FC",xnis:"\u22FB",xodot:"\u2A00",Xopf:"\u{1D54F}",xopf:"\u{1D569}",xoplus:"\u2A01",xotime:"\u2A02",xrArr:"\u27F9",xrarr:"\u27F6",Xscr:"\u{1D4B3}",xscr:"\u{1D4CD}",xsqcup:"\u2A06",xuplus:"\u2A04",xutri:"\u25B3",xvee:"\u22C1",xwedge:"\u22C0",Yacute:"\xDD",yacute:"\xFD",YAcy:"\u042F",yacy:"\u044F",Ycirc:"\u0176",ycirc:"\u0177",Ycy:"\u042B",ycy:"\u044B",yen:"\xA5",Yfr:"\u{1D51C}",yfr:"\u{1D536}",YIcy:"\u0407",yicy:"\u0457",Yopf:"\u{1D550}",yopf:"\u{1D56A}",Yscr:"\u{1D4B4}",yscr:"\u{1D4CE}",YUcy:"\u042E",yucy:"\u044E",Yuml:"\u0178",yuml:"\xFF",Zacute:"\u0179",zacute:"\u017A",Zcaron:"\u017D",zcaron:"\u017E",Zcy:"\u0417",zcy:"\u0437",Zdot:"\u017B",zdot:"\u017C",zeetrf:"\u2128",ZeroWidthSpace:"\u200B",Zeta:"\u0396",zeta:"\u03B6",Zfr:"\u2128",zfr:"\u{1D537}",ZHcy:"\u0416",zhcy:"\u0436",zigrarr:"\u21DD",Zopf:"\u2124",zopf:"\u{1D56B}",Zscr:"\u{1D4B5}",zscr:"\u{1D4CF}",zwj:"\u200D",zwnj:"\u200C"}),X.entityMap=X.HTML_ENTITIES}),NAMESPACE$1=conventions.NAMESPACE,nameStartChar=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,nameChar=new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),tagNamePattern=new RegExp("^"+nameStartChar.source+nameChar.source+"*(?::"+nameStartChar.source+nameChar.source+"*)?$"),S_TAG=0,S_ATTR=1,S_ATTR_SPACE=2,S_EQ=3,S_ATTR_NOQUOT_VALUE=4,S_ATTR_END=5,S_TAG_SPACE=6,S_TAG_CLOSE=7;function ParseError$1(Z,X){this.message=Z,this.locator=X,Error.captureStackTrace&&Error.captureStackTrace(this,ParseError$1)}ParseError$1.prototype=new Error,ParseError$1.prototype.name=ParseError$1.name;function XMLReader$1(){}XMLReader$1.prototype={parse:function(Z,X,K){var J=this.domBuilder;J.startDocument(),_copy(X,X={}),parse(Z,X,K,J,this.errorHandler),J.endDocument()}};function parse(Z,X,K,J,Q){function ee(we){if(we>65535){we-=65536;var Be=55296+(we>>10),De=56320+(we&1023);return String.fromCharCode(Be,De)}else return String.fromCharCode(we)}function te(we){var Be=we.slice(1,-1);return Object.hasOwnProperty.call(K,Be)?K[Be]:Be.charAt(0)==="#"?ee(parseInt(Be.substr(1).replace("x","0x"))):(Q.error("entity not found:"+we),we)}function re(we){if(we>de){var Be=Z.substring(de,we).replace(/&#?\w+;/g,te);ae&&ne(de),J.characters(Be,0,we-de),de=we}}function ne(we,Be){for(;we>=se&&(Be=oe.exec(Z));)ie=Be.index,se=ie+Be[0].length,ae.lineNumber++;ae.columnNumber=we-ie+1}for(var ie=0,se=0,oe=/.*(?:\r\n?|\n)|.*$/g,ae=J.locator,le=[{currentNSMap:X}],ce={},de=0;;){try{var he=Z.indexOf("<",de);if(he<0){if(!Z.substr(de).match(/^\s*$/)){var pe=J.doc,fe=pe.createTextNode(Z.substr(de));pe.appendChild(fe),J.currentElement=fe}return}switch(he>de&&re(he),Z.charAt(he+1)){case"/":var Se=Z.indexOf(">",he+3),ge=Z.substring(he+2,Se).replace(/[ \t\n\r]+$/g,""),me=le.pop();Se<0?(ge=Z.substring(he+2).replace(/[\s<].*/,""),Q.error("end tag name: "+ge+" is not complete:"+me.tagName),Se=he+1+ge.length):ge.match(/\s</)&&(ge=ge.replace(/[\s<].*/,""),Q.error("end tag name: "+ge+" maybe not complete"),Se=he+1+ge.length);var ye=me.localNSMap,_e=me.tagName==ge,Ae=_e||me.tagName&&me.tagName.toLowerCase()==ge.toLowerCase();if(Ae){if(J.endElement(me.uri,me.localName,ge),ye)for(var ve in ye)Object.prototype.hasOwnProperty.call(ye,ve)&&J.endPrefixMapping(ve);_e||Q.fatalError("end tag name: "+ge+" is not match the current start tagName:"+me.tagName)}else le.push(me);Se++;break;case"?":ae&&ne(he),Se=parseInstruction(Z,he,J);break;case"!":ae&&ne(he),Se=parseDCC(Z,he,J,Q);break;default:ae&&ne(he);var be=new ElementAttributes,xe=le[le.length-1].currentNSMap,Se=parseElementStartPart(Z,he,be,xe,te,Q),$e=be.length;if(!be.closed&&fixSelfClosed(Z,Se,be.tagName,ce)&&(be.closed=!0,K.nbsp||Q.warning("unclosed xml attribute")),ae&&$e){for(var Ce=copyLocator(ae,{}),Te=0;Te<$e;Te++){var Ie=be[Te];ne(Ie.offset),Ie.locator=copyLocator(ae,{})}J.locator=Ce,appendElement$1(be,J,xe)&&le.push(be),J.locator=ae}else appendElement$1(be,J,xe)&&le.push(be);NAMESPACE$1.isHTML(be.uri)&&!be.closed?Se=parseHtmlSpecialContent(Z,Se,be.tagName,te,J):Se++}}catch(we){if(we instanceof ParseError$1)throw we;Q.error("element parse error: "+we),Se=-1}Se>de?de=Se:re(Math.max(he,de)+1)}}function copyLocator(Z,X){return X.lineNumber=Z.lineNumber,X.columnNumber=Z.columnNumber,X}function parseElementStartPart(Z,X,K,J,Q,ee){function te(le,ce,de){K.attributeNames.hasOwnProperty(le)&&ee.fatalError("Attribute "+le+" redefined"),K.addValue(le,ce.replace(/[\t\n\r]/g," ").replace(/&#?\w+;/g,Q),de)}for(var re,ne,ie=++X,se=S_TAG;;){var oe=Z.charAt(ie);switch(oe){case"=":if(se===S_ATTR)re=Z.slice(X,ie),se=S_EQ;else if(se===S_ATTR_SPACE)se=S_EQ;else throw new Error("attribute equal must after attrName");break;case"'":case'"':if(se===S_EQ||se===S_ATTR)if(se===S_ATTR&&(ee.warning('attribute value must after "="'),re=Z.slice(X,ie)),X=ie+1,ie=Z.indexOf(oe,X),ie>0)ne=Z.slice(X,ie),te(re,ne,X-1),se=S_ATTR_END;else throw new Error("attribute value no end '"+oe+"' match");else if(se==S_ATTR_NOQUOT_VALUE)ne=Z.slice(X,ie),te(re,ne,X),ee.warning('attribute "'+re+'" missed start quot('+oe+")!!"),X=ie+1,se=S_ATTR_END;else throw new Error('attribute value must after "="');break;case"/":switch(se){case S_TAG:K.setTagName(Z.slice(X,ie));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:se=S_TAG_CLOSE,K.closed=!0;case S_ATTR_NOQUOT_VALUE:case S_ATTR:break;case S_ATTR_SPACE:K.closed=!0;break;default:throw new Error("attribute invalid close char('/')")}break;case"":return ee.error("unexpected end of input"),se==S_TAG&&K.setTagName(Z.slice(X,ie)),ie;case">":switch(se){case S_TAG:K.setTagName(Z.slice(X,ie));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:break;case S_ATTR_NOQUOT_VALUE:case S_ATTR:ne=Z.slice(X,ie),ne.slice(-1)==="/"&&(K.closed=!0,ne=ne.slice(0,-1));case S_ATTR_SPACE:se===S_ATTR_SPACE&&(ne=re),se==S_ATTR_NOQUOT_VALUE?(ee.warning('attribute "'+ne+'" missed quot(")!'),te(re,ne,X)):((!NAMESPACE$1.isHTML(J[""])||!ne.match(/^(?:disabled|checked|selected)$/i))&&ee.warning('attribute "'+ne+'" missed value!! "'+ne+'" instead!!'),te(ne,ne,X));break;case S_EQ:throw new Error("attribute value missed!!")}return ie;case"\x80":oe=" ";default:if(oe<=" ")switch(se){case S_TAG:K.setTagName(Z.slice(X,ie)),se=S_TAG_SPACE;break;case S_ATTR:re=Z.slice(X,ie),se=S_ATTR_SPACE;break;case S_ATTR_NOQUOT_VALUE:var ne=Z.slice(X,ie);ee.warning('attribute "'+ne+'" missed quot(")!!'),te(re,ne,X);case S_ATTR_END:se=S_TAG_SPACE;break}else switch(se){case S_ATTR_SPACE:var ae=K.tagName;(!NAMESPACE$1.isHTML(J[""])||!re.match(/^(?:disabled|checked|selected)$/i))&&ee.warning('attribute "'+re+'" missed value!! "'+re+'" instead2!!'),te(re,re,X),X=ie,se=S_ATTR;break;case S_ATTR_END:ee.warning('attribute space is required"'+re+'"!!');case S_TAG_SPACE:se=S_ATTR,X=ie;break;case S_EQ:se=S_ATTR_NOQUOT_VALUE,X=ie;break;case S_TAG_CLOSE:throw new Error("elements closed character '/' and '>' must be connected to")}}ie++}}function appendElement$1(Z,X,K){for(var J=Z.tagName,Q=null,oe=Z.length;oe--;){var ee=Z[oe],te=ee.qName,re=ee.value,ae=te.indexOf(":");if(ae>0)var ne=ee.prefix=te.slice(0,ae),ie=te.slice(ae+1),se=ne==="xmlns"&&ie;else ie=te,ne=null,se=te==="xmlns"&&"";ee.localName=ie,se!==!1&&(Q==null&&(Q={},_copy(K,K={})),K[se]=Q[se]=re,ee.uri=NAMESPACE$1.XMLNS,X.startPrefixMapping(se,re))}for(var oe=Z.length;oe--;){ee=Z[oe];var ne=ee.prefix;ne&&(ne==="xml"&&(ee.uri=NAMESPACE$1.XML),ne!=="xmlns"&&(ee.uri=K[ne||""]))}var ae=J.indexOf(":");ae>0?(ne=Z.prefix=J.slice(0,ae),ie=Z.localName=J.slice(ae+1)):(ne=null,ie=Z.localName=J);var le=Z.uri=K[ne||""];if(X.startElement(le,ie,J,Z),Z.closed){if(X.endElement(le,ie,J),Q)for(ne in Q)Object.prototype.hasOwnProperty.call(Q,ne)&&X.endPrefixMapping(ne)}else return Z.currentNSMap=K,Z.localNSMap=Q,!0}function parseHtmlSpecialContent(Z,X,K,J,Q){if(/^(?:script|textarea)$/i.test(K)){var ee=Z.indexOf("</"+K+">",X),te=Z.substring(X+1,ee);if(/[&<]/.test(te))return/^script$/i.test(K)?(Q.characters(te,0,te.length),ee):(te=te.replace(/&#?\w+;/g,J),Q.characters(te,0,te.length),ee)}return X+1}function fixSelfClosed(Z,X,K,J){var Q=J[K];return Q==null&&(Q=Z.lastIndexOf("</"+K+">"),Q<X&&(Q=Z.lastIndexOf("</"+K)),J[K]=Q),Q<X}function _copy(Z,X){for(var K in Z)Object.prototype.hasOwnProperty.call(Z,K)&&(X[K]=Z[K])}function parseDCC(Z,X,K,J){var Q=Z.charAt(X+2);switch(Q){case"-":if(Z.charAt(X+3)==="-"){var ee=Z.indexOf("-->",X+4);return ee>X?(K.comment(Z,X+4,ee-X-4),ee+3):(J.error("Unclosed comment"),-1)}else return-1;default:if(Z.substr(X+3,6)=="CDATA["){var ee=Z.indexOf("]]>",X+9);return K.startCDATA(),K.characters(Z,X+9,ee-X-9),K.endCDATA(),ee+3}var te=split(Z,X),re=te.length;if(re>1&&/!doctype/i.test(te[0][0])){var ne=te[1][0],ie=!1,se=!1;re>3&&(/^public$/i.test(te[2][0])?(ie=te[3][0],se=re>4&&te[4][0]):/^system$/i.test(te[2][0])&&(se=te[3][0]));var oe=te[re-1];return K.startDTD(ne,ie,se),K.endDTD(),oe.index+oe[0].length}}return-1}function parseInstruction(Z,X,K){var J=Z.indexOf("?>",X);if(J){var Q=Z.substring(X,J).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(Q){var ee=Q[0].length;return K.processingInstruction(Q[1],Q[2]),J+2}else return-1}return-1}function ElementAttributes(){this.attributeNames={}}ElementAttributes.prototype={setTagName:function(Z){if(!tagNamePattern.test(Z))throw new Error("invalid tagName:"+Z);this.tagName=Z},addValue:function(Z,X,K){if(!tagNamePattern.test(Z))throw new Error("invalid attribute:"+Z);this.attributeNames[Z]=this.length,this[this.length++]={qName:Z,value:X,offset:K}},length:0,getLocalName:function(Z){return this[Z].localName},getLocator:function(Z){return this[Z].locator},getQName:function(Z){return this[Z].qName},getURI:function(Z){return this[Z].uri},getValue:function(Z){return this[Z].value}};function split(Z,X){var K,J=[],Q=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(Q.lastIndex=X,Q.exec(Z);K=Q.exec(Z);)if(J.push(K),K[1])return J}var XMLReader_1=XMLReader$1,ParseError_1=ParseError$1,sax={XMLReader:XMLReader_1,ParseError:ParseError_1},DOMImplementation$1=dom.DOMImplementation,NAMESPACE=conventions.NAMESPACE,ParseError=sax.ParseError,XMLReader=sax.XMLReader;function normalizeLineEndings(Z){return Z.replace(/\r[\n\u0085]/g,`
`).replace(/[\r\u0085\u2028]/g,`
`)}function DOMParser$2(Z){this.options=Z||{locator:{}}}DOMParser$2.prototype.parseFromString=function(Z,X){var K=this.options,J=new XMLReader,Q=K.domBuilder||new DOMHandler,ee=K.errorHandler,te=K.locator,re=K.xmlns||{},ne=/\/x?html?$/.test(X),ie=ne?entities.HTML_ENTITIES:entities.XML_ENTITIES;te&&Q.setDocumentLocator(te),J.errorHandler=buildErrorHandler(ee,Q,te),J.domBuilder=K.domBuilder||Q,ne&&(re[""]=NAMESPACE.HTML),re.xml=re.xml||NAMESPACE.XML;var se=K.normalizeLineEndings||normalizeLineEndings;return Z&&typeof Z=="string"?J.parse(se(Z),re,ie):J.errorHandler.error("invalid doc source"),Q.doc};function buildErrorHandler(Z,X,K){if(!Z){if(X instanceof DOMHandler)return X;Z=X}var J={},Q=Z instanceof Function;K=K||{};function ee(te){var re=Z[te];!re&&Q&&(re=Z.length==2?function(ne){Z(te,ne)}:Z),J[te]=re&&function(ne){re("[xmldom "+te+"]	"+ne+_locator(K))}||function(){}}return ee("warning"),ee("error"),ee("fatalError"),J}function DOMHandler(){this.cdata=!1}function position(Z,X){X.lineNumber=Z.lineNumber,X.columnNumber=Z.columnNumber}DOMHandler.prototype={startDocument:function(){this.doc=new DOMImplementation$1().createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(Z,X,K,J){var Q=this.doc,ee=Q.createElementNS(Z,K||X),te=J.length;appendElement(this,ee),this.currentElement=ee,this.locator&&position(this.locator,ee);for(var re=0;re<te;re++){var Z=J.getURI(re),ne=J.getValue(re),K=J.getQName(re),ie=Q.createAttributeNS(Z,K);this.locator&&position(J.getLocator(re),ie),ie.value=ie.nodeValue=ne,ee.setAttributeNode(ie)}},endElement:function(Z,X,K){var J=this.currentElement,Q=J.tagName;this.currentElement=J.parentNode},startPrefixMapping:function(Z,X){},endPrefixMapping:function(Z){},processingInstruction:function(Z,X){var K=this.doc.createProcessingInstruction(Z,X);this.locator&&position(this.locator,K),appendElement(this,K)},ignorableWhitespace:function(Z,X,K){},characters:function(Z,X,K){if(Z=_toString.apply(this,arguments),Z){if(this.cdata)var J=this.doc.createCDATASection(Z);else var J=this.doc.createTextNode(Z);this.currentElement?this.currentElement.appendChild(J):/^\s*$/.test(Z)&&this.doc.appendChild(J),this.locator&&position(this.locator,J)}},skippedEntity:function(Z){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(Z){(this.locator=Z)&&(Z.lineNumber=0)},comment:function(Z,X,K){Z=_toString.apply(this,arguments);var J=this.doc.createComment(Z);this.locator&&position(this.locator,J),appendElement(this,J)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(Z,X,K){var J=this.doc.implementation;if(J&&J.createDocumentType){var Q=J.createDocumentType(Z,X,K);this.locator&&position(this.locator,Q),appendElement(this,Q),this.doc.doctype=Q}},warning:function(Z){console.warn("[xmldom warning]	"+Z,_locator(this.locator))},error:function(Z){console.error("[xmldom error]	"+Z,_locator(this.locator))},fatalError:function(Z){throw new ParseError(Z,this.locator)}};function _locator(Z){if(Z)return`
@`+(Z.systemId||"")+"#[line:"+Z.lineNumber+",col:"+Z.columnNumber+"]"}function _toString(Z,X,K){return typeof Z=="string"?Z.substr(X,K):Z.length>=X+K||X?new java.lang.String(Z,X,K)+"":Z}"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(Z){DOMHandler.prototype[Z]=function(){return null}});function appendElement(Z,X){Z.currentElement?Z.currentElement.appendChild(X):Z.doc.appendChild(X)}var __DOMHandler=DOMHandler,normalizeLineEndings_1=normalizeLineEndings,DOMParser_1=DOMParser$2,domParser={__DOMHandler,normalizeLineEndings:normalizeLineEndings_1,DOMParser:DOMParser_1},DOMImplementation=dom.DOMImplementation,XMLSerializer$1=dom.XMLSerializer,DOMParser$1=domParser.DOMParser,lib={DOMImplementation,XMLSerializer:XMLSerializer$1,DOMParser:DOMParser$1};const WebWorkerAdapter={createCanvas:(Z,X)=>new OffscreenCanvas(Z!=null?Z:0,X!=null?X:0),getCanvasRenderingContext2D:()=>OffscreenCanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>globalThis.location.href,getFontFaceSet:()=>globalThis.fonts,fetch:(Z,X)=>fetch(Z,X),parseXML:Z=>new DOMParser$1().parseFromString(Z,"text/xml")};var webworkerAll={__proto__:null},u$f=Object.defineProperty,d$e=Object.getOwnPropertySymbols,p$j=Object.prototype.hasOwnProperty,b$b=Object.prototype.propertyIsEnumerable,l$d=(Z,X,K)=>X in Z?u$f(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$l=(Z,X)=>{for(var K in X||(X={}))p$j.call(X,K)&&l$d(Z,K,X[K]);if(d$e)for(var K of d$e(X))b$b.call(X,K)&&l$d(Z,K,X[K]);return Z};const n$i=class extends Shader{constructor(Z){var X;Z=a$l(a$l({},n$i.defaultOptions),Z),super(Z),this.enabled=!0,this._state=State.for2d(),this.padding=Z.padding,typeof Z.antialias=="boolean"?this.antialias=Z.antialias?"on":"off":this.antialias=(X=Z.antialias)!=null?X:"inherit",this.resolution=Z.resolution,this.blendRequired=Z.blendRequired,this.addResource("filterUniforms",0,0),this.addResource("uSampler",0,1)}apply(Z,X,K,J){Z.applyFilter(this,X,K,J)}get blendMode(){return this._state.blendMode}set blendMode(Z){this._state.blendMode=Z}};let Filter=n$i;Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"inherit",blendRequired:!1};var M$4=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 fragColor;

uniform float uBlend;

uniform sampler2D uSampler;
uniform sampler2D backTexture;

{FUNCTIONS}

void main()
{ 
    vec4 back = texture(backTexture, vTextureCoord);
    vec4 front = texture(uSampler, vTextureCoord);

    {MAIN}
}
`,B$1=`in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 backgroundUv;

uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 backgroundFrame;
uniform vec4 outputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,O$5=`
struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct BlendUniforms {
  uBlend:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var backTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

{FUNCTIONS}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>
) -> @location(0) vec4<f32> {


   var back =  textureSample(backTexture, mySampler, uv);
   var front = textureSample(uSampler, mySampler, uv);
   
   var out = vec4<f32>(0.0,0.0,0.0,0.0);

   {MAIN}

   return out;
}`,a$k=Object.defineProperty,i$a=Object.getOwnPropertySymbols,f$g=Object.prototype.hasOwnProperty,d$d=Object.prototype.propertyIsEnumerable,s$k=(Z,X,K)=>X in Z?a$k(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$9=(Z,X)=>{for(var K in X||(X={}))f$g.call(X,K)&&s$k(Z,K,X[K]);if(i$a)for(var K of i$a(X))d$d.call(X,K)&&s$k(Z,K,X[K]);return Z};class BlendModeFilter extends Filter{constructor(X){const K=X.gpu,J=m$c(o$9({source:O$5},K)),Q=new GpuProgram({vertex:{source:J,entryPoint:"mainVertex"},fragment:{source:J,entryPoint:"mainFragment"}}),ee=X.gl,te=m$c(o$9({source:M$4},ee)),re=new GlProgram({vertex:B$1,fragment:te}),ne=new UniformGroup({uBlend:{value:1,type:"f32"}});super({gpuProgram:Q,glProgram:re,blendRequired:!0,resources:{blendUniforms:ne,backTexture:Texture.EMPTY}})}}function m$c(Z){const{source:X,functions:K,main:J}=Z;return X.replace("{FUNCTIONS}",K).replace("{MAIN}",J)}const hslgl=`
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `,hslgpu=`
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;class ColorBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}ColorBlend.extension={name:"color",type:u$z.BlendMode};class ColorBurnBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}ColorBurnBlend.extension={name:"color-burn",type:u$z.BlendMode};class ColorDodgeBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}ColorDodgeBlend.extension={name:"color-dodge",type:u$z.BlendMode};class DarkenBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}DarkenBlend.extension={name:"darken",type:u$z.BlendMode};class DifferenceBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}DifferenceBlend.extension={name:"difference",type:u$z.BlendMode};class DivideBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}DivideBlend.extension={name:"divide",type:u$z.BlendMode};class ExclusionBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}ExclusionBlend.extension={name:"exclusion",type:u$z.BlendMode};class HardLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}HardLightBlend.extension={name:"hard-light",type:u$z.BlendMode};class HardMixBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}HardMixBlend.extension={name:"hard-mix",type:u$z.BlendMode};class LightenBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LightenBlend.extension={name:"lighten",type:u$z.BlendMode};class LinearBurnBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}LinearBurnBlend.extension={name:"linear-burn",type:u$z.BlendMode};class LinearDodgeBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LinearDodgeBlend.extension={name:"linear-dodge",type:u$z.BlendMode};class LinearLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LinearLightBlend.extension={name:"linear-light",type:u$z.BlendMode};class LuminosityBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LuminosityBlend.extension={name:"luminosity",type:u$z.BlendMode};class NegationBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}NegationBlend.extension={name:"negation",type:u$z.BlendMode};class OverlayBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}OverlayBlend.extension={name:"overlay",type:u$z.BlendMode};class PinLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}PinLightBlend.extension={name:"pin-light",type:u$z.BlendMode};class SaturationBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}SaturationBlend.extension={name:"saturation",type:u$z.BlendMode};class SoftLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}SoftLightBlend.extension={name:"soft-light",type:u$z.BlendMode};class SubtractBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}SubtractBlend.extension={name:"subtract",type:u$z.BlendMode};class VividLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}VividLightBlend.extension={name:"vivid-light",type:u$z.BlendMode},b$r.add(ColorBlend,ColorBurnBlend,ColorDodgeBlend,DarkenBlend,DifferenceBlend,DivideBlend,ExclusionBlend,HardLightBlend,HardMixBlend,LightenBlend,LinearBurnBlend,LinearLightBlend,LinearDodgeBlend,LuminosityBlend,NegationBlend,OverlayBlend,PinLightBlend,SaturationBlend,SoftLightBlend,SubtractBlend,VividLightBlend);var P$4=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 outputTexture;
// uniform vec4 globalFrame;
// uniform float flipped;


vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,y$7=`
in vec2 vTextureCoord;

out vec4 fragColor;

uniform float uAlpha;
uniform sampler2D uSampler;

void main()
{
    fragColor =  texture(uSampler, vTextureCoord) * uAlpha;
}
`,s$j=`struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uSampler, mySampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`,f$f=Object.defineProperty,h$h=Object.defineProperties,c$g=Object.getOwnPropertyDescriptors,i$9=Object.getOwnPropertySymbols,g$b=Object.prototype.hasOwnProperty,O$4=Object.prototype.propertyIsEnumerable,n$h=(Z,X,K)=>X in Z?f$f(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$8=(Z,X)=>{for(var K in X||(X={}))g$b.call(X,K)&&n$h(Z,K,X[K]);if(i$9)for(var K of i$9(X))O$4.call(X,K)&&n$h(Z,K,X[K]);return Z},p$i=(Z,X)=>h$h(Z,c$g(X));const a$j=class extends Filter{constructor(Z){Z=o$8(o$8({},a$j.defaultOptions),Z);const X=new GpuProgram({vertex:{source:s$j,entryPoint:"mainVertex"},fragment:{source:s$j,entryPoint:"mainFragment"}}),K=new GlProgram({vertex:P$4,fragment:y$7,name:"alpha-filter"}),J=new UniformGroup({uAlpha:{value:Z.alpha,type:"f32"}});super({gpuProgram:X,glProgram:K,resources:{alphaUniforms:J}})}get alpha(){return this.resources.alphaUniforms.uniforms.uAlpha}set alpha(Z){this.resources.alphaUniforms.uniforms.uAlpha=Z}};let AlphaFilter=a$j;AlphaFilter.defaultOptions=p$i(o$8({},Filter.defaultOptions),{alpha:1});const GAUSSIAN_VALUES={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]},g$a=["in vec2 vBlurTexCoords[%size%];","uniform sampler2D uSampler;","out vec4 fragColor;","void main(void)","{","    fragColor = vec4(0.0);","    %blur%","}"].join(`
`);function generateBlurFragSource(Z){const X=GAUSSIAN_VALUES[Z],K=X.length;let J=g$a,Q="";const ee="fragColor += texture(uSampler, vBlurTexCoords[%index%]) * %value%;";let te;for(let re=0;re<Z;re++){let ne=ee.replace("%index%",re.toString());te=re,re>=K&&(te=Z-re-1),ne=ne.replace("%value%",X[te].toString()),Q+=ne,Q+=`
`}return J=J.replace("%blur%",Q),J=J.replace("%size%",Z.toString()),J}const p$h=`
    in vec2 aPosition;

    uniform float strength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;
    uniform vec4 inputPixel;
    uniform vec4 outputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = inputSize.%dimension% * strength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;function generateBlurVertSource(Z,X){const K=Math.ceil(Z/2);let J=p$h,Q="",ee;X?ee="vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);":ee="vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";for(let te=0;te<Z;te++){let re=ee.replace("%index%",te.toString());re=re.replace("%sampleIndex%",`${te-(K-1)}.0`),Q+=re,Q+=`
`}return J=J.replace("%blur%",Q),J=J.replace("%size%",Z.toString()),J=J.replace("%dimension%",X?"z":"w"),J}function generateBlurGlProgram(Z,X){const K=generateBlurVertSource(X,Z),J=generateBlurFragSource(X);return GlProgram.from({vertex:K,fragment:J,name:`blur-${Z?"horizontal":"vertical"}-pass-filter`})}var b$a=`

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct BlurUniforms {
  strength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.globalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let strength = gfu.inputSize.w * blurUniforms.strength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   fragColor = vec4(0.0);

    %blur-sampling%

    return fragColor;
}`;function generateBlurProgram(Z,X){const K=GAUSSIAN_VALUES[X],J=K.length,Q=[],ee=[],te=[];for(let oe=0;oe<X;oe++){Q[oe]=`@location(${oe}) offset${oe}: vec2<f32>,`,Z?ee[oe]=`filteredCord + vec2(${oe-J+1} * strength, 0.0),`:ee[oe]=`filteredCord + vec2(0.0, ${oe-J+1} * strength),`;const ae=oe<J?oe:X-oe-1,le=K[ae].toString();te[oe]=`fragColor += textureSample(uSampler, mySampler, offset${oe}) * ${le};`}const re=Q.join(`
`),ne=ee.join(`
`),ie=te.join(`
`),se=b$a.replace("%blur-struct%",re).replace("%blur-vertex-out%",ne).replace("%blur-fragment-in%",re).replace("%blur-sampling%",ie);return GpuProgram.from({vertex:{source:se,entryPoint:"mainVertex"},fragment:{source:se,entryPoint:"mainFragment"}})}var d$c=Object.defineProperty,h$g=Object.getOwnPropertySymbols,g$9=Object.prototype.hasOwnProperty,c$f=Object.prototype.propertyIsEnumerable,y$6=(Z,X,K)=>X in Z?d$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$g=(Z,X)=>{for(var K in X||(X={}))g$9.call(X,K)&&y$6(Z,K,X[K]);if(h$g)for(var K of h$g(X))c$f.call(X,K)&&y$6(Z,K,X[K]);return Z};const a$i=class extends Filter{constructor(Z){Z=n$g(n$g({},a$i.defaultOptions),Z);const X=generateBlurGlProgram(Z.horizontal,Z.kernelSize),K=generateBlurProgram(Z.horizontal,Z.kernelSize);super(n$g({glProgram:X,gpuProgram:K,resources:{blurUniforms:{strength:{value:0,type:"f32"}}}},Z)),this.horizontal=Z.horizontal,this._quality=0,this.quality=Z.quality,this.blur=Z.strength,this._uniforms=this.resources.blurUniforms.uniforms}apply(Z,X,K,J){if(this._uniforms.strength=this.strength/this.passes,this.passes===1)Z.applyFilter(this,X,K,J);else{const Q=TexturePool.getSameSizeTexture(X);let ee=X,te=Q;this._state.blend=!1;for(let re=0;re<this.passes-1;re++){Z.applyFilter(this,ee,te,Z.renderer.type===RendererType.WEBGPU);const ne=te;te=ee,ee=ne}this._state.blend=!0,Z.applyFilter(this,ee,K,J),TexturePool.returnTexture(Q)}}get blur(){return this.strength}set blur(Z){this.padding=1+Math.abs(Z)*2,this.strength=Z}get quality(){return this._quality}set quality(Z){this._quality=Z,this.passes=Z}};let BlurFilterPass=a$i;BlurFilterPass.defaultOptions={strength:8,quality:4,kernelSize:5};var y$5=Object.defineProperty,g$8=Object.defineProperties,c$e=Object.getOwnPropertyDescriptors,a$h=Object.getOwnPropertySymbols,f$e=Object.prototype.hasOwnProperty,x$8=Object.prototype.propertyIsEnumerable,p$g=(Z,X,K)=>X in Z?y$5(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$e=(Z,X)=>{for(var K in X||(X={}))f$e.call(X,K)&&p$g(Z,K,X[K]);if(a$h)for(var K of a$h(X))x$8.call(X,K)&&p$g(Z,K,X[K]);return Z},d$b=(Z,X)=>g$8(Z,c$e(X));class BlurFilter extends Filter{constructor(...X){var K;let J=(K=X[0])!=null?K:{};typeof J=="number"&&(deprecation(v8_0_0,"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"),J={strength:J},X[1]&&(J.quality=X[1]),X[2]&&(J.resolution=X[2]),X[3]&&(J.kernelSize=X[3])),J=u$e(u$e({},BlurFilterPass.defaultOptions),J),super(d$b(u$e({},J),{compatibleRenderers:RendererType.WEBGL|RendererType.WEBGPU,resources:{}})),this._repeatEdgePixels=!1,this.blurXFilter=new BlurFilterPass(u$e({horizontal:!1},J)),this.blurYFilter=new BlurFilterPass(u$e({horizontal:!0},J)),this.quality=J.quality,this.blur=J.strength,this.repeatEdgePixels=!1}apply(X,K,J,Q){const ee=Math.abs(this.blurXFilter.strength),te=Math.abs(this.blurYFilter.strength);if(ee&&te){const re=TexturePool.getSameSizeTexture(K);this.blurXFilter.apply(X,K,re,!0),this.blurYFilter.apply(X,re,J,Q),TexturePool.returnTexture(re)}else te?this.blurYFilter.apply(X,K,J,Q):this.blurXFilter.apply(X,K,J,Q)}updatePadding(){this._repeatEdgePixels?this.padding=0:this.padding=Math.max(Math.abs(this.blurXFilter.blur),Math.abs(this.blurYFilter.blur))*2}get blur(){return this.blurXFilter.blur}set blur(X){this.blurXFilter.blur=this.blurYFilter.blur=X,this.updatePadding()}get quality(){return this.blurXFilter.quality}set quality(X){this.blurXFilter.quality=this.blurYFilter.quality=X}get blurX(){return this.blurXFilter.blur}set blurX(X){this.blurXFilter.blur=X,this.updatePadding()}get blurY(){return this.blurYFilter.blur}set blurY(X){this.blurYFilter.blur=X,this.updatePadding()}get blendMode(){return this.blurYFilter.blendMode}set blendMode(X){this.blurYFilter.blendMode=X}get repeatEdgePixels(){return this._repeatEdgePixels}set repeatEdgePixels(X){this._repeatEdgePixels=X,this.updatePadding()}}BlurFilter.defaultOptions={strength:8,quality:4,kernelSize:5};var F=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 fragColor;

uniform float uColorMatrix[20];
uniform float uAlpha;

uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;
    
    float[20] cm = uColorMatrix;


    if (uAlpha == 0.0) {
        fragColor = color;
        return;
    }

    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    vec4 result;

    result.r = (cm[0] * color.r);
        result.r += (cm[1] * color.g);
        result.r += (cm[2] * color.b);
        result.r += (cm[3] * color.a);
        result.r += cm[4];

    result.g = (cm[5] * color.r);
        result.g += (cm[6] * color.g);
        result.g += (cm[7] * color.b);
        result.g += (cm[8] * color.a);
        result.g += cm[9];

    result.b = (cm[10] * color.r);
       result.b += (cm[11] * color.g);
       result.b += (cm[12] * color.b);
       result.b += (cm[13] * color.a);
       result.b += cm[14];

    result.a = (cm[15] * color.r);
       result.a += (cm[16] * color.g);
       result.a += (cm[17] * color.b);
       result.a += (cm[18] * color.a);
       result.a += cm[19];

    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    fragColor = vec4(rgb, result.a);
}
`,d$a=`struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct ColorMatrixUniforms {
  uColorMatrix:array<vec4<f32>, 5>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var backTexture: texture_2d<f32>;
@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
  };
  
fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
  );
}


@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {


  var c = textureSample(uSampler, mySampler, uv);
  
  if (colorMatrixUniforms.uAlpha == 0.0) {
    return c;
  }

 
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.r /= c.a;
      c.g /= c.a;
      c.b /= c.a;
    }

    var cm = colorMatrixUniforms.uColorMatrix;


    var result = vec4<f32>(0.);

    result.r = (cm[0][0] * c.r);
    result.r += (cm[0][1] * c.g);
    result.r += (cm[0][2] * c.b);
    result.r += (cm[0][3] * c.a);
    result.r += cm[1][0];

    result.g = (cm[1][1] * c.r);
    result.g += (cm[1][2] * c.g);
    result.g += (cm[1][3] * c.b);
    result.g += (cm[2][0] * c.a);
    result.g += cm[2][1];

    result.b = (cm[2][2] * c.r);
    result.b += (cm[2][3] * c.g);
    result.b += (cm[3][0] * c.b);
    result.b += (cm[3][1] * c.a);
    result.b += cm[3][2];

    result.a = (cm[3][3] * c.r);
    result.a += (cm[4][0] * c.g);
    result.a += (cm[4][1] * c.b);
    result.a += (cm[4][2] * c.a);
    result.a += cm[4][3];

    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);

    rgb.r *= result.a;
    rgb.g *= result.a;
    rgb.b *= result.a;

    return vec4(rgb, result.a);
}`;class ColorMatrixFilter extends Filter{constructor(){const X=new UniformGroup({uColorMatrix:{value:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],type:"vec4<f32>",size:5},uAlpha:{value:1,type:"f32"}}),K=GpuProgram.from({vertex:{source:d$a,entryPoint:"mainVertex"},fragment:{source:d$a,entryPoint:"mainFragment"}}),J=GlProgram.from({vertex:P$4,fragment:F,name:"color-matrix-filter"});super({gpuProgram:K,glProgram:J,resources:{colorMatrixUniforms:X}}),this.alpha=1}_loadMatrix(X,K=!1){let J=X;K&&(this._multiply(J,this.matrix,X),J=this._colorMatrix(J)),this.resources.colorMatrixUniforms.uniforms.uColorMatrix=J,this.resources.colorMatrixUniforms.update()}_multiply(X,K,J){return X[0]=K[0]*J[0]+K[1]*J[5]+K[2]*J[10]+K[3]*J[15],X[1]=K[0]*J[1]+K[1]*J[6]+K[2]*J[11]+K[3]*J[16],X[2]=K[0]*J[2]+K[1]*J[7]+K[2]*J[12]+K[3]*J[17],X[3]=K[0]*J[3]+K[1]*J[8]+K[2]*J[13]+K[3]*J[18],X[4]=K[0]*J[4]+K[1]*J[9]+K[2]*J[14]+K[3]*J[19]+K[4],X[5]=K[5]*J[0]+K[6]*J[5]+K[7]*J[10]+K[8]*J[15],X[6]=K[5]*J[1]+K[6]*J[6]+K[7]*J[11]+K[8]*J[16],X[7]=K[5]*J[2]+K[6]*J[7]+K[7]*J[12]+K[8]*J[17],X[8]=K[5]*J[3]+K[6]*J[8]+K[7]*J[13]+K[8]*J[18],X[9]=K[5]*J[4]+K[6]*J[9]+K[7]*J[14]+K[8]*J[19]+K[9],X[10]=K[10]*J[0]+K[11]*J[5]+K[12]*J[10]+K[13]*J[15],X[11]=K[10]*J[1]+K[11]*J[6]+K[12]*J[11]+K[13]*J[16],X[12]=K[10]*J[2]+K[11]*J[7]+K[12]*J[12]+K[13]*J[17],X[13]=K[10]*J[3]+K[11]*J[8]+K[12]*J[13]+K[13]*J[18],X[14]=K[10]*J[4]+K[11]*J[9]+K[12]*J[14]+K[13]*J[19]+K[14],X[15]=K[15]*J[0]+K[16]*J[5]+K[17]*J[10]+K[18]*J[15],X[16]=K[15]*J[1]+K[16]*J[6]+K[17]*J[11]+K[18]*J[16],X[17]=K[15]*J[2]+K[16]*J[7]+K[17]*J[12]+K[18]*J[17],X[18]=K[15]*J[3]+K[16]*J[8]+K[17]*J[13]+K[18]*J[18],X[19]=K[15]*J[4]+K[16]*J[9]+K[17]*J[14]+K[18]*J[19]+K[19],X}_colorMatrix(X){const K=new Float32Array(X);return K[4]/=255,K[9]/=255,K[14]/=255,K[19]/=255,K}brightness(X,K){const J=[X,0,0,0,0,0,X,0,0,0,0,0,X,0,0,0,0,0,1,0];this._loadMatrix(J,K)}tint(X,K){const[J,Q,ee]=Color.shared.setValue(X).toArray(),te=[J,0,0,0,0,0,Q,0,0,0,0,0,ee,0,0,0,0,0,1,0];this._loadMatrix(te,K)}greyscale(X,K){const J=[X,X,X,0,0,X,X,X,0,0,X,X,X,0,0,0,0,0,1,0];this._loadMatrix(J,K)}grayscale(X,K){this.greyscale(X,K)}blackAndWhite(X){const K=[.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0];this._loadMatrix(K,X)}hue(X,K){X=(X||0)/180*Math.PI;const J=Math.cos(X),Q=Math.sin(X),ee=Math.sqrt,te=1/3,re=ee(te),ne=J+(1-J)*te,ie=te*(1-J)-re*Q,se=te*(1-J)+re*Q,oe=te*(1-J)+re*Q,ae=J+te*(1-J),le=te*(1-J)-re*Q,ce=te*(1-J)-re*Q,de=te*(1-J)+re*Q,he=J+te*(1-J),pe=[ne,ie,se,0,0,oe,ae,le,0,0,ce,de,he,0,0,0,0,0,1,0];this._loadMatrix(pe,K)}contrast(X,K){const J=(X||0)+1,Q=-.5*(J-1),ee=[J,0,0,0,Q,0,J,0,0,Q,0,0,J,0,Q,0,0,0,1,0];this._loadMatrix(ee,K)}saturate(X=0,K){const J=X*2/3+1,Q=(J-1)*-.5,ee=[J,Q,Q,0,0,Q,J,Q,0,0,Q,Q,J,0,0,0,0,0,1,0];this._loadMatrix(ee,K)}desaturate(){this.saturate(-1)}negative(X){const K=[-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0];this._loadMatrix(K,X)}sepia(X){const K=[.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0];this._loadMatrix(K,X)}technicolor(X){const K=[1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0];this._loadMatrix(K,X)}polaroid(X){const K=[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0];this._loadMatrix(K,X)}toBGR(X){const K=[0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0];this._loadMatrix(K,X)}kodachrome(X){const K=[1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0];this._loadMatrix(K,X)}browni(X){const K=[.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0];this._loadMatrix(K,X)}vintage(X){const K=[.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0];this._loadMatrix(K,X)}colorTone(X,K,J,Q,ee){X=X||.2,K=K||.15,J=J||16770432,Q=Q||3375104;const te=Color.shared,[re,ne,ie]=te.setValue(J).toArray(),[se,oe,ae]=te.setValue(Q).toArray(),le=[.3,.59,.11,0,0,re,ne,ie,X,0,se,oe,ae,K,0,re-se,ne-oe,ie-ae,0,0];this._loadMatrix(le,ee)}night(X,K){X=X||.1;const J=[X*-2,-X,0,0,0,-X,0,X,0,0,0,X,X*2,0,0,0,0,0,1,0];this._loadMatrix(J,K)}predator(X,K){const J=[11.224130630493164*X,-4.794486999511719*X,-2.8746118545532227*X,0*X,.40342438220977783*X,-3.6330697536468506*X,9.193157196044922*X,-2.951810836791992*X,0*X,-1.316135048866272*X,-3.2184197902679443*X,-4.2375030517578125*X,7.476448059082031*X,0*X,.8044459223747253*X,0,0,0,1,0];this._loadMatrix(J,K)}lsd(X){const K=[2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0];this._loadMatrix(K,X)}reset(){const X=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this._loadMatrix(X,!1)}get matrix(){return this.resources.colorMatrixUniforms.uniforms.uColorMatrix}set matrix(X){this.resources.colorMatrixUniforms.uniforms.uColorMatrix=X}get alpha(){return this.resources.colorMatrixUniforms.uniforms.uAlpha}set alpha(X){this.resources.colorMatrixUniforms.uniforms.uAlpha=X}}var h$f=`
in vec2 vTextureCoord;
in vec2 vFilterUv;

out vec4 fragColor;

uniform sampler2D uSampler;
uniform sampler2D mapTexture;

uniform vec4 filterArea;
uniform vec4 filterClamp;
uniform vec4 inputClamp;
uniform highp vec4 inputSize;
uniform mat2 rotation;
uniform vec2 scale;


void main()
{
vec4 map = texture(mapTexture, vFilterUv);
    
    vec2 offset = inputSize.zw * (rotation * (map.xy - 0.5)) * scale; 

    fragColor = texture(uSampler, clamp(vTextureCoord + offset, inputClamp.xy, inputClamp.zw));
}
`,S$2=`in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 vFilterUv;


uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 outputTexture;

uniform mat3 filterMatrix;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

vec2 getFilterCoord( void )
{
  return ( filterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;
}


void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
    vFilterUv = getFilterCoord();
}
`,p$f=`
struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct DisplacementUniforms {
  filterMatrix:mat3x3<f32>,
  scale:vec2<f32>,
  rotation:mat2x2<f32>
};



@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;
@group(1) @binding(1) var mapTexture: texture_2d<f32>;
@group(1) @binding(2) var mapSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var map = textureSample(mapTexture, mapSampler, filterUv);
    
    var offset =  gfu.inputSize.zw * (filterUniforms.rotation * (map.xy - 0.5)) * filterUniforms.scale; 
   
     return textureSample(uSampler, mySampler, clamp(uv + offset, gfu.inputClamp.xy, gfu.inputClamp.zw));
}`;class DisplacementFilter extends Filter{constructor(...X){var K;let J=X[0];J instanceof Sprite&&(X[1]&&deprecation(v8_0_0,"DisplacementFilter now uses options object instead of params. {sprite, scale}"),J={sprite:J,scale:X[1]});let Q=(K=J.scale)!=null?K:20;typeof Q=="number"&&(Q=new Point(Q,Q));const ee=new UniformGroup({filterMatrix:{value:new Matrix,type:"mat3x3<f32>"},scale:{value:Q,type:"vec2<f32>"},rotation:{value:new Float32Array([0,0,0,0]),type:"vec4<f32>"}}),te=GlProgram.from({vertex:S$2,fragment:h$f,name:"displacement-filter"}),re=GpuProgram.from({vertex:{source:p$f,entryPoint:"mainVertex"},fragment:{source:p$f,entryPoint:"mainFragment"}}),ne=J.sprite.texture.source;super({gpuProgram:re,glProgram:te,resources:{filterUniforms:ee,mapTexture:ne,mapSampler:ne.style}}),this._sprite=J.sprite,this._sprite.renderable=!1}apply(X,K,J,Q){const ee=this.resources.filterUniforms.uniforms;X.calculateSpriteMatrix(ee.filterMatrix,this._sprite);const te=this._sprite.worldTransform,re=Math.sqrt(te.a*te.a+te.b*te.b),ne=Math.sqrt(te.c*te.c+te.d*te.d);re!==0&&ne!==0&&(ee.rotation[0]=te.a/re,ee.rotation[1]=te.b/re,ee.rotation[2]=te.c/ne,ee.rotation[3]=te.d/ne),this.resources.mapTexture=this._sprite.texture.source,X.applyFilter(this,K,J,Q)}get scale(){return this.resources.filterUniforms.uniforms.scale}}var U=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 fragColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    fragColor = color;
}
`,f$d=`

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var backTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.outputFrame.xy);
  
    
    var sample = textureSample(uSampler, mySampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`,p$e=Object.defineProperty,t$4=Object.getOwnPropertySymbols,g$7=Object.prototype.hasOwnProperty,l$c=Object.prototype.propertyIsEnumerable,m$b=(Z,X,K)=>X in Z?p$e(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$d=(Z,X)=>{for(var K in X||(X={}))g$7.call(X,K)&&m$b(Z,K,X[K]);if(t$4)for(var K of t$4(X))l$c.call(X,K)&&m$b(Z,K,X[K]);return Z};class NoiseFilter extends Filter{constructor(X={}){var K,J,Q;X=u$d({noise:.5,seed:Math.random()},X);const ee=new GpuProgram({vertex:{source:f$d,entryPoint:"mainVertex"},fragment:{source:f$d,entryPoint:"mainFragment"}}),te=new GlProgram({vertex:P$4,fragment:U,name:"noise-filter"});super({gpuProgram:ee,glProgram:te,resources:{noiseUniforms:new UniformGroup({uNoise:{value:X.noise,type:"f32"},uSeed:{value:(K=X.seed)!=null?K:Math.random(),type:"f32"}})},resolution:1});const re=(J=X.noise)!=null?J:.5,ne=(Q=X.seed)!=null?Q:Math.random();this.noise=re,this.seed=ne}get noise(){return this.resources.noiseUniforms.uniforms.uNoise}set noise(X){this.resources.noiseUniforms.uniforms.uNoise=X}get seed(){return this.resources.noiseUniforms.uniforms.uSeed}set seed(X){this.resources.noiseUniforms.uniforms.uSeed=X}}var P$3=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform vec4 inputSize;
uniform vec4 inputClamp;

out vec4 fragColor;

uniform vec2 uCenter;
uniform float uTime;
uniform float uSpeed;
uniform vec4 uWave;

uniform sampler2D uSampler;


const float PI = 3.14159;

void main()
{
    float uAmplitude = uWave[0];
    float uWavelength = uWave[1];
    float uBrightness = uWave[2];
    float uRadius = uWave[3];

    float halfWavelength = uWavelength * 0.5 / inputSize.x;
    float maxRadius = uRadius / inputSize.x;
    float currentRadius = uTime * uSpeed / inputSize.x;

    float fade = 1.0;

    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            fragColor = texture(uSampler, vTextureCoord);
            return;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }

    vec2 dir = vec2(vTextureCoord - uCenter / inputSize.xy);
    dir.y *= inputSize.y / inputSize.x;
    float dist = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        fragColor = texture(uSampler, vTextureCoord);
        return;
    }

    vec2 diffUV = normalize(dir);

    float diff = (dist - currentRadius) / halfWavelength;

    float p = 1.0 - pow(abs(diff), 2.0);

    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );
    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );

    vec2 offset = diffUV * powDiff / inputSize.xy;

    // Do clamp :
    vec2 coord = vTextureCoord + offset;
    vec2 clampedCoord = clamp(coord, inputClamp.xy, inputClamp.zw);
    vec4 color = texture(uSampler, clampedCoord);
    if (coord != clampedCoord) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    // No clamp :
    // fragColor = texture(uSampler, vTextureCoord + offset);

    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;

    fragColor = color;
}
`,w$4=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,f$c=`
struct GlobalFilterUniforms {
    inputSize:vec4<f32>,
    inputPixel:vec4<f32>,
    inputClamp:vec4<f32>,
    outputFrame:vec4<f32>,
    backgroundFrame:vec4<f32>,
    globalFrame:vec4<f32>,
};

struct ShockWaveUniforms {
    uTime: f32,
    uOffset: vec2<f32>,
    uSpeed: f32,
    uWave: vec4<f32>,
};
@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(1) @binding(1) var uSampler: texture_2d<f32>;
@group(1) @binding(2) var mySampler : sampler;
@group(1) @binding(3) var backTexture: texture_2d<f32>;
@group(2) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) backgroundUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;
    return vec4((globalUniforms.projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * gfu.backgroundFrame.zw;
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}
fn getSize() -> vec2<f32>
{
    return gfu.globalFrame.zw;
}

@vertex
fn mainVertex(
    @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
    return VSOutput(
        filterVertexPosition(aPosition),
        filterTextureCoord(aPosition),
        filterBackgroundTextureCoord(aPosition),
    );
}

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @location(1) backgroundUv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    let uTime = shockwaveUniforms.uTime;
    let uOffset = shockwaveUniforms.uOffset;
    let uSpeed = shockwaveUniforms.uSpeed;
    let uAmplitude = shockwaveUniforms.uWave[0];
    let uWavelength = shockwaveUniforms.uWave[1];
    let uBrightness = shockwaveUniforms.uWave[2];
    let uRadius = shockwaveUniforms.uWave[3];
    let halfWavelength: f32 = uWavelength * 0.5 / gfu.inputSize.x;
    let maxRadius: f32 = uRadius / gfu.inputSize.x;
    let currentRadius: f32 = uTime * uSpeed / gfu.inputSize.x;
    var fade: f32 = 1.0;
    var returnColorOnly: bool = false;
    
    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            returnColorOnly = true;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }
    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.inputSize.xy);
    dir.y *= gfu.inputSize.y / gfu.inputSize.x;

    let dist:f32 = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        returnColorOnly = true;
    }

    let diffUV: vec2<f32> = normalize(dir);
    let diff: f32 = (dist - currentRadius) / halfWavelength;
    let p: f32 = 1.0 - pow(abs(diff), 2.0);
    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );
    let offset: vec2<f32> = diffUV * powDiff / gfu.inputSize.xy;
    // Do clamp :
    let coord: vec2<f32> = uv + offset;
    let clampedCoord: vec2<f32> = clamp(coord, gfu.inputClamp.xy, gfu.inputClamp.zw);

    var clampedColor: vec4<f32> = textureSample(uSampler, mySampler, clampedCoord);
    
    if (boolVec2(coord, clampedCoord)) 
    {
        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));
    }
    // No clamp :
    return select(clampedColor * vec4<f32>(vec3<f32>(1.0 + (uBrightness - 1.0) * p * fade), clampedColor.a), textureSample(uSampler, mySampler, uv), returnColorOnly);
}

fn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool
{
    if (x.x == y.x && x.y == y.y)
    {
        return true;
    }
    
    return false;
}

const PI: f32 = 3.14159265358979323846264;
`,h$e=Object.defineProperty,d$9=Object.defineProperties,b$9=Object.getOwnPropertyDescriptors,m$a=Object.getOwnPropertySymbols,c$d=Object.prototype.hasOwnProperty,g$6=Object.prototype.propertyIsEnumerable,o$7=(Z,X,K)=>X in Z?h$e(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$f=(Z,X)=>{for(var K in X||(X={}))c$d.call(X,K)&&o$7(Z,K,X[K]);if(m$a)for(var K of m$a(X))g$6.call(X,K)&&o$7(Z,K,X[K]);return Z},a$g=(Z,X)=>d$9(Z,b$9(X));const s$i=class extends Filter{constructor(Z={}){Z=n$f(n$f({},s$i.defaultOptions),Z);const X=new GpuProgram({vertex:{source:f$c,entryPoint:"mainVertex"},fragment:{source:f$c,entryPoint:"mainFragment"}}),K=new GlProgram({vertex:w$4,fragment:P$3,name:"shockwave-filter"});super({gpuProgram:X,glProgram:K,resources:{shockwaveUniforms:new UniformGroup({uTime:{value:0,type:"f32"},uCenter:{value:Z.center,type:"vec2<f32>"},uSpeed:{value:Z.speed,type:"f32"},uWave:{value:new Float32Array(4),type:"vec4<f32>"}})},resolution:1}),this.time=0,this.uniforms=this.resources.shockwaveUniforms.uniforms,Object.assign(this,Z)}apply(Z,X,K,J){this.uniforms.uTime=this.time,Z.applyFilter(this,X,K,J)}get center(){return this.uniforms.uCenter}set center(Z){this.uniforms.uCenter=Z}get centerX(){return this.uniforms.uCenter.x}set centerX(Z){this.uniforms.uCenter.x=Z}get centerY(){return this.uniforms.uCenter.y}set centerY(Z){this.uniforms.uCenter.y=Z}get speed(){return this.uniforms.uSpeed}set speed(Z){this.uniforms.uSpeed=Z}get amplitude(){return this.uniforms.uWave[0]}set amplitude(Z){this.uniforms.uWave[0]=Z}get wavelength(){return this.uniforms.uWave[1]}set wavelength(Z){this.uniforms.uWave[1]=Z}get brightness(){return this.uniforms.uWave[2]}set brightness(Z){this.uniforms.uWave[2]=Z}get radius(){return this.uniforms.uWave[3]}set radius(Z){this.uniforms.uWave[3]=Z}};let ShockwaveFilter=s$i;ShockwaveFilter.defaultOptions=a$g(n$f({},Filter.defaultOptions),{center:{x:0,y:0},speed:500,amplitude:30,wavelength:160,brightness:1,radius:-1});var l$b=`in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mapTexture;

uniform float alpha;
uniform vec4 maskClamp;

out vec4 fragColor;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = alpha; 
    vec4 original = texture(uSampler, vTextureCoord);
    vec4 masky = texture(mapTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    fragColor = original;
}
`,f$b=`in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 outputTexture;
uniform mat3 filterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
       
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,o$6=`struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,  
};

struct MaskUniforms {
  filterMatrix:mat3x3<f32>,
  maskClamp:vec4<f32>,
  alpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var mapTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.maskClamp;

     var clip = step(3.5,
        step(maskClamp.x, filterUv.x) +
        step(maskClamp.y, filterUv.y) +
        step(filterUv.x, maskClamp.z) +
        step(filterUv.y, maskClamp.w));

    var mask = textureSample(mapTexture, mySampler, filterUv);
    var source = textureSample(uSampler, mySampler, uv);
    
    var npmAlpha = 0.0;

    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);

    var a = (alphaMul * mask.r) * clip;

    return vec4(source.rgb, source.a) * a;
}`;class MaskFilter extends Filter{constructor({sprite:X}){const K=new TextureMatrix(X.texture),J=new UniformGroup({filterMatrix:{value:new Matrix,type:"mat3x3<f32>"},maskClamp:{value:K.uClampFrame,type:"vec4<f32>"},alpha:{value:1,type:"f32"}}),Q=new GpuProgram({vertex:{source:o$6,entryPoint:"mainVertex"},fragment:{source:o$6,entryPoint:"mainFragment"}}),ee=GlProgram.from({vertex:f$b,fragment:l$b,name:"mask-filter"});super({gpuProgram:Q,glProgram:ee,resources:{filterUniforms:J,mapTexture:X.texture.source}}),this.sprite=X,this._textureMatrix=K}apply(X,K,J,Q){this._textureMatrix.texture=this.sprite.texture,X.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.filterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.mapTexture=this.sprite.texture.source,X.applyFilter(this,K,J,Q)}}const mixins={add(Z,X){return X||(X=new Point),X.x=this.x+Z.x,X.y=this.y+Z.y,X},subtract(Z,X){return X||(X=new Point),X.x=this.x-Z.x,X.y=this.y-Z.y,X},multiply(Z,X){return X||(X=new Point),X.x=this.x*Z.x,X.y=this.y*Z.y,X},multiplyScalar(Z,X){return X||(X=new Point),X.x=this.x*Z,X.y=this.y*Z,X},dot(Z){return this.x*Z.x+this.y*Z.y},cross(Z){return this.x*Z.y-this.y*Z.x},normalize(Z){Z||(Z=new Point);const X=Math.sqrt(this.x*this.x+this.y*this.y);return Z.x=this.x/X,Z.y=this.y/X,Z},magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)},magnitudeSquared(){return this.x*this.x+this.y*this.y},project(Z,X){X||(X=new Point);const K=(this.x*Z.x+this.y*Z.y)/(Z.x*Z.x+Z.y*Z.y);return X.x=Z.x*K,X.y=Z.y*K,X},reflect(Z,X){X||(X=new Point);const K=this.x*Z.x+this.y*Z.y;return X.x=this.x-2*K*Z.x,X.y=this.y-2*K*Z.y,X}};Rectangle.prototype.containsRect=function(Z){return Z.width<=0||Z.height<=0?Z.x>this.x&&Z.y>this.y&&Z.right<this.right&&Z.bottom<this.bottom:Z.x>=this.x&&Z.y>=this.y&&Z.right<=this.right&&Z.bottom<=this.bottom},Rectangle.prototype.equals=function(Z){return Z===this?!0:Z&&this.x===Z.x&&this.y===Z.y&&this.width===Z.width&&this.height===Z.height},Rectangle.prototype.intersection=function(Z,X){X||(X=new Rectangle);const K=this.x<Z.x?Z.x:this.x,J=this.right>Z.right?Z.right:this.right;if(J<=K)return X.x=X.y=X.width=X.height=0,X;const Q=this.y<Z.y?Z.y:this.y,ee=this.bottom>Z.bottom?Z.bottom:this.bottom;return ee<=Q?(X.x=X.y=X.width=X.height=0,X):(X.x=K,X.y=Q,X.width=J-K,X.height=ee-Q,X)},Rectangle.prototype.union=function(Z,X){X||(X=new Rectangle);const K=Math.min(this.x,Z.x),J=Math.max(this.x+this.width,Z.x+Z.width),Q=Math.min(this.y,Z.y),ee=Math.max(this.y+this.height,Z.y+Z.height);return X.x=K,X.y=Q,X.width=J-K,X.height=ee-Q,X},Object.assign(Point.prototype,mixins),Object.assign(ObservablePoint.prototype,mixins);function floatEqual(Z,X,K=Number.EPSILON){return Z===X?!0:Math.abs(Z-X)<K}function f$a(Z,X,K,J,Q,ee){ee||(ee=new Point);const te=X.x-Z.x,re=X.y-Z.y,ne=J.x-K.x,ie=J.y-K.y,se=ie*te-ne*re;if(floatEqual(se,0))return ee.x=NaN,ee.y=NaN,ee;const oe=(ne*(Z.y-K.y)-ie*(Z.x-K.x))/se,ae=(te*(Z.y-K.y)-re*(Z.x-K.x))/se;return!Q&&(oe<0||oe>1||ae<0||ae>1)?(ee.x=NaN,ee.y=NaN,ee):(ee.x=Z.x+oe*te,ee.y=K.y+ae*ie,ee)}function lineIntersection(Z,X,K,J,Q){return f$a(Z,X,K,J,!0,Q)}function segmentIntersection(Z,X,K,J,Q){return f$a(Z,X,K,J,!1,Q)}class Triangle{constructor(X=0,K=0,J=0,Q=0,ee=0,te=0){this.type="triangle",this.x=X,this.y=K,this.x2=J,this.y2=Q,this.x3=ee,this.y3=te}contains(X,K){const J=(this.x-this.x3)*(K-this.y3)-(this.y-this.y3)*(X-this.x3),Q=(this.x2-this.x)*(K-this.y)-(this.y2-this.y)*(X-this.x);if(J<0!=Q<0&&J!==0&&Q!==0)return!1;const ee=(this.x3-this.x2)*(K-this.y2)-(this.y3-this.y2)*(X-this.x2);return ee===0||ee<0==J+Q<=0}strokeContains(X,K,J){const Q=J/2,ee=Q*Q,{x:te,x2:re,x3:ne,y:ie,y2:se,y3:oe}=this;return squaredDistanceToLineSegment(X,K,te,ie,re,oe)<=ee||squaredDistanceToLineSegment(X,K,re,se,ne,oe)<=ee||squaredDistanceToLineSegment(X,K,ne,oe,te,ie)<=ee}clone(){return new Triangle(this.x,this.y,this.x2,this.y2,this.x3,this.y3)}copyFrom(X){return this.x=X.x,this.y=X.y,this.x2=X.x2,this.y2=X.y2,this.x3=X.x3,this.y3=X.y3,this}copyTo(X){return X.copyFrom(this),X}getBounds(X){X=X||new Rectangle;const K=Math.min(this.x,this.x2,this.x3),J=Math.max(this.x,this.x2,this.x3),Q=Math.min(this.y,this.y2,this.y3),ee=Math.max(this.y,this.y2,this.y3);return X.x=K,X.y=Q,X.width=J-K,X.height=ee-Q,X}}function textStyleToCSS(Z){const X=Z._stroke,K=Z._fill,J=[`div { ${[`color: ${Color.shared.setValue(K.color).toHex()}`,`font-size: ${Z.fontSize}px`,`font-family: ${Z.fontFamily}`,`font-weight: ${Z.fontWeight}`,`font-style: ${Z.fontStyle}`,`font-variant: ${Z.fontVariant}`,`letter-spacing: ${Z.letterSpacing}px`,`text-align: ${Z.align}`,`padding: ${Z.padding}px`,`white-space: ${Z.whiteSpace==="pre"&&Z.wordWrap?"pre-wrap":Z.whiteSpace}`,...Z.lineHeight?[`line-height: ${Z.lineHeight}px`]:[],...Z.wordWrap?[`word-wrap: ${Z.breakWords?"break-all":"break-word"}`,`max-width: ${Z.wordWrapWidth}px`]:[],...X?[p$d(X)]:[],...Z.dropShadow?[s$h(Z.dropShadow)]:[],...Z.cssOverrides].join(";")} }`];return c$c(Z.tagStyles,J),J.join(" ")}function s$h(Z){const X=Color.shared.setValue(Z.color).setAlpha(Z.alpha).toHexa(),K=Math.round(Math.cos(Z.angle)*Z.distance),J=Math.round(Math.sin(Z.angle)*Z.distance),Q=`${K}px ${J}px`;return Z.blur>0?`text-shadow: ${Q} ${Z.blur}px ${X}`:`text-shadow: ${Q} ${X}`}function p$d(Z){return[`-webkit-text-stroke-width: ${Z.width}px`,`-webkit-text-stroke-color: ${Color.shared.setValue(Z.color).toHex()}`,`text-stroke-width: ${Z.width}px`,`text-stroke-color: ${Color.shared.setValue(Z.color).toHex()}`,"paint-order: stroke"].join(";")}const f$9={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},l$a={fill:Z=>`color: ${Color.shared.setValue(Z).toHex()}`,breakWords:Z=>`word-wrap: ${Z?"break-all":"break-word"}`,stroke:p$d,dropShadow:s$h};function c$c(Z,X){for(const K in Z){const J=Z[K],Q=[];for(const ee in J)l$a[ee]?Q.push(l$a[ee](J[ee])):f$9[ee]&&Q.push(f$9[ee].replace("{{VALUE}}",J[ee]));X.push(`${K} { ${Q.join(";")} }`)}}class HTMLTextStyle extends TextStyle{constructor(X={}){var K,J;super(X),this._cssOverrides=[],(K=this.cssOverrides)!=null||(this.cssOverrides=X.cssOverrides),this.tagStyles=(J=X.tagStyles)!=null?J:{}}set cssOverrides(X){this._cssOverrides=X instanceof Array?X:[X],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=generateTextStyleKey(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new HTMLTextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=textStyleToCSS(this)),this._cssStyle}addOverride(...X){const K=X.filter(J=>!this.cssOverrides.includes(J));K.length>0&&(this.cssOverrides.push(...K),this.update())}removeOverride(...X){const K=X.filter(J=>this.cssOverrides.includes(J));K.length>0&&(this.cssOverrides=this.cssOverrides.filter(J=>!K.includes(J)),this.update())}set fill(X){super.fill=X}set stroke(X){super.stroke=X}}function detectRenderType(Z){if(Z instanceof HTMLTextStyle)return"html";const X=Cache.get(`${Z==null?void 0:Z.fontFamily}-bitmap`);return X instanceof DynamicBitmapFont||X instanceof BitmapFont?"bitmap":"canvas"}function ensureTextStyle(Z,X){return X instanceof TextStyle||X instanceof HTMLTextStyle?X:Z==="html"?new HTMLTextStyle(X):new TextStyle(X)}const T$5={canvas:"text",html:"htmlText",bitmap:"bitmapText"};class TextView{constructor(X){this.uid=uid("textView"),this.renderPipeId="text",this.owner=emptyViewObserver,this.batched=!0,this.resolution=null,this._didUpdate=!0,this.roundPixels=0,this._bounds={left:0,right:1,top:0,bottom:0},this._boundsDirty=!0;var K,J,Q;this.text=(K=X.text)!=null?K:"";const ee=(J=X.renderMode)!=null?J:detectRenderType(X.style);this._renderMode=ee,this.style=ensureTextStyle(ee,X.style),this.renderPipeId=T$5[ee],this.anchor=new ObservablePoint(this,0,0),this.resolution=(Q=X.resolution)!=null?Q:null}set text(X){X=X.toString(),this._text!==X&&(this._text=X,this.onUpdate())}get text(){return this._text}get style(){return this._style}set style(X){var K;X=X||{},(K=this._style)==null||K.off("update",this.onUpdate,this),this._style=ensureTextStyle(this._renderMode,X),this._style.on("update",this.onUpdate,this),this.onUpdate()}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}addBounds(X){const K=this.bounds;X.addFrame(K.left,K.top,K.right,K.bottom)}containsPoint(X){const K=this.bounds.right,J=this.bounds.bottom,Q=-K*this.anchor.x;let ee=0;return X.x>=Q&&X.x<=Q+K&&(ee=-J*this.anchor.y,X.y>=ee&&X.y<=ee+J)}onUpdate(){this._didUpdate=!0,this._boundsDirty=!0,this.owner.onViewUpdate()}_getKey(){return`${this.text}:${this._style.styleKey}`}_updateBounds(){const X=this._bounds,K=this._style.padding,J=this.anchor;if(this.renderPipeId==="bitmapText"){const Q=BitmapFontManager.measureText(this.text,this._style),ee=Q.scale,te=Q.offsetY*ee,re=Q.width*ee,ne=Q.height*ee;X.left=-J._x*re-K,X.right=X.left+re,X.top=-J._y*(ne+te)-K,X.bottom=X.top+ne}else if(this.renderPipeId==="htmlText"){const Q=measureHtmlText(this.text,this._style),{width:ee,height:te}=Q;X.left=-J._x*ee-K,X.right=X.left+ee,X.top=-J._y*te-K,X.bottom=X.top+te}else{const Q=CanvasTextMetrics.measureText(this.text,this._style),{width:ee,height:te}=Q;X.left=-J._x*ee-K,X.right=X.left+ee,X.top=-J._y*te-K,X.bottom=X.top+te}}destroy(X=!1){this.owner=null,this._bounds=null,this.anchor=null,this._style.destroy(X),this._style=null,this._text=null}}var p$c=Object.defineProperty,a$f=Object.getOwnPropertySymbols,o$5=Object.prototype.hasOwnProperty,c$b=Object.prototype.propertyIsEnumerable,n$e=(Z,X,K)=>X in Z?p$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$d=(Z,X)=>{for(var K in X||(X={}))o$5.call(X,K)&&n$e(Z,K,X[K]);if(a$f)for(var K of a$f(X))c$b.call(X,K)&&n$e(Z,K,X[K]);return Z},u$c=(Z,X)=>{var K={};for(var J in Z)o$5.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&a$f)for(var J of a$f(Z))X.indexOf(J)<0&&c$b.call(Z,J)&&(K[J]=Z[J]);return K};class Graphics extends Container{constructor(X){X instanceof GraphicsContext&&(X={context:X});const K=X||{},{context:J}=K,Q=u$c(K,["context"]);super(h$d({view:new GraphicsView(J),label:"Graphics"},Q)),this.allowChildren=!1}get context(){return this.view.context}set context(X){this.view.context=X}_callContextMethod(X,K){return this.view.context[X](...K),this}setFillStyle(X){return this._callContextMethod("setFillStyle",[X])}setStrokeStyle(X){return this._callContextMethod("setStrokeStyle",[X])}fill(...X){return this._callContextMethod("fill",X)}stroke(...X){return this._callContextMethod("stroke",X)}texture(...X){return this._callContextMethod("texture",X)}beginPath(){return this._callContextMethod("beginPath",[])}cut(...X){return this._callContextMethod("cut",X)}arc(...X){return this._callContextMethod("arc",X)}arcTo(...X){return this._callContextMethod("arcTo",X)}arcToSvg(...X){return this._callContextMethod("arcToSvg",X)}bezierCurveTo(...X){return this._callContextMethod("bezierCurveTo",X)}closePath(...X){return this._callContextMethod("closePath",X)}ellipse(...X){return this._callContextMethod("ellipse",X)}circle(...X){return this._callContextMethod("circle",X)}path(...X){return this._callContextMethod("path",X)}lineTo(...X){return this._callContextMethod("lineTo",X)}moveTo(...X){return this._callContextMethod("moveTo",X)}quadraticCurveTo(...X){return this._callContextMethod("quadraticCurveTo",X)}rect(...X){return this._callContextMethod("rect",X)}roundRect(...X){return this._callContextMethod("roundRect",X)}poly(...X){return this._callContextMethod("poly",X)}regularPoly(...X){return this._callContextMethod("regularPoly",X)}roundPoly(...X){return this._callContextMethod("roundPoly",X)}roundShape(...X){return this._callContextMethod("roundShape",X)}filletRect(...X){return this._callContextMethod("filletRect",X)}chamferRect(...X){return this._callContextMethod("chamferRect",X)}star(...X){return this._callContextMethod("star",X)}svg(...X){return this._callContextMethod("svg",X)}restore(...X){return this._callContextMethod("restore",X)}save(...X){return this._callContextMethod("save",X)}getTransform(...X){return this._callContextMethod("getTransform",X)}resetTransform(...X){return this._callContextMethod("resetTransform",X)}rotateTransform(...X){return this._callContextMethod("rotate",X)}scaleTransform(...X){return this._callContextMethod("scale",X)}setTransform(...X){return this._callContextMethod("setTransform",X)}transform(...X){return this._callContextMethod("transform",X)}translateTransform(...X){return this._callContextMethod("translate",X)}clear(...X){return this._callContextMethod("clear",X)}get fillStyle(){return this.view.context.fillStyle}set fillStyle(X){this.view.context.fillStyle=X}get strokeStyle(){return this.view.context.strokeStyle}set strokeStyle(X){this.view.context.strokeStyle=X}beginFill(X,K){return deprecation("8.0.0","Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.endFill(),this.context.fillStyle={color:X,alpha:K},this}endFill(){return deprecation("8.0.0","Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill(),this}drawCircle(...X){return deprecation("8.0.0","Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",X)}drawEllipse(...X){return deprecation("8.0.0","Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",X)}drawPolygon(...X){return deprecation("8.0.0","Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",X)}drawRect(...X){return deprecation("8.0.0","Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",X)}drawRoundedRect(...X){return deprecation("8.0.0","Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",X)}drawStar(...X){return deprecation("8.0.0","Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",X)}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}function definedProps(Z){const X={};for(const K in Z)Z[K]!==void 0&&(X[K]=Z[K]);return X}var x$7=Object.defineProperty,s$g=Object.getOwnPropertySymbols,d$8=Object.prototype.hasOwnProperty,m$9=Object.prototype.propertyIsEnumerable,a$e=(Z,X,K)=>X in Z?x$7(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$b=(Z,X)=>{for(var K in X||(X={}))d$8.call(X,K)&&a$e(Z,K,X[K]);if(s$g)for(var K of s$g(X))m$9.call(X,K)&&a$e(Z,K,X[K]);return Z},M$3=(Z,X)=>{var K={};for(var J in Z)d$8.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&s$g)for(var J of s$g(Z))X.indexOf(J)<0&&m$9.call(Z,J)&&(K[J]=Z[J]);return K};class Mesh extends Container{constructor(...X){let K=X[0];K instanceof MeshGeometry&&(deprecation(v8_0_0,"Mesh: use new Mesh({ geometry, shader }) instead"),K={geometry:K,shader:X[1]},X[3]&&(deprecation(v8_0_0,"Mesh: drawMode argument has been removed, use geometry.topology instead"),K.geometry.topology=X[3]));const J=K,{geometry:Q,shader:ee,texture:te}=J,re=M$3(J,["geometry","shader","texture"]);super(p$b({view:new MeshView(definedProps({geometry:Q,shader:ee,texture:te})),label:"Mesh"},re)),this.allowChildren=!1}get texture(){return this.view.texture}set texture(X){this.view.texture=X}get geometry(){return this.view.geometry}set geometry(X){this.view.geometry=X}get material(){return deprecation(v8_0_0,"mesh.material property has been removed, use mesh.shader instead"),this.view.shader}get shader(){return this.view.shader}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}class AnimatedSprite extends Sprite{constructor(X,K=!0){super(X[0]instanceof Texture?X[0]:X[0].texture),this._textures=null,this._durations=null,this._autoUpdate=K,this._isConnectedToTicker=!1,this.animationSpeed=1,this.loop=!0,this.updateAnchor=!1,this.onComplete=null,this.onFrameChange=null,this.onLoop=null,this._currentTime=0,this._playing=!1,this._previousFrame=null,this.textures=X}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(Ticker.shared.add(this.update,this,UPDATE_PRIORITY.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(X){this.stop(),this.currentFrame=X}gotoAndPlay(X){this.currentFrame=X,this.play()}update(X){if(!this._playing)return;const K=X.deltaTime,J=this.animationSpeed*K,Q=this.currentFrame;if(this._durations!==null){let ee=this._currentTime%1*this._durations[this.currentFrame];for(ee+=J/60*1e3;ee<0;)this._currentTime--,ee+=this._durations[this.currentFrame];const te=Math.sign(this.animationSpeed*K);for(this._currentTime=Math.floor(this._currentTime);ee>=this._durations[this.currentFrame];)ee-=this._durations[this.currentFrame]*te,this._currentTime+=te;this._currentTime+=ee/this._durations[this.currentFrame]}else this._currentTime+=J;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):Q!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<Q||this.animationSpeed<0&&this.currentFrame>Q)&&this.onLoop(),this._updateTexture())}_updateTexture(){const X=this.currentFrame;this._previousFrame!==X&&(this._previousFrame=X,this.texture=this._textures[X],this.updateAnchor&&this.anchor.copyFrom(this.texture.defaultAnchor),this.onFrameChange&&this.onFrameChange(this.currentFrame))}destroy(){this.stop(),super.destroy(),this.onComplete=null,this.onFrameChange=null,this.onLoop=null}static fromFrames(X){const K=[];for(let J=0;J<X.length;++J)K.push(Texture.from(X[J]));return new AnimatedSprite(K)}static fromImages(X){const K=[];for(let J=0;J<X.length;++J)K.push(Texture.from(X[J]));return new AnimatedSprite(K)}get totalFrames(){return this._textures.length}get textures(){return this._textures}set textures(X){if(X[0]instanceof Texture)this._textures=X,this._durations=null;else{this._textures=[],this._durations=[];for(let K=0;K<X.length;K++)this._textures.push(X[K].texture),this._durations.push(X[K].time)}this._previousFrame=null,this.gotoAndStop(0),this._updateTexture()}get currentFrame(){let X=Math.floor(this._currentTime)%this._textures.length;return X<0&&(X+=this._textures.length),X}set currentFrame(X){if(X<0||X>this.totalFrames-1)throw new Error(`[AnimatedSprite]: Invalid frame index value ${X}, expected to be between 0 and totalFrames ${this.totalFrames}.`);const K=this.currentFrame;this._currentTime=X,K!==this.currentFrame&&this._updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(X){X!==this._autoUpdate&&(this._autoUpdate=X,!this._autoUpdate&&this._isConnectedToTicker?(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(Ticker.shared.add(this.update,this),this._isConnectedToTicker=!0))}}class Transform{constructor({matrix:X,observer:K}={}){this.dirty=!0,this._matrix=X!=null?X:new Matrix,this.observer=K,this.position=new ObservablePoint(this,0,0),this.scale=new ObservablePoint(this,1,1),this.pivot=new ObservablePoint(this,0,0),this.skew=new ObservablePoint(this,0,0),this._rotation=0,this._cx=1,this._sx=0,this._cy=0,this._sy=1}get matrix(){const X=this._matrix;return this.dirty&&(X.a=this._cx*this.scale.x,X.b=this._sx*this.scale.x,X.c=this._cy*this.scale.y,X.d=this._sy*this.scale.y,X.tx=this.position.x-(this.pivot.x*X.a+this.pivot.y*X.c),X.ty=this.position.y-(this.pivot.x*X.b+this.pivot.y*X.d),this.dirty=!1),X}onUpdate(X){var K;this.dirty=!0,X===this.skew&&this.updateSkew(),(K=this.observer)==null||K.onUpdate(this)}updateSkew(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this.dirty=!0}setFromMatrix(X){X.decompose(this),this.dirty=!0}get rotation(){return this._rotation}set rotation(X){this._rotation!==X&&(this._rotation=X,this.updateSkew())}}var a$d=Object.defineProperty,n$d=Object.getOwnPropertySymbols,l$9=Object.prototype.hasOwnProperty,p$a=Object.prototype.propertyIsEnumerable,d$7=(Z,X,K)=>X in Z?a$d(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$f=(Z,X)=>{for(var K in X||(X={}))l$9.call(X,K)&&d$7(Z,K,X[K]);if(n$d)for(var K of n$d(X))p$a.call(X,K)&&d$7(Z,K,X[K]);return Z};const h$c=class{constructor(Z){this.owner=emptyViewObserver,this.uid=uid("tilingSpriteView"),this.renderPipeId="tilingSprite",this.batched=!0,this.roundPixels=0,this._bounds={left:0,right:1,top:0,bottom:0},this._boundsDirty=!0,Z=s$f(s$f({},h$c.defaultOptions),Z),this.anchor=new ObservablePoint(this,0,0),this._applyAnchorToTexture=Z.applyAnchorToTexture,this.texture=Z.texture,this._width=Z.width,this._height=Z.height,this._tileTransform=new Transform({observer:this})}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}set texture(Z){this._texture!==Z&&(this._texture=Z,this.onUpdate())}get texture(){return this._texture}set width(Z){this._width=Z,this.onUpdate()}get width(){return this._width}set height(Z){this._height=Z,this.onUpdate()}get height(){return this._height}_updateBounds(){const Z=this._bounds,X=this.anchor,K=this._width,J=this._height;Z.right=-X._x*K,Z.left=Z.right+K,Z.bottom=-X._y*J,Z.top=Z.bottom+J}addBounds(Z){const X=this.bounds;Z.addFrame(X.left,X.top,X.right,X.bottom)}containsPoint(Z){const X=this.bounds.left,K=this.bounds.top,J=-X*this.anchor.x;let Q=0;return Z.x>=J&&Z.x<=J+X&&(Q=-K*this.anchor.y,Z.y>=Q&&Z.y<=Q+K)}onUpdate(){this._boundsDirty=!0,this._didUpdate=!0,this.owner.onViewUpdate()}destroy(Z=!1){if(this.anchor=null,this._tileTransform=null,this._bounds=null,typeof Z=="boolean"?Z:Z==null?void 0:Z.texture){const X=typeof Z=="boolean"?Z:Z==null?void 0:Z.textureSource;this._texture.destroy(X)}this._texture=null}};let TilingSpriteView=h$c;TilingSpriteView.defaultOptions={texture:Texture.EMPTY,width:256,height:256,applyAnchorToTexture:!1};var c$a=Object.defineProperty,n$c=Object.getOwnPropertySymbols,h$b=Object.prototype.hasOwnProperty,l$8=Object.prototype.propertyIsEnumerable,a$c=(Z,X,K)=>X in Z?c$a(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$4=(Z,X)=>{for(var K in X||(X={}))h$b.call(X,K)&&a$c(Z,K,X[K]);if(n$c)for(var K of n$c(X))l$8.call(X,K)&&a$c(Z,K,X[K]);return Z},p$9=(Z,X)=>{var K={};for(var J in Z)h$b.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&n$c)for(var J of n$c(Z))X.indexOf(J)<0&&l$8.call(Z,J)&&(K[J]=Z[J]);return K};class TilingSprite extends Container{static from(X,K={}){return typeof X=="string"?new TilingSprite(o$4({texture:Cache.get(X)},K)):new TilingSprite(o$4({texture:X},K))}constructor(...X){let K=X[0]||{};K instanceof Texture&&(K={texture:K}),X.length>1&&(deprecation(v8_0_0,"use new TilingSprite({ texture, width:100, height:100 }) instead"),K.width=X[1],K.height=X[2]),K instanceof Texture&&(K={texture:K});const J=K!=null?K:{},{texture:Q,width:ee,height:te,applyAnchorToTexture:re}=J,ne=p$9(J,["texture","width","height","applyAnchorToTexture"]);super(o$4({view:new TilingSpriteView(definedProps({texture:Q,width:ee,height:te,applyAnchorToTexture:re})),label:"TilingSprite"},ne)),this.allowChildren=!1}get clampMargin(){return this.view.texture.textureMatrix.clampMargin}set clampMargin(X){this.view.texture.textureMatrix.clampMargin=X}set texture(X){this.view.texture=X}get texture(){return this.view.texture}get anchor(){return this.view.anchor}set anchor(X){this.view.anchor.x=X.x,this.view.anchor.y=X.y}get width(){return this.view.width}set width(X){this.view.width=X}get height(){return this.view.height}set height(X){this.view.height=X}get tilePosition(){return this.view._tileTransform.position}set tilePosition(X){this.view._tileTransform.position.copyFrom(X)}get tileScale(){return this.view._tileTransform.scale}set tileScale(X){this.view._tileTransform.scale.copyFrom(X)}set tileRotation(X){this.view._tileTransform.rotation=X}get tileRotation(){return this.view._tileTransform.rotation}get tileTransform(){return this.view._tileTransform}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}var O$3=Object.defineProperty,n$b=Object.getOwnPropertySymbols,l$7=Object.prototype.hasOwnProperty,a$b=Object.prototype.propertyIsEnumerable,T$4=(Z,X,K)=>X in Z?O$3(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,y$4=(Z,X)=>{for(var K in X||(X={}))l$7.call(X,K)&&T$4(Z,K,X[K]);if(n$b)for(var K of n$b(X))a$b.call(X,K)&&T$4(Z,K,X[K]);return Z},c$9=(Z,X)=>{var K={};for(var J in Z)l$7.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&n$b)for(var J of n$b(Z))X.indexOf(J)<0&&a$b.call(Z,J)&&(K[J]=Z[J]);return K};class Text extends Container{constructor(...X){var K;let J=(K=X[0])!=null?K:{};(typeof J=="string"||X[1])&&(deprecation(v8_0_0,'use new Text({ text: "hi!", style }) instead'),J={text:J,style:X[1]});const Q=J,{style:ee,text:te,renderMode:re,resolution:ne}=Q,ie=c$9(Q,["style","text","renderMode","resolution"]);super(y$4({view:new TextView(definedProps({style:ee,text:te,renderMode:re,resolution:ne})),label:"Text"},ie)),this.allowChildren=!1}get anchor(){return this.view.anchor}set anchor(X){this.view.anchor.x=X.x,this.view.anchor.y=X.y}set text(X){this.view.text=X}get text(){return this.view.text}set style(X){this.view.style=X}get style(){return this.view.style}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}class BitmapText extends Text{constructor(...X){let K=X[0];(typeof K=="string"||X[1])&&(deprecation(v8_0_0,'use new BitmapText({ text: "hi!", style }) instead'),K={text:K,style:X[1]}),K.renderMode="bitmap",super(K)}}class HTMLText extends Text{constructor(...X){let K=X[0];(typeof K=="string"||X[1])&&(deprecation(v8_0_0,'use new HTMLText({ text: "hi!", style }) instead'),K={text:K,style:X[1]}),K.renderMode="html",super(K)}}const i$8=class{constructor(Z){this._tick=()=>{this.timeout=setTimeout(this._processQueue,0)},this._processQueue=()=>{const{queue:X}=this;let K=0;for(;X.length&&K<i$8.uploadsPerFrame;){const J=X.shift();this.uploadQueueItem(J),K++}X.length?Ticker.system.addOnce(this._tick,this,UPDATE_PRIORITY.UTILITY):this._resolve()},this.renderer=Z,this.queue=[],this.resolves=[]}getQueue(){return[...this.queue]}add(Z){const X=Array.isArray(Z)?Z:[Z];for(const K of X)K instanceof Container?this._addContainer(K):this.resolveQueueItem(K,this.queue);return this}_addContainer(Z){this.resolveQueueItem(Z,this.queue);for(const X of Z.children)this._addContainer(X)}upload(Z){return Z&&this.add(Z),new Promise(X=>{this.queue.length?(this.resolves.push(X),this.dedupeQueue(),Ticker.system.addOnce(this._tick,this,UPDATE_PRIORITY.UTILITY)):X()})}dedupeQueue(){const Z=Object.create(null);let X=0;for(let K=0;K<this.queue.length;K++){const J=this.queue[K];Z[J.uid]||(Z[J.uid]=!0,this.queue[X++]=J)}this.queue.length=X}_resolve(){const{resolves:Z}=this,X=Z.slice(0);Z.length=0;for(const K of X)K()}};let PrepareBase=i$8;PrepareBase.uploadsPerFrame=4;class PrepareQueue extends PrepareBase{resolveQueueItem(X,K){return X instanceof Container?this.resolveContainerQueueItem(X,K):X instanceof TextureSource||X instanceof Texture?K.push(X.source):X instanceof GraphicsContext&&K.push(X),null}resolveContainerQueueItem(X,K){X instanceof Sprite||X instanceof TilingSprite||X instanceof Mesh?K.push(X.texture.source):X instanceof Text?K.push(X.view):X instanceof Graphics?K.push(X.context):X instanceof AnimatedSprite&&X.textures.forEach(J=>{J.source?K.push(J.source):K.push(J.texture.source)})}resolveGraphicsContextQueueItem(X){this.renderer.graphicsContext.getContextRenderData(X);const{instructions:K}=X;for(const J of K)if(J.action==="texture"){const{image:Q}=J.data;return Q.source}else if(J.action==="fill"){const{texture:Q}=J.data.style;return Q.source}return null}}class PrepareUpload extends PrepareQueue{uploadQueueItem(X){X instanceof TextureSource?this.uploadTextureSource(X):X instanceof TextView?this.uploadText(X):X instanceof GraphicsContext&&this.uploadGraphicsContext(X)}uploadTextureSource(X){this.renderer.texture.initSource(X)}uploadText(X){const K=X.renderPipeId;this.renderer.renderPipes[K].initGpuText(X.owner)}uploadGraphicsContext(X){this.renderer.graphicsContext.getContextRenderData(X);const{instructions:K}=X;for(const J of K)if(J.action==="texture"){const{image:Q}=J.data;this.uploadTextureSource(Q.source)}else if(J.action==="fill"){const{texture:Q}=J.data.style;this.uploadTextureSource(Q.source)}return null}}class PrepareSystem extends PrepareUpload{destroy(){clearTimeout(this.timeout),this.renderer=null,this.queue=null,this.resolves=null}}PrepareSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem],name:"prepare"},b$r.add(PrepareSystem);class GlBatchAdaptor{constructor(){this._didUpload=!1,this._tempState=State.for2d()}init(){const X=new UniformGroup({tint:{value:new Float32Array([1,1,1,1]),type:"f32"},translationMatrix:{value:new Matrix,type:"mat3x3<f32>"}}),K=compileHighShaderGlProgram({name:"batch",bits:[colorBitGl,generateTextureBatchBitGl(MAX_TEXTURES),roundPixelsBitGl]});this._shader=new Shader({glProgram:K,resources:{uniforms:X,batchSamplers:batchSamplersUniformGroup}})}start(X,K){const J=X.renderer;J.shader.bind(this._shader,this._didUpload),J.shader.bindUniformBlock(J.globalUniforms.uniformGroup,"globalUniforms",0),J.geometry.bind(K,this._shader.glProgram)}execute(X,K){const J=X.renderer;this._didUpload=!0,this._tempState.blendMode=K.blendMode,J.state.set(this._tempState);const Q=K.textures.textures;for(let ee=0;ee<Q.length;ee++)J.texture.bind(Q[ee],ee);J.geometry.draw("triangle-list",K.size,K.start)}destroy(){this._shader.destroy(!0),this._shader=null}}GlBatchAdaptor.extension={type:[u$z.WebGLPipesAdaptor],name:"batch"};function generateGPULayout(Z){const X=[];let K=0;for(let J=0;J<Z;J++)X[K]={texture:{sampleType:"float",viewDimension:"2d",multisampled:!1},binding:K,visibility:GPUShaderStage.FRAGMENT},K++,X[K]={sampler:{type:"filtering"},binding:K,visibility:GPUShaderStage.FRAGMENT},K++;return X}function generateLayout(Z){const X={};let K=0;for(let J=0;J<Z;J++)X[`textureSource${J+1}`]=K++,X[`textureSampler${J+1}`]=K++;return X}const n$a=State.for2d();class GpuBatchAdaptor{init(){const X=compileHighShaderGpuProgram({name:"batch",bits:[colorBit,generateTextureBatchBit(MAX_TEXTURES),roundPixelsBit]});this._shader=new Shader({gpuProgram:X,groups:{}})}start(X,K){const J=X.renderer,Q=J.encoder,ee=this._shader.gpuProgram;this._geometry=K,Q.setGeometry(K),n$a.blendMode="normal",J.pipeline.getPipeline(K,ee,n$a);const te=J.globalUniforms.bindGroup;Q.setBindGroup(0,te,ee)}execute(X,K){const J=this._shader.gpuProgram,Q=X.renderer,ee=Q.encoder;if(!K.bindGroup){const ne=K.textures;K.bindGroup=getTextureBatchBindGroup(ne.textures,ne.count)}n$a.blendMode=K.blendMode;const te=Q.bindGroup.getBindGroup(K.bindGroup,J,1),re=Q.pipeline.getPipeline(this._geometry,J,n$a);K.bindGroup._touch(Q.textureGC.count),ee.setPipeline(re),ee.renderPassEncoder.setBindGroup(1,te),ee.renderPassEncoder.drawIndexed(K.size,1,K.start)}destroy(){this._shader.destroy(!0),this._shader=null}}GpuBatchAdaptor.extension={type:[u$z.WebGPUPipesAdaptor],name:"batch"};class BatcherPipe{constructor(X,K){this.state=State.for2d(),this._batches=Object.create(null),this._geometries=Object.create(null),this.renderer=X,this._adaptor=K,this._adaptor.init()}buildStart(X){if(!this._batches[X.uid]){const K=new Batcher;this._batches[X.uid]=K,this._geometries[K.uid]=new BatchGeometry}this._activeBatch=this._batches[X.uid],this._activeGeometry=this._geometries[this._activeBatch.uid],this._activeBatch.begin()}addToBatch(X){this._activeBatch.add(X)}break(X){this._activeBatch.break(X)}buildEnd(X){const K=this._activeBatch,J=this._activeGeometry;K.finish(X),J.indexBuffer.setDataWithSize(K.indexBuffer,K.indexSize,!0),J.buffers[0].setDataWithSize(K.attributeBuffer.float32View,K.attributeSize,!1)}upload(X){const K=this._batches[X.uid],J=this._geometries[K.uid];K.dirty&&(K.dirty=!1,J.buffers[0].update(K.attributeSize*4))}execute(X){if(X.action==="startBatch"){const K=X.batcher,J=this._geometries[K.uid];this._adaptor.start(this,J)}this._adaptor.execute(this,X)}destroy(){this.state=null,this.renderer=null,this._adaptor.destroy(),this._adaptor=null;for(const X in this._batches)this._batches[X].destroy();this._batches=null;for(const X in this._geometries)this._geometries[X].destroy();this._geometries=null}}BatcherPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"batch"};function formatShader(Z){const X=Z.split(/([\n{}])/g).map(J=>J.trim()).filter(J=>J.length);let K="";return X.map(J=>{let Q=K+J;return J==="{"?K+="    ":J==="}"&&(K=K.substr(0,K.length-4),Q=K+J),Q}).join(`
`)}const textureBit={name:"texture-bit",fragment:{header:`
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,main:`
            outColor = textureSample(uTexture, uSampler, vUV);
        `}},textureBitGl={name:"texture-bit",fragment:{header:`
        uniform sampler2D uTexture;

         
        `,main:`
            outColor = texture(uTexture, vUV);
        `}};class RGRenderable extends eventemitter3{constructor({original:X,view:K}){super(),this.uid=uid("renderable"),this.rgColorAlpha=4294967295,this.rgColor=16777215,this.rgAlpha=1,this.view=K,this._original=X,this.rgTransform=new Matrix,this.rgVisibleRenderable=3,this.uid=X.uid,this.view.owner=this}get rgBlendMode(){return this._original.rgBlendMode}onViewUpdate(){this.didViewUpdate=!0,this._original.renderGroup.onChildViewUpdate(this)}get isRenderable(){return this._original.isRenderable}}function buildInstructions(Z,X){const K=Z.root,J=Z.instructionSet;J.reset(),X.batch.buildStart(J),X.blendMode.buildStart(),X.colorMask.buildStart(),K.sortableChildren&&K.sortChildren(),s$e(K,J,X,!0),X.batch.buildEnd(J),X.blendMode.buildEnd(J)}function collectAllRenderables(Z,X,K){Z.rgVisibleRenderable<3||!Z.includeInBuild||(Z.sortableChildren&&Z.sortChildren(),Z.isSimple?f$8(Z,X,K):s$e(Z,X,K,!1))}function f$8(Z,X,K){const J=Z.view;if(J&&(K.blendMode.setBlendMode(Z,Z.rgBlendMode,X),Z.didViewUpdate=!1,K[J.renderPipeId].addRenderable(Z,X)),!Z.isRenderGroupRoot){const Q=Z.children,ee=Q.length;for(let te=0;te<ee;te++)collectAllRenderables(Q[te],X,K)}}function s$e(Z,X,K,J){var Q;if(J){const ee=Z.renderGroup;if(ee.root.view){const te=(Q=ee.proxyRenderable)!=null?Q:R(ee);te&&(K.blendMode.setBlendMode(te,te.rgBlendMode,X),K[te.view.renderPipeId].addRenderable(te,X))}}else for(let ee=0;ee<Z.effects.length;ee++){const te=Z.effects[ee];K[te.pipe].push(te,Z,X)}if(!J&&Z.isRenderGroupRoot)K.renderGroup.addRenderGroup(Z.renderGroup,X);else{const ee=Z.view;ee&&(K.blendMode.setBlendMode(Z,Z.rgBlendMode,X),Z.didViewUpdate=!1,K[ee.renderPipeId].addRenderable(Z,X));const te=Z.children;if(te.length)for(let re=0;re<te.length;re++)collectAllRenderables(te[re],X,K)}if(!J)for(let ee=Z.effects.length-1;ee>=0;ee--){const te=Z.effects[ee];K[te.pipe].pop(te,Z,X)}}function R(Z){const X=Z.root;Z.proxyRenderable=new RGRenderable({original:X,view:X.view})}const g$5=new Bounds;class I extends FilterEffect{constructor(){super({filters:[new MaskFilter({sprite:new Sprite(Texture.EMPTY)})]})}get sprite(){return this.filters[0].sprite}set sprite(X){this.filters[0].sprite=X}}class AlphaMaskPipe{constructor(X){this._activeMaskStage=[],this._renderer=X}push(X,K,J){const Q=this._renderer;if(Q.renderPipes.batch.break(J),J.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:X,canBundle:!1,maskedContainer:K}),X.renderMaskToTexture){const ee=X.mask;ee.includeInBuild=!0,collectAllRenderables(ee,J,Q.renderPipes),ee.includeInBuild=!1}Q.renderPipes.batch.break(J),J.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:X,maskedContainer:K,canBundle:!1})}pop(X,K,J){this._renderer.renderPipes.batch.break(J),J.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:X,canBundle:!1})}execute(X){const K=this._renderer,J=X.mask.renderMaskToTexture;if(X.action==="pushMaskBegin"){const Q=BigPool.get(I);if(J){X.mask.mask.measurable=!0;const ee=getGlobalBounds(X.mask.mask,!0,g$5);X.mask.mask.measurable=!1,ee.ceil();const te=TexturePool.getOptimalTexture(ee.width,ee.height,1,!1);K.renderTarget.push(te,!0),K.globalUniforms.push({offset:ee,worldColor:4294967295});const re=Q.sprite;re.texture=te,re.worldTransform.tx=ee.minX,re.worldTransform.ty=ee.minY,this._activeMaskStage.push({filterEffect:Q,maskedContainer:X.maskedContainer,filterTexture:te})}else Q.sprite=X.mask.mask,this._activeMaskStage.push({filterEffect:Q,maskedContainer:X.maskedContainer})}else if(X.action==="pushMaskEnd"){const Q=this._activeMaskStage[this._activeMaskStage.length-1];J&&(K.renderTarget.pop(),K.globalUniforms.pop()),K.filter.push({renderPipeId:"filter",action:"pushFilter",container:Q.maskedContainer,filterEffect:Q.filterEffect,canBundle:!1})}else if(X.action==="popMaskEnd"){K.filter.pop();const Q=this._activeMaskStage.pop();J&&TexturePool.returnTexture(Q.filterTexture),BigPool.return(Q.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"alphaMask"};class ColorMaskPipe{constructor(X){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=X}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(X,K,J){this._renderer.renderPipes.batch.break(J);const Q=this._colorStack;Q[this._colorStackIndex]=Q[this._colorStackIndex-1]&X.mask;const ee=this._colorStack[this._colorStackIndex];ee!==this._currentColor&&(this._currentColor=ee,J.add({renderPipeId:"colorMask",colorMask:ee,canBundle:!1})),this._colorStackIndex++}pop(X,K,J){this._renderer.renderPipes.batch.break(J);const Q=this._colorStack;this._colorStackIndex--;const ee=Q[this._colorStackIndex-1];ee!==this._currentColor&&(this._currentColor=ee,J.add({renderPipeId:"colorMask",colorMask:ee,canBundle:!1}))}execute(X){this._renderer.colorMask.setMask(X.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"colorMask"};class ScissorMask{constructor(X){this.priority=0,this.pipe="scissorMask",this.mask=X,this.mask.renderable=!1,this.mask.measurable=!1}addBounds(X,K){addMaskBounds(this.mask,X,K)}addLocalBounds(X,K){addMaskLocalBounds(this.mask,X,K)}containsPoint(X,K){const J=this.mask;return K(J,X)}reset(){this.mask.measurable=!0,this.mask=null}destroy(){this.reset()}}var CLEAR=(Z=>(Z[Z.NONE=0]="NONE",Z[Z.COLOR=16384]="COLOR",Z[Z.STENCIL=1024]="STENCIL",Z[Z.DEPTH=256]="DEPTH",Z[Z.COLOR_DEPTH=16640]="COLOR_DEPTH",Z[Z.COLOR_STENCIL=17408]="COLOR_STENCIL",Z[Z.DEPTH_STENCIL=1280]="DEPTH_STENCIL",Z[Z.ALL=17664]="ALL",Z))(CLEAR||{});class StencilMaskPipe{constructor(X){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=X}push(X,K,J){const Q=X,ee=this._renderer;ee.renderPipes.batch.break(J),ee.renderPipes.blendMode.setBlendMode(Q.mask,"none",J),J.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:X,canBundle:!1});const te=Q.mask;te.includeInBuild=!0,this._maskHash.has(Q)||this._maskHash.set(Q,{instructionsStart:0,instructionsLength:0});const re=this._maskHash.get(Q);re.instructionsStart=J.instructionSize,collectAllRenderables(te,J,ee.renderPipes),te.includeInBuild=!1,ee.renderPipes.batch.break(J),J.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:X,canBundle:!1});const ne=J.instructionSize-re.instructionsStart-1;re.instructionsLength=ne;const ie=ee.renderTarget.renderTarget.uid;this._maskStackHash[ie]===void 0&&(this._maskStackHash[ie]=0),this._maskStackHash[ie]++}pop(X,K,J){const Q=X,ee=this._renderer,te=ee.renderTarget.renderTarget.uid;this._maskStackHash[te]--,ee.renderPipes.batch.break(J),ee.renderPipes.blendMode.setBlendMode(Q.mask,"none",J),J.add({renderPipeId:"stencilMask",action:"popMaskBegin",canBundle:!1});const re=this._maskHash.get(X);if(this._maskStackHash[te]!==0)for(let ne=0;ne<re.instructionsLength;ne++)J.instructions[J.instructionSize++]=J.instructions[re.instructionsStart++];J.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(X){var K;const J=this._renderer,Q=J.renderTarget.renderTarget.uid;let ee=(K=this._maskStackHash[Q])!=null?K:0;X.action==="pushMaskBegin"?(ee++,J.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD,ee),J.colorMask.setMask(0)):X.action==="pushMaskEnd"?(J.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,ee),J.colorMask.setMask(15)):X.action==="popMaskBegin"?(ee--,ee!==0?(J.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE,ee),J.colorMask.setMask(0)):J.renderTarget.clear(CLEAR.STENCIL)):X.action==="popMaskEnd"&&(ee===0?J.stencil.setStencilMode(STENCIL_MODES.DISABLED,ee):J.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,ee),J.colorMask.setMask(15)),this._maskStackHash[Q]=ee}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}StencilMaskPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"stencilMask"};var BUFFER_TYPE=(Z=>(Z[Z.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",Z[Z.ARRAY_BUFFER=34962]="ARRAY_BUFFER",Z[Z.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",Z))(BUFFER_TYPE||{});class GlBuffer{constructor(X,K){this.buffer=X||null,this.updateID=-1,this.byteLength=-1,this.type=K}}class GlBufferSystem{constructor(X){this._gpuBuffers=Object.create(null),this._boundBufferBases=Object.create(null),this._renderer=X}destroy(){this.destroyAll(!0),this._renderer=null,this._gl=null,this._gpuBuffers=null,this._boundBufferBases=null}contextChange(){this.destroyAll(!0),this._gl=this._renderer.gl}getGlBuffer(X){return this._gpuBuffers[X.uid]||this.createGLBuffer(X)}bind(X){const{_gl:K}=this,J=this.getGlBuffer(X);K.bindBuffer(J.type,J.buffer)}bindBufferBase(X,K){const{_gl:J}=this;if(this._boundBufferBases[K]!==X){const Q=this.getGlBuffer(X);this._boundBufferBases[K]=X,J.bindBufferBase(J.UNIFORM_BUFFER,K,Q.buffer)}}bindBufferRange(X,K,J){const{_gl:Q}=this;J=J||0;const ee=this.getGlBuffer(X);Q.bindBufferRange(Q.UNIFORM_BUFFER,K||0,ee.buffer,J*256,256)}updateBuffer(X){const{_gl:K}=this,J=this.getGlBuffer(X);if(X._updateID===J.updateID)return J;if(J.updateID=X._updateID,K.bindBuffer(J.type,J.buffer),J.byteLength>=X.data.byteLength)K.bufferSubData(J.type,0,X.data,0,X._updateSize/4);else{const Q=X.descriptor.usage&BufferUsage.STATIC?K.STATIC_DRAW:K.DYNAMIC_DRAW;J.byteLength=X.data.byteLength,K.bufferData(J.type,X.data,Q)}return J}destroyAll(X){const K=this._gl;if(!X)for(const J in this._gpuBuffers)K.deleteBuffer(this._gpuBuffers[J].buffer);this._gpuBuffers={}}onBufferDestroy(X,K){const J=this._gpuBuffers[X.uid],Q=this._gl;K||Q.deleteBuffer(J.buffer),this._gpuBuffers[X.uid]=null}createGLBuffer(X){const{_gl:K}=this;let J=BUFFER_TYPE.ARRAY_BUFFER;X.descriptor.usage&BufferUsage.INDEX?J=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER:X.descriptor.usage&BufferUsage.UNIFORM&&(J=BUFFER_TYPE.UNIFORM_BUFFER);const Q=new GlBuffer(K.createBuffer(),J);return this._gpuBuffers[X.uid]=Q,X.on("destroy",this.onBufferDestroy,this),Q}}GlBufferSystem.extension={type:[u$z.WebGLSystem],name:"buffer"};class GlContextSystem{constructor(X){this._renderer=X,this.webGLVersion=2,this.extensions=Object.create(null),this.supports={uint32Indices:!1},this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(X){this.gl=X,this._renderer.gl=X,X.isContextLost()&&X.getExtension("WEBGL_lose_context")&&X.getExtension("WEBGL_lose_context").restoreContext()}init(X){var K,J;if(X!=null&&X.context)this.initFromContext(X.context);else{const Q=this._renderer.background.alpha<1,ee=(K=X.premultipliedAlpha)!=null?K:!0,te=X.antialias&&!this._renderer.backBuffer.useBackBuffer;this.initFromOptions({alpha:Q,premultipliedAlpha:ee,antialias:te,stencil:!0,preserveDrawingBuffer:X.preserveDrawingBuffer,powerPreference:(J=X.powerPreference)!=null?J:"default"})}}initFromContext(X){this.gl=X,this.validateContext(X),this._renderer.runners.contextChange.emit(X);const K=this._renderer.view.canvas;K.addEventListener("webglcontextlost",this.handleContextLost,!1),K.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}initFromOptions(X){const K=this.createContext(this._renderer.view.canvas,X);this.initFromContext(K)}createContext(X,K){const J=X.getContext("webgl2",K);return this.webGLVersion=2,this.gl=J,this.getExtensions(),this.gl}getExtensions(){const{gl:X}=this,K={anisotropicFiltering:X.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:X.getExtension("OES_texture_float_linear"),s3tc:X.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:X.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:X.getExtension("WEBGL_compressed_texture_etc"),etc1:X.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:X.getExtension("WEBGL_compressed_texture_pvrtc")||X.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:X.getExtension("WEBGL_compressed_texture_atc"),astc:X.getExtension("WEBGL_compressed_texture_astc"),bptc:X.getExtension("EXT_texture_compression_bptc")};Object.assign(this.extensions,K,{colorBufferFloat:X.getExtension("EXT_color_buffer_float")})}handleContextLost(X){X.preventDefault()}handleContextRestored(){this._renderer.runners.contextChange.emit(this.gl)}destroy(){const X=this._renderer.view.canvas;this._renderer=null,X.removeEventListener("webglcontextlost",this.handleContextLost),X.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),this.extensions.loseContext&&this.extensions.loseContext.loseContext()}validateContext(X){const K=X.getContextAttributes(),J="WebGL2RenderingContext"in globalThis&&X instanceof globalThis.WebGL2RenderingContext;J&&(this.webGLVersion=2),K&&K.stencil;const Q=J||!!X.getExtension("OES_element_index_uint");this.supports.uint32Indices=Q}}GlContextSystem.extension={type:[u$z.WebGLSystem],name:"context"},GlContextSystem.defaultOptions={context:null,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:void 0};var GL_FORMATS=(Z=>(Z[Z.RGBA=6408]="RGBA",Z[Z.RGB=6407]="RGB",Z[Z.RG=33319]="RG",Z[Z.RED=6403]="RED",Z[Z.RGBA_INTEGER=36249]="RGBA_INTEGER",Z[Z.RGB_INTEGER=36248]="RGB_INTEGER",Z[Z.RG_INTEGER=33320]="RG_INTEGER",Z[Z.RED_INTEGER=36244]="RED_INTEGER",Z[Z.ALPHA=6406]="ALPHA",Z[Z.LUMINANCE=6409]="LUMINANCE",Z[Z.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",Z[Z.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",Z[Z.DEPTH_STENCIL=34041]="DEPTH_STENCIL",Z))(GL_FORMATS||{}),GL_TARGETS=(Z=>(Z[Z.TEXTURE_2D=3553]="TEXTURE_2D",Z[Z.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",Z[Z.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",Z[Z.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",Z[Z.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",Z[Z.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",Z[Z.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",Z[Z.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",Z[Z.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",Z))(GL_TARGETS||{}),GL_WRAP_MODES=(Z=>(Z[Z.CLAMP=33071]="CLAMP",Z[Z.REPEAT=10497]="REPEAT",Z[Z.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",Z))(GL_WRAP_MODES||{}),GL_TYPES=(Z=>(Z[Z.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",Z[Z.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",Z[Z.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",Z[Z.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",Z[Z.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",Z[Z.UNSIGNED_INT=5125]="UNSIGNED_INT",Z[Z.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",Z[Z.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",Z[Z.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",Z[Z.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",Z[Z.BYTE=5120]="BYTE",Z[Z.SHORT=5122]="SHORT",Z[Z.INT=5124]="INT",Z[Z.FLOAT=5126]="FLOAT",Z[Z.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",Z[Z.HALF_FLOAT=36193]="HALF_FLOAT",Z))(GL_TYPES||{});const i$7={uint8x2:{type:GL_TYPES.UNSIGNED_BYTE,size:2,normalised:!1},uint8x4:{type:GL_TYPES.UNSIGNED_BYTE,size:4,normalised:!1},sint8x2:{type:GL_TYPES.BYTE,size:2,normalised:!1},sint8x4:{type:GL_TYPES.BYTE,size:4,normalised:!1},unorm8x2:{type:GL_TYPES.UNSIGNED_BYTE,size:2,normalised:!0},unorm8x4:{type:GL_TYPES.UNSIGNED_BYTE,size:4,normalised:!0},snorm8x2:{type:GL_TYPES.BYTE,size:2,normalised:!0},snorm8x4:{type:GL_TYPES.BYTE,size:4,normalised:!0},uint16x2:{type:GL_TYPES.UNSIGNED_SHORT,size:2,normalised:!1},uint16x4:{type:GL_TYPES.UNSIGNED_SHORT,size:4,normalised:!1},sint16x2:{type:GL_TYPES.SHORT,size:2,normalised:!1},sint16x4:{type:GL_TYPES.SHORT,size:4,normalised:!1},unorm16x2:{type:GL_TYPES.UNSIGNED_SHORT,size:2,normalised:!0},unorm16x4:{type:GL_TYPES.UNSIGNED_SHORT,size:4,normalised:!0},snorm16x2:{type:GL_TYPES.SHORT,size:2,normalised:!0},snorm16x4:{type:GL_TYPES.SHORT,size:4,normalised:!0},float16x2:{type:GL_TYPES.HALF_FLOAT,size:2,normalised:!1},float16x4:{type:GL_TYPES.HALF_FLOAT,size:4,normalised:!1},float32:{type:GL_TYPES.FLOAT,size:1,normalised:!1},float32x2:{type:GL_TYPES.FLOAT,size:2,normalised:!1},float32x3:{type:GL_TYPES.FLOAT,size:3,normalised:!1},float32x4:{type:GL_TYPES.FLOAT,size:4,normalised:!1},uint32:{type:GL_TYPES.UNSIGNED_INT,size:1,normalised:!1},uint32x2:{type:GL_TYPES.UNSIGNED_INT,size:2,normalised:!1},uint32x3:{type:GL_TYPES.UNSIGNED_INT,size:3,normalised:!1},uint32x4:{type:GL_TYPES.UNSIGNED_INT,size:4,normalised:!1},sint32:{type:GL_TYPES.INT,size:1,normalised:!1},sint32x2:{type:GL_TYPES.INT,size:2,normalised:!1},sint32x3:{type:GL_TYPES.INT,size:3,normalised:!1},sint32x4:{type:GL_TYPES.INT,size:4,normalised:!1}};function getGlInfoFromFormat(Z){var X;return(X=i$7[Z])!=null?X:i$7.float32}const h$a={5126:4,5123:2,5121:1},p$8={"point-list":0,"line-list":1,"line-strip":3,"triangle-list":4,"triangle-strip":5};class GlGeometrySystem{constructor(X){this._geometryVaoHash={},this._renderer=X,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this.canUseUInt32ElementIndex=!0}contextChange(){this.gl=this._renderer.gl}bind(X,K){const J=this.gl;this._activeGeometry=X;const Q=this.getVao(X,K);this._activeVao!==Q&&(this._activeVao=Q,J.bindVertexArray(Q)),this.updateBuffers()}reset(){this.unbind()}updateBuffers(){const X=this._activeGeometry,K=this._renderer.buffer;for(let J=0;J<X.buffers.length;J++){const Q=X.buffers[J];K.updateBuffer(Q)}}checkCompatibility(X,K){const J=X.attributes,Q=K._attributeData;for(const ee in Q)if(!J[ee])throw new Error(`shader and geometry incompatible, geometry missing the "${ee}" attribute`)}getSignature(X,K){const J=X.attributes,Q=K._attributeData,ee=["g",X.uid];for(const te in J)Q[te]&&ee.push(te,Q[te].location);return ee.join("-")}getVao(X,K){var J;return((J=this._geometryVaoHash[X.uid])==null?void 0:J[K._key])||this.initGeometryVao(X,K)}initGeometryVao(X,K,J=!0){const Q=this._renderer.gl,ee=this._renderer.buffer;this._renderer.shader._getProgramData(K),this.checkCompatibility(X,K);const te=this.getSignature(X,K);this._geometryVaoHash[X.uid]||(this._geometryVaoHash[X.uid]=Object.create(null),X.on("destroy",this.onGeometryDestroy,this));const re=this._geometryVaoHash[X.uid];let ne=re[te];if(ne)return re[K._key]=ne,ne;const ie=X.buffers,se=X.attributes,oe={},ae={};for(const le in ie)oe[le]=0,ae[le]=0;for(const le in se)!se[le].size&&K._attributeData[le]?se[le].size=K._attributeData[le].size:se[le].size,oe[se[le].buffer.uid]+=se[le].size*h$a[se[le].type];for(const le in se){const ce=se[le],de=ce.size;ce.stride===void 0&&(oe[ce.buffer.uid]===de*h$a[ce.type]?ce.stride=0:ce.stride=oe[ce.buffer.uid]),ce.start===void 0&&(ce.start=ae[ce.buffer.uid],ae[ce.buffer.uid]+=de*h$a[ce.type])}ne=Q.createVertexArray(),Q.bindVertexArray(ne);for(let le=0;le<ie.length;le++){const ce=ie[le];ee.bind(ce)}return this.activateVao(X,K),re[K._key]=ne,re[te]=ne,Q.bindVertexArray(null),ne}onGeometryDestroy(X,K){const J=this._geometryVaoHash[X.uid],Q=this.gl;if(J){if(K)for(const ee in J)this._activeVao!==J[ee]&&this.unbind(),Q.deleteVertexArray(J[ee]);this._geometryVaoHash[X.uid]=null}}destroyAll(X=!1){const K=this.gl;for(const J in this._geometryVaoHash){if(X)for(const Q in this._geometryVaoHash[J]){const ee=this._geometryVaoHash[J];this._activeVao!==ee&&this.unbind(),K.deleteVertexArray(ee[Q])}this._geometryVaoHash[J]=null}}activateVao(X,K){const J=this._renderer.gl,Q=this._renderer.buffer,ee=X.attributes;X.indexBuffer&&Q.bind(X.indexBuffer);let te=null;for(const re in ee){const ne=ee[re],ie=ne.buffer,se=Q.getGlBuffer(ie);if(K._attributeData[re]){te!==se&&(Q.bind(ie),te=se);const oe=K._attributeData[re].location;J.enableVertexAttribArray(oe);const ae=getGlInfoFromFormat(ne.format);if(J.vertexAttribPointer(oe,ae.size,ae.type,ae.normalised,ne.stride,ne.offset),ne.instance)if(this.hasInstance)J.vertexAttribDivisor(oe,1);else throw new Error("geometry error, GPU Instancing is not supported on this device")}}}draw(X,K,J,Q){const{gl:ee}=this._renderer,te=this._activeGeometry,re=p$8[te.topology||X];if(te.indexBuffer){const ne=te.indexBuffer.data.BYTES_PER_ELEMENT,ie=ne===2?ee.UNSIGNED_SHORT:ee.UNSIGNED_INT;te.instanced?ee.drawElementsInstanced(re,K||te.indexBuffer.data.length,ie,(J||0)*ne,te.instanceCount||1):ee.drawElements(re,K||te.indexBuffer.data.length,ie,(J||0)*ne)}else te.instanced?ee.drawArraysInstanced(re,J,K||te.getSize(),Q||1):ee.drawArrays(re,J,K||te.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this._renderer=null,this.gl=null,this._activeVao=null,this._activeGeometry=null}}GlGeometrySystem.extension={type:[u$z.WebGLSystem],name:"geometry"};var c$8=Object.defineProperty,n$9=Object.getOwnPropertySymbols,d$6=Object.prototype.hasOwnProperty,l$6=Object.prototype.propertyIsEnumerable,f$7=(Z,X,K)=>X in Z?c$8(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$d=(Z,X)=>{for(var K in X||(X={}))d$6.call(X,K)&&f$7(Z,K,X[K]);if(n$9)for(var K of n$9(X))l$6.call(X,K)&&f$7(Z,K,X[K]);return Z};const m$8=new GlProgram({vertex:`
        out vec2 vUv;

        void main() {
            vUv = vec2((gl_VertexID << 1) & 2, (gl_VertexID & 2));

            gl_Position = vec4(vUv * 2.0f + -1.0f, 0.0f, 1.0f);

            // flip dem UVs
            vUv.y = 1.0f - vUv.y;
        }`,fragment:`
        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uTexture;

        void main() {
            fragColor = texture(uTexture, vUv);
        }`,name:"big-triangle"}),o$3=new Shader({glProgram:m$8,resources:{uTexture:Texture.WHITE.source}}),a$a=class{constructor(Z){this.useBackBuffer=!1,this._useBackBufferThisRender=!1,this._renderer=Z}init(Z={}){const{useBackBuffer:X,antialias:K}=s$d(s$d({},a$a.defaultOptions),Z);this.useBackBuffer=X,this._antialias=K}renderStart(Z){const X=this._renderer.renderTarget.getRenderTarget(Z.target);if(this._useBackBufferThisRender=this.useBackBuffer&&!!X.isRoot,this._useBackBufferThisRender){const K=this._renderer.renderTarget.getRenderTarget(Z.target);this._targetTexture=K.colorTexture,Z.target=this._getBackBufferTexture(K.colorTexture)}}renderEnd(){this._presentBackBuffer()}_presentBackBuffer(){const Z=this._renderer;if(Z.renderTarget.finishRenderPass(),!this._useBackBufferThisRender)return;const X=Z.gl;Z.renderTarget.bind(this._targetTexture,!1),o$3.resources.uTexture=this._backBufferTexture.source,Z.shader.bind(o$3,!1),Z.state.set(State.for2d()),X.drawArrays(X.TRIANGLES,0,3)}_getBackBufferTexture(Z){return this._backBufferTexture=this._backBufferTexture||new Texture({source:new TextureSource({width:Z.width,height:Z.height,resolution:Z._resolution,antialias:this._antialias})}),this._backBufferTexture.source.resize(Z.width,Z.height,Z._resolution),this._backBufferTexture}destroy(){this._backBufferTexture&&(this._backBufferTexture.destroy(),this._backBufferTexture=null)}};let GlBackBufferSystem=a$a;GlBackBufferSystem.extension={type:[u$z.WebGLSystem],name:"backBuffer",priority:1},GlBackBufferSystem.defaultOptions={useBackBuffer:!1};class GlColorMaskSystem{constructor(X){this._colorMaskCache=15,this._renderer=X}setMask(X){this._colorMaskCache!==X&&(this._colorMaskCache=X,this._renderer.gl.colorMask(!!(X&8),!!(X&4),!!(X&2),!!(X&1)))}}GlColorMaskSystem.extension={type:[u$z.WebGLSystem],name:"colorMask"};class GlEncoderSystem{constructor(X){this.commandFinished=Promise.resolve(),this._renderer=X}setGeometry(X,K){this._renderer.geometry.bind(X,K.glProgram)}finishRenderPass(){}draw(X){const K=this._renderer,{geometry:J,shader:Q,state:ee,skipSync:te,topology:re,size:ne,start:ie,instanceCount:se}=X;K.shader.bind(Q,te),K.geometry.bind(J,K.shader._activeProgram),ee&&K.state.set(ee),K.geometry.draw(re,ne,ie,se)}destroy(){this._renderer=null}}GlEncoderSystem.extension={type:[u$z.WebGLSystem],name:"encoder"};class GlRenderTarget{constructor(){this.width=-1,this.height=-1,this.msaa=!1,this.msaaRenderBuffer=[]}}class GlRenderTargetAdaptor{constructor(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new Rectangle}init(X,K){this._renderer=X,this._renderTargetSystem=K}copyToTexture(X,K,J,Q){const ee=this._renderTargetSystem,te=this._renderer,re=ee.getGpuRenderTarget(X),ne=te.gl;return this.finishRenderPass(X),ne.bindFramebuffer(ne.FRAMEBUFFER,re.resolveTargetFramebuffer),te.texture.bind(K,0),ne.copyTexSubImage2D(ne.TEXTURE_2D,0,0,0,J.x,J.y,Q.width,Q.height),K}startRenderPass(X,K=!0,J,Q){const ee=this._renderTargetSystem,te=X.colorTexture,re=ee.getGpuRenderTarget(X);let ne=Q.y;X.isRoot&&(ne=te.pixelHeight-Q.height),X.colorTextures.forEach(oe=>{this._renderer.texture.unbind(oe)});const ie=this._renderer.gl;ie.bindFramebuffer(ie.FRAMEBUFFER,re.framebuffer);const se=this._viewPortCache;(se.x!==Q.x||se.y!==ne||se.width!==Q.width||se.height!==Q.height)&&(se.x=Q.x,se.y=ne,se.width=Q.width,se.height=Q.height,ie.viewport(Q.x,ne,Q.width,Q.height)),this.clear(X,K,J)}finishRenderPass(X){const K=this._renderTargetSystem.getGpuRenderTarget(X);if(!K.msaa)return;const J=this._renderer.gl;J.bindFramebuffer(J.FRAMEBUFFER,K.resolveTargetFramebuffer),J.bindFramebuffer(J.READ_FRAMEBUFFER,K.framebuffer),J.blitFramebuffer(0,0,K.width,K.height,0,0,K.width,K.height,J.COLOR_BUFFER_BIT,J.NEAREST),J.bindFramebuffer(J.FRAMEBUFFER,K.framebuffer)}initGpuRenderTarget(X){const K=this._renderer.gl,J=new GlRenderTarget;return CanvasSource.test(X.colorTexture.resource)?(J.framebuffer=null,J):(this._initColor(X,J),X.stencil&&this._initStencil(J),K.bindFramebuffer(K.FRAMEBUFFER,null),J)}clear(X,K,J){if(!K)return;const Q=this._renderTargetSystem;typeof K=="boolean"&&(K=K?CLEAR.ALL:CLEAR.NONE);const ee=this._renderer.gl;if(K&CLEAR.COLOR){J!=null||(J=Q.defaultClearColor);const te=this._clearColorCache,re=J;(te[0]!==re[0]||te[1]!==re[1]||te[2]!==re[2]||te[3]!==re[3])&&(te[0]=re[0],te[1]=re[1],te[2]=re[2],te[3]=re[3],ee.clearColor(re[0],re[1],re[2],re[3]))}ee.clear(K)}resizeGpuRenderTarget(X){if(X.isRoot)return;const K=this._renderTargetSystem.getGpuRenderTarget(X);this._resizeColor(X,K),X.stencil&&this._resizeStencil(K)}_initColor(X,K){const J=this._renderer,Q=J.gl,ee=Q.createFramebuffer();if(K.resolveTargetFramebuffer=ee,Q.bindFramebuffer(Q.FRAMEBUFFER,ee),K.width=X.colorTexture.source.pixelWidth,K.height=X.colorTexture.source.pixelHeight,X.colorTextures.forEach((te,re)=>{const ne=te.source;ne.antialias&&(K.msaa=!0),J.texture.bindSource(ne,0);const ie=J.texture.getGlSource(ne).texture;Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0+re,3553,ie,0)}),K.msaa){const te=Q.createFramebuffer();K.framebuffer=te,Q.bindFramebuffer(Q.FRAMEBUFFER,te),X.colorTextures.forEach((re,ne)=>{const ie=Q.createRenderbuffer();K.msaaRenderBuffer[ne]=ie})}else K.framebuffer=ee;this._resizeColor(X,K)}_resizeColor(X,K){const J=X.colorTexture.source;if(K.width=J.pixelWidth,K.height=J.pixelHeight,X.colorTextures.forEach((Q,ee)=>{ee!==0&&Q.source.resize(J.width,J.height,J._resolution)}),K.msaa){const Q=this._renderer,ee=Q.gl,te=K.framebuffer;ee.bindFramebuffer(ee.FRAMEBUFFER,te),X.colorTextures.forEach((re,ne)=>{const ie=re.source;Q.texture.bindSource(ie,0);const se=Q.texture.getGlSource(ie).internalFormat,oe=K.msaaRenderBuffer[ne];ee.bindRenderbuffer(ee.RENDERBUFFER,oe),ee.renderbufferStorageMultisample(ee.RENDERBUFFER,4,se,ie.pixelWidth,ie.pixelHeight),ee.framebufferRenderbuffer(ee.FRAMEBUFFER,ee.COLOR_ATTACHMENT0+ne,ee.RENDERBUFFER,oe)})}}_initStencil(X){const K=this._renderer.gl,J=K.createRenderbuffer();X.depthStencilRenderBuffer=J,K.bindRenderbuffer(K.RENDERBUFFER,J),K.framebufferRenderbuffer(K.FRAMEBUFFER,K.DEPTH_STENCIL_ATTACHMENT,K.RENDERBUFFER,J),this._resizeStencil(X)}_resizeStencil(X){const K=this._renderer.gl;K.bindRenderbuffer(K.RENDERBUFFER,X.depthStencilRenderBuffer),X.msaa?K.renderbufferStorageMultisample(K.RENDERBUFFER,4,K.DEPTH24_STENCIL8,X.width,X.height):K.renderbufferStorage(K.RENDERBUFFER,K.DEPTH24_STENCIL8,X.width,X.height)}}function calculateProjection(Z,X,K,J,Q,ee){const te=ee?1:-1;return Z.identity(),Z.a=1/J*2,Z.d=te*(1/Q*2),Z.tx=-1-X*Z.a,Z.ty=-te-K*Z.d,Z}var c$7=Object.defineProperty,s$c=Object.getOwnPropertySymbols,C$2=Object.prototype.hasOwnProperty,p$7=Object.prototype.propertyIsEnumerable,a$9=(Z,X,K)=>X in Z?c$7(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$b=(Z,X)=>{for(var K in X||(X={}))C$2.call(X,K)&&a$9(Z,K,X[K]);if(s$c)for(var K of s$c(X))p$7.call(X,K)&&a$9(Z,K,X[K]);return Z};const t$3=new Map;function getCanvasTexture(Z,X){if(!t$3.has(Z)){const K=new Texture({source:new CanvasSource(u$b({resource:Z},X))}),J=()=>{t$3.get(Z)===K&&t$3.delete(Z)};K.once("destroy",J),K.source.once("destroy",J),t$3.set(Z,K)}return t$3.get(Z)}function hasCachedCanvasTexture(Z){return t$3.has(Z)}function isRenderingToScreen(Z){const X=Z.colorTexture.source.resource;return X instanceof HTMLCanvasElement&&document.body.contains(X)}var T$3=Object.defineProperty,h$9=Object.getOwnPropertySymbols,a$8=Object.prototype.hasOwnProperty,b$8=Object.prototype.propertyIsEnumerable,l$5=(Z,X,K)=>X in Z?T$3(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$a=(Z,X)=>{for(var K in X||(X={}))a$8.call(X,K)&&l$5(Z,K,X[K]);if(h$9)for(var K of h$9(X))b$8.call(X,K)&&l$5(Z,K,X[K]);return Z};const s$b=class{constructor(Z={}){if(this.uid=uid("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),Z=u$a(u$a({},s$b.defaultDescriptor),Z),this.stencil=Z.stencil,typeof Z.colorTextures=="number")for(let X=0;X<Z.colorTextures;X++)this.colorTextures.push(new TextureSource({width:Z.width,height:Z.height,resolution:Z.resolution,antialias:Z.antialias}));else{this.colorTextures=[...Z.colorTextures.map(K=>K.source)];const X=this.colorTexture.source;this.resize(X.width,X.height,X._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),Z.depthTexture&&(Z.depthTexture instanceof Texture||Z.depthTexture instanceof TextureSource?this.depthTexture=Z.depthTexture.source:this.depthTexture=new TextureSource({width:this.width,height:this.height,resolution:this.resolution,format:"stencil8"}))}get size(){const Z=this._size;return Z[0]=this.pixelWidth,Z[1]=this.pixelHeight,Z}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(Z){this.resize(Z.width,Z.height,Z._resolution,!0)}resize(Z,X,K=this.resolution,J=!1){this.dirtyId++,this.colorTextures.forEach((Q,ee)=>{J&&ee===0||Q.source.resize(Z,X,K)}),this.depthTexture&&this.depthTexture.source.resize(Z,X,K)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this.depthTexture&&(this.depthTexture.destroy(),delete this.depthTexture)}};let RenderTarget=s$b;RenderTarget.defaultDescriptor={width:0,height:0,resolution:1,colorTextures:1,stencil:!0,antialias:!1};class RenderTargetSystem{constructor(X){this.rootViewPort=new Rectangle,this.viewport=new Rectangle,this.onRenderTargetChange=new SystemRunner("onRenderTargetChange"),this.projectionMatrix=new Matrix,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=X}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target:X,clear:K,clearColor:J,frame:Q}){this._renderTargetStack.length=0,this.push(X,K,J!=null?J:this._renderer.background.colorRgba,Q),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=isRenderingToScreen(this.rootRenderTarget)}bind(X,K=!0,J,Q){const ee=this.getRenderTarget(X),te=this.renderTarget!==ee;this.renderTarget=ee;const re=this.getGpuRenderTarget(ee);(ee.pixelWidth!==re.width||ee.pixelHeight!==re.height)&&(this.adaptor.resizeGpuRenderTarget(ee),re.width=ee.pixelWidth,re.height=ee.pixelHeight);const ne=ee.colorTexture,ie=this.viewport,se=ne.pixelWidth,oe=ne.pixelHeight;if(!Q&&X instanceof Texture&&(Q=X.frame),Q){const ae=ne._resolution;ie.x=Q.x*ae+.5|0,ie.y=Q.y*ae+.5|0,ie.width=Q.width*ae+.5|0,ie.height=Q.height*ae+.5|0}else ie.x=0,ie.y=0,ie.width=se,ie.height=oe;return calculateProjection(this.projectionMatrix,0,0,ie.width/ne.resolution,ie.height/ne.resolution,!ee.isRoot),this.adaptor.startRenderPass(ee,K,J,ie),te&&this.onRenderTargetChange.emit(ee),ee}clear(X=CLEAR.ALL,K){X&&this.adaptor.clear(this.renderTarget,X,K,this.viewport)}push(X,K=CLEAR.ALL,J,Q){const ee=this.bind(X,K,J,Q);return this._renderTargetStack.push({renderTarget:ee,frame:Q}),ee}pop(){this._renderTargetStack.pop();const X=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(X.renderTarget,!1,null,X.frame)}getRenderTarget(X){var K;return X instanceof Texture&&(X=X.source),(K=this._renderSurfaceToRenderTargetHash.get(X))!=null?K:this._initRenderTarget(X)}copyToTexture(X,K,J,Q){return this.adaptor.copyToTexture(X,K,J,Q)}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((X,K)=>{X!==K&&X.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(X){let K=null;return CanvasSource.test(X)&&(X=getCanvasTexture(X)),X instanceof RenderTarget?K=X:X instanceof TextureSource&&(K=new RenderTarget({colorTextures:[X],depthTexture:X.source.depthStencil}),CanvasSource.test(X.source.resource)&&(K.isRoot=!0),X.on("destroy",()=>{K.destroy()})),this._renderSurfaceToRenderTargetHash.set(X,K),K}getGpuRenderTarget(X){return this._gpuRenderTargetHash[X.uid]||(this._gpuRenderTargetHash[X.uid]=this.adaptor.initGpuRenderTarget(X))}}class GlRenderTargetSystem extends RenderTargetSystem{constructor(X){super(X),this.adaptor=new GlRenderTargetAdaptor,this.adaptor.init(X,this)}}GlRenderTargetSystem.extension={type:[u$z.WebGLSystem],name:"renderTarget"};const GpuStencilModesToPixi=[];GpuStencilModesToPixi[STENCIL_MODES.NONE]=void 0,GpuStencilModesToPixi[STENCIL_MODES.DISABLED]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilWriteMask:0,stencilReadMask:0,stencilBack:{compare:"always",passOp:"keep"}},GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilBack:{compare:"always",passOp:"increment-clamp"}},GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilBack:{compare:"always",passOp:"increment-clamp"}},GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilBack:{compare:"always",passOp:"decrement-clamp"}},GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilWriteMask:0,stencilBack:{compare:"equal",passOp:"keep"}};class GlStencilSystem{constructor(X){this._stencilCache={enabled:!1,stencilReference:0,stencilMode:STENCIL_MODES.NONE},this._renderTargetStencilState=Object.create(null),X.renderTarget.onRenderTargetChange.add(this)}contextChange(X){this._gl=X,this._comparisonFuncMapping={always:X.ALWAYS,never:X.NEVER,equal:X.EQUAL,"not-equal":X.NOTEQUAL,less:X.LESS,"less-equal":X.LEQUAL,greater:X.GREATER,"greater-equal":X.GEQUAL},this._stencilOpsMapping={keep:X.KEEP,zero:X.ZERO,replace:X.REPLACE,invert:X.INVERT,"increment-clamp":X.INCR,"decrement-clamp":X.DECR,"increment-wrap":X.INCR_WRAP,"decrement-wrap":X.DECR_WRAP}}onRenderTargetChange(X){if(this._activeRenderTarget===X)return;this._activeRenderTarget=X;let K=this._renderTargetStencilState[X.uid];K||(K=this._renderTargetStencilState[X.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this.setStencilMode(K.stencilMode,K.stencilReference)}setStencilMode(X,K){const J=this._renderTargetStencilState[this._activeRenderTarget.uid],Q=this._gl,ee=GpuStencilModesToPixi[X],te=this._stencilCache;if(J.stencilMode=X,J.stencilReference=K,X===STENCIL_MODES.DISABLED){this._stencilCache.enabled&&(this._stencilCache.enabled=!1,Q.disable(Q.STENCIL_TEST));return}this._stencilCache.enabled||(this._stencilCache.enabled=!0,Q.enable(Q.STENCIL_TEST)),(X!==te.stencilMode||te.stencilReference!==K)&&(te.stencilMode=X,te.stencilReference=K,Q.stencilFunc(this._comparisonFuncMapping[ee.stencilBack.compare],K,255),Q.stencilOp(Q.KEEP,Q.KEEP,this._stencilOpsMapping[ee.stencilBack.passOp]))}}GlStencilSystem.extension={type:[u$z.WebGLSystem],name:"stencil"};class IGLUniformData{}class GlProgramData{constructor(X,K){this.program=X,this.uniformData=K,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBlockBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBlockBindings=null,this.program=null}}class BufferResource extends eventemitter3{constructor({buffer:X,offset:K,size:J}){super(),this.uid=uid("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=uid("buffer"),this._bufferResource=!0,this.buffer=X,this.offset=K|0,this.size=J,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=uid("buffer"),this.emit("change",this)}destroy(X=!1){X&&this.buffer.destroy(),this.buffer=null}}function compileShader(Z,X,K){const J=Z.createShader(X);return Z.shaderSource(J,K),Z.compileShader(J),J}function n$8(Z){const X=new Array(Z);for(let K=0;K<X.length;K++)X[K]=!1;return X}function defaultValue(Z,X){switch(Z){case"float":return 0;case"vec2":return new Float32Array(2*X);case"vec3":return new Float32Array(3*X);case"vec4":return new Float32Array(4*X);case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"ivec2":return new Int32Array(2*X);case"ivec3":return new Int32Array(3*X);case"ivec4":return new Int32Array(4*X);case"uvec2":return new Uint32Array(2*X);case"uvec3":return new Uint32Array(3*X);case"uvec4":return new Uint32Array(4*X);case"bool":return!1;case"bvec2":return n$8(2*X);case"bvec3":return n$8(3*X);case"bvec4":return n$8(4*X);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const t$2={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,uint:1,uvec2:2,uvec3:3,uvec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1};function mapSize(Z){return t$2[Z]}let _$2=null;const N={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"};function mapType(Z,X){if(!_$2){const K=Object.keys(N);_$2={};for(let J=0;J<K.length;++J){const Q=K[J];_$2[Z[Q]]=N[Q]}}return _$2[X]}function getAttributeData(Z,X){const K={},J=X.getProgramParameter(Z,X.ACTIVE_ATTRIBUTES);for(let Q=0;Q<J;Q++){const ee=X.getActiveAttrib(Z,Q);if(ee.name.startsWith("gl_"))continue;const te=mapType(X,ee.type),re={type:te,name:ee.name,size:mapSize(te),location:X.getAttribLocation(Z,ee.name)};K[ee.name]=re}return K}function getUniformBufferData(Z,X){const K={},J=X.getProgramParameter(Z,X.ACTIVE_UNIFORM_BLOCKS);for(let Q=0;Q<J;Q++){const ee=X.getActiveUniformBlockName(Z,Q),te=X.getUniformBlockIndex(Z,ee),re=X.getActiveUniformBlockParameter(Z,Q,X.UNIFORM_BLOCK_DATA_SIZE);K[ee]={name:ee,index:te,size:re}}return K}function getUniformData(Z,X){const K={},J=X.getProgramParameter(Z,X.ACTIVE_UNIFORMS);for(let Q=0;Q<J;Q++){const ee=X.getActiveUniform(Z,Q),te=ee.name.replace(/\[.*?\]$/,""),re=!!ee.name.match(/\[.*?\]$/),ne=mapType(X,ee.type);K[te]={name:te,index:Q,type:ne,size:ee.size,isArray:re,value:defaultValue(ne,ee.size)}}return K}function c$6(Z,X){const K=Z.getShaderSource(X).split(`
`).map((ie,se)=>`${se}: ${ie}`),J=Z.getShaderInfoLog(X),Q=J.split(`
`),ee={},te=Q.map(ie=>parseFloat(ie.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))).filter(ie=>ie&&!ee[ie]?(ee[ie]=!0,!0):!1),re=[""];te.forEach(ie=>{K[ie-1]=`%c${K[ie-1]}%c`,re.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});const ne=K.join(`
`);re[0]=ne,console.error(J),console.groupCollapsed("click to view full shader code"),console.warn(...re),console.groupEnd()}function logProgramError(Z,X,K,J){Z.getProgramParameter(X,Z.LINK_STATUS)||(Z.getShaderParameter(K,Z.COMPILE_STATUS)||c$6(Z,K),Z.getShaderParameter(J,Z.COMPILE_STATUS)||c$6(Z,J),console.error("PixiJS Error: Could not initialize shader."),Z.getProgramInfoLog(X)!==""&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",Z.getProgramInfoLog(X)))}function generateProgram(Z,X){const K=compileShader(Z,Z.VERTEX_SHADER,X.vertex),J=compileShader(Z,Z.FRAGMENT_SHADER,X.fragment),Q=Z.createProgram();Z.attachShader(Q,K),Z.attachShader(Q,J);const ee=X.transformFeedbackVaryings;ee&&(typeof Z.transformFeedbackVaryings!="function"||Z.transformFeedbackVaryings(Q,ee.names,ee.bufferMode==="separate"?Z.SEPARATE_ATTRIBS:Z.INTERLEAVED_ATTRIBS)),Z.linkProgram(Q),Z.getProgramParameter(Q,Z.LINK_STATUS)||logProgramError(Z,Q,K,J),X._attributeData=getAttributeData(Q,Z),X._uniformData=getUniformData(Q,Z),X._uniformBlockData=getUniformBufferData(Q,Z),Z.deleteShader(K),Z.deleteShader(J);const te={};for(const re in X._uniformData){const ne=X._uniformData[re];te[re]={location:Z.getUniformLocation(Q,re),value:defaultValue(ne.type,ne.size)}}return new GlProgramData(Q,te)}const a$7={textureCount:0,blockIndex:0};class GlShaderSystem{constructor(X){this._activeProgram=null,this._programDataHash=Object.create(null),this._nextIndex=0,this._boundUniformsIdsToIndexHash=Object.create(null),this._boundIndexToUniformsHash=Object.create(null),this._renderer=X}contextChange(X){this._gl=X,this._maxBindings=X.getParameter(X.MAX_UNIFORM_BUFFER_BINDINGS)}bind(X,K){if(this._setProgram(X.glProgram),K)return;a$7.textureCount=0,a$7.blockIndex=0;const J=this._gl,Q=this._getProgramData(X.glProgram);for(const ee in X.groups){const te=X.groups[ee];for(const re in te.resources){const ne=te.resources[re];if(ne instanceof UniformGroup)ne.ubo?this.bindUniformBlock(ne,X._uniformBindMap[ee][re],a$7.blockIndex++):this._updateUniformGroup(ne);else if(ne instanceof BufferResource)this.bindUniformBlock(ne,X._uniformBindMap[ee][re],a$7.blockIndex++);else if(ne instanceof TextureSource){this._renderer.texture.bind(ne,a$7.textureCount);const ie=X._uniformBindMap[ee][re],se=Q.uniformData[ie];se&&(se.value!==a$7.textureCount&&J.uniform1i(se.location,a$7.textureCount),a$7.textureCount++)}else ne instanceof TextureStyle}}}_updateUniformGroup(X){this._renderer.uniformGroup.updateUniformGroup(X,this._activeProgram,a$7)}bindUniformBlock(X,K,J=0){const Q=this._renderer.buffer,ee=this._getProgramData(this._activeProgram),te=X._bufferResource;te&&this._renderer.uniformBuffer.updateUniformGroup(X),Q.updateBuffer(X.buffer);let re=this._boundUniformsIdsToIndexHash[X.uid];if(re===void 0){const se=this._nextIndex++%this._maxBindings,oe=this._boundIndexToUniformsHash[se];oe&&(this._boundUniformsIdsToIndexHash[oe.uid]=void 0),re=this._boundUniformsIdsToIndexHash[X.uid]=se,this._boundIndexToUniformsHash[se]=X,te?Q.bindBufferRange(X.buffer,se,X.offset):Q.bindBufferBase(X.buffer,se)}const ne=this._gl,ie=this._activeProgram._uniformBlockData[K].index;ee.uniformBlockBindings[J]!==re&&(ee.uniformBlockBindings[J]=re,ne.uniformBlockBinding(ee.program,ie,re))}_setProgram(X){if(this._activeProgram===X)return;this._activeProgram=X;const K=this._getProgramData(X);this._gl.useProgram(K.program)}_getProgramData(X){return this._programDataHash[X._key]||this._createProgramData(X)}_createProgramData(X){const K=X._key;return this._programDataHash[K]=generateProgram(this._gl,X),this._programDataHash[K]}destroy(){for(const X of Object.keys(this._programDataHash))this._programDataHash[X].destroy(),this._programDataHash[X]=null;this._programDataHash=null,this._boundUniformsIdsToIndexHash=null}}GlShaderSystem.extension={type:[u$z.WebGLSystem],name:"shader"};let a$6;function unsafeEvalSupported(){if(typeof a$6=="boolean")return a$6;try{a$6=new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")===!0}catch(Z){a$6=!1}return a$6}function parseFunctionBody(Z){const X=Z.toString(),K=X.indexOf("{"),J=X.lastIndexOf("}");if(K===-1||J===-1)throw new Error("getFunctionBody: No body found in function definition");return X.slice(K+1,J).trim()}const GLSL_TO_SINGLE_SETTERS_FN_CACHED={float:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1f(J,K))},vec2:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1])&&(X[0]=K[0],X[1]=K[1],Q.uniform2f(J,K[0],K[1]))},vec3:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],Q.uniform3f(J,K[0],K[1],K[2]))},vec4:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2]||X[3]!==K[3])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],X[3]=K[3],Q.uniform4f(J,K[0],K[1],K[2],K[3]))},int:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1i(J,K))},ivec2:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1])&&(X[0]=K[0],X[1]=K[1],Q.uniform2i(J,K[0],K[1]))},ivec3:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],Q.uniform3i(J,K[0],K[1],K[2]))},ivec4:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2]||X[3]!==K[3])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],X[3]=K[3],Q.uniform4i(J,K[0],K[1],K[2],K[3]))},uint:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1ui(J,K))},uvec2:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1])&&(X[0]=K[0],X[1]=K[1],Q.uniform2ui(J,K[0],K[1]))},uvec3:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],Q.uniform3ui(J,K[0],K[1],K[2]))},uvec4:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2]||X[3]!==K[3])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],X[3]=K[3],Q.uniform4ui(J,K[0],K[1],K[2],K[3]))},bool:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1i(J,K))},bvec2:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1])&&(X[0]=K[0],X[1]=K[1],Q.uniform2i(J,K[0],K[1]))},bvec3:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],Q.uniform3i(J,K[0],K[1],K[2]))},bvec4:(Z,X,K,J,Q)=>{(X[0]!==K[0]||X[1]!==K[1]||X[2]!==K[2]||X[3]!==K[3])&&(X[0]=K[0],X[1]=K[1],X[2]=K[2],X[3]=K[3],Q.uniform4i(J,K[0],K[1],K[2],K[3]))},mat2:(Z,X,K,J,Q)=>{Q.uniformMatrix2fv(J,!1,K)},mat3:(Z,X,K,J,Q)=>{Q.uniformMatrix3fv(J,!1,K)},mat4:(Z,X,K,J,Q)=>{Q.uniformMatrix4fv(J,!1,K)},sampler2D:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1i(J,K))},samplerCube:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1i(J,K))},sampler2DArray:(Z,X,K,J,Q)=>{X!==K&&(Z.value=K,Q.uniform1i(J,K))}},GLSL_TO_SINGLE_SETTERS_CACHED={float:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.float),vec2:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.vec2),vec3:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.vec3),vec4:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.vec4),int:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.int),ivec2:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.ivec2),ivec3:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.ivec3),ivec4:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.ivec4),uint:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.uint),uvec2:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.uvec2),uvec3:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.uvec3),uvec4:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.uvec4),bool:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.bool),bvec2:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.bvec2),bvec3:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.bvec3),bvec4:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.bvec4),mat2:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.mat2),mat3:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.mat3),mat4:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.mat4),sampler2D:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.sampler2D),samplerCube:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.samplerCube),sampler2DArray:parseFunctionBody(GLSL_TO_SINGLE_SETTERS_FN_CACHED.sampler2DArray)},GLSL_TO_ARRAY_SETTERS_FN={float:(Z,X,K)=>{K.uniform1fv(X,Z)},vec2:(Z,X,K)=>{K.uniform2fv(X,Z)},vec3:(Z,X,K)=>{K.uniform3fv(X,Z)},vec4:(Z,X,K)=>{K.uniform4fv(X,Z)},mat2:(Z,X,K)=>{K.uniformMatrix2fv(X,!1,Z)},mat3:(Z,X,K)=>{K.uniformMatrix3fv(X,!1,Z)},mat4:(Z,X,K)=>{K.uniformMatrix4fv(X,!1,Z)},int:(Z,X,K)=>{K.uniform1iv(X,Z)},ivec2:(Z,X,K)=>{K.uniform2iv(X,Z)},ivec3:(Z,X,K)=>{K.uniform3iv(X,Z)},ivec4:(Z,X,K)=>{K.uniform4iv(X,Z)},uint:(Z,X,K)=>{K.uniform1uiv(X,Z)},uvec2:(Z,X,K)=>{K.uniform2uiv(X,Z)},uvec3:(Z,X,K)=>{K.uniform3uiv(X,Z)},uvec4:(Z,X,K)=>{K.uniform4uiv(X,Z)},bool:(Z,X,K)=>{K.uniform1iv(X,Z)},bvec2:(Z,X,K)=>{K.uniform2iv(X,Z)},bvec3:(Z,X,K)=>{K.uniform3iv(X,Z)},bvec4:(Z,X,K)=>{K.uniform4iv(X,Z)},sampler2D:(Z,X,K)=>{K.uniform1iv(X,Z)},samplerCube:(Z,X,K)=>{K.uniform1iv(X,Z)},sampler2DArray:(Z,X,K)=>{K.uniform1iv(X,Z)}},GLSL_TO_ARRAY_SETTERS={float:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.float),vec2:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.vec2),vec3:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.vec3),vec4:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.vec4),mat4:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.mat4),mat3:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.mat3),mat2:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.mat2),int:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.int),ivec2:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.ivec2),ivec3:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.ivec3),ivec4:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.ivec4),uint:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.uint),uvec2:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.uvec2),uvec3:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.uvec3),uvec4:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.uvec4),bool:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.bool),bvec2:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.bvec2),bvec3:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.bvec3),bvec4:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.bvec4),sampler2D:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.sampler2D),samplerCube:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.samplerCube),sampler2DArray:parseFunctionBody(GLSL_TO_ARRAY_SETTERS_FN.sampler2DArray)},y$3={FLOAT_CACHE_LAYER:{test:Z=>Z.type==="float"&&Z.size===1&&!Z.isArray,exec:(Z,X,K,J,Q,ee,te,re)=>{J[Z]!==K[Z].value&&(K[Z].value=J[Z],te.uniform1f(K[Z].location,J[Z]))}},HANDLE_SAMPLERS:{test:(Z,X)=>(Z.type==="sampler2D"||Z.type==="samplerCube"||Z.type==="sampler2DArray")&&Z.size===1&&!Z.isArray&&(X===null||X instanceof Texture),exec:(Z,X,K,J,Q,ee,te,re,ne)=>{ee=ne.textureCount++,re.texture.bind(J[Z],ee),K[Z].value!==ee&&(K[Z].value=ee,te.uniform1i(K[Z].location,ee))}},UPLOAD_PIXI_MAT3:{test:(Z,X)=>Z.type==="mat3"&&Z.size===1&&!Z.isArray&&X.a!==void 0,exec:(Z,X,K,J,Q,ee,te)=>{te.uniformMatrix3fv(K[Z].location,!1,J[Z].toArray(!0))}},UPLOAD_PIXI_VEC2_CACHE:{test:(Z,X)=>Z.type==="vec2"&&Z.size===1&&!Z.isArray&&X.x!==void 0,exec:(Z,X,K,J,Q,ee,te)=>{X=K[Z].value,Q=J[Z],(X[0]!==Q.x||X[1]!==Q.y)&&(X[0]=Q.x,X[1]=Q.y,te.uniform2f(K[Z].location,Q.x,Q.y))}},VEC2_CACHE_LAYER:{test:Z=>Z.type==="vec2"&&Z.size===1&&!Z.isArray,exec:(Z,X,K,J,Q,ee,te)=>{X=K[Z].value,Q=J[Z],(X[0]!==Q[0]||X[1]!==Q[1])&&(X[0]=Q[0],X[1]=Q[1],te.uniform2f(K[Z].location,Q[0],Q[1]))}},UPLOAD_PIXI_RECT_VEC4_CACHE:{test:(Z,X)=>Z.type==="vec4"&&Z.size===1&&!Z.isArray&&X.width!==void 0,exec:(Z,X,K,J,Q,ee,te)=>{X=K[Z].value,Q=J[Z],(X[0]!==Q.x||X[1]!==Q.y||X[2]!==Q.width||X[3]!==Q.height)&&(X[0]=Q.x,X[1]=Q.y,X[2]=Q.width,X[3]=Q.height,te.uniform4f(K[Z].location,Q.x,Q.y,Q.width,Q.height))}},UPLOAD_PIXI_COLOR_VEC4_CACHE:{test:(Z,X)=>Z.type==="vec4"&&Z.size===1&&!Z.isArray&&X.red!==void 0,exec:(Z,X,K,J,Q,ee,te)=>{X=K[Z].value,Q=J[Z],(X[0]!==Q.red||X[1]!==Q.green||X[2]!==Q.blue||X[3]!==Q.alpha)&&(X[0]=Q.red,X[1]=Q.green,X[2]=Q.blue,X[3]=Q.alpha,te.uniform4f(K[Z].location,Q.red,Q.green,Q.blue,Q.alpha))}},UPLOAD_PIXI_COLOR_VEC3_CACHE:{test:(Z,X)=>Z.type==="vec3"&&Z.size===1&&!Z.isArray&&X.red!==void 0,exec:(Z,X,K,J,Q,ee,te)=>{X=K[Z].value,Q=J[Z],(X[0]!==Q.red||X[1]!==Q.green||X[2]!==Q.blue)&&(X[0]=Q.red,X[1]=Q.green,X[2]=Q.blue,te.uniform3f(K[Z].location,Q.red,Q.green,Q.blue))}},VEC4_CACHE_LAYER:{test:Z=>Z.type==="vec4"&&Z.size===1&&!Z.isArray,exec:(Z,X,K,J,Q,ee,te)=>{X=K[Z].value,Q=J[Z],(X[0]!==Q[0]||X[1]!==Q[1]||X[2]!==Q[2]||X[3]!==Q[3])&&(X[0]=Q[0],X[1]=Q[1],X[2]=Q[2],X[3]=Q[3],te.uniform4f(K[Z].location,Q[0],Q[1],Q[2],Q[3]))}}},uniformParsers=[{test:y$3.FLOAT_CACHE_LAYER.test,code:parseFunctionBody(y$3.FLOAT_CACHE_LAYER.exec),exec:y$3.FLOAT_CACHE_LAYER.exec},{test:y$3.HANDLE_SAMPLERS.test,code:parseFunctionBody(y$3.HANDLE_SAMPLERS.exec),exec:y$3.HANDLE_SAMPLERS.exec},{test:y$3.UPLOAD_PIXI_MAT3.test,code:parseFunctionBody(y$3.UPLOAD_PIXI_MAT3.exec),exec:y$3.UPLOAD_PIXI_MAT3.exec},{test:y$3.UPLOAD_PIXI_VEC2_CACHE.test,code:parseFunctionBody(y$3.UPLOAD_PIXI_VEC2_CACHE.exec),exec:y$3.UPLOAD_PIXI_VEC2_CACHE.exec},{test:y$3.VEC2_CACHE_LAYER.test,code:parseFunctionBody(y$3.VEC2_CACHE_LAYER.exec),exec:y$3.VEC2_CACHE_LAYER.exec},{test:y$3.UPLOAD_PIXI_RECT_VEC4_CACHE.test,code:parseFunctionBody(y$3.UPLOAD_PIXI_RECT_VEC4_CACHE.exec),exec:y$3.UPLOAD_PIXI_RECT_VEC4_CACHE.exec},{test:y$3.UPLOAD_PIXI_COLOR_VEC4_CACHE.test,code:parseFunctionBody(y$3.UPLOAD_PIXI_COLOR_VEC4_CACHE.exec),exec:y$3.UPLOAD_PIXI_COLOR_VEC4_CACHE.exec},{test:y$3.UPLOAD_PIXI_COLOR_VEC3_CACHE.test,code:parseFunctionBody(y$3.UPLOAD_PIXI_COLOR_VEC3_CACHE.exec),exec:y$3.UPLOAD_PIXI_COLOR_VEC3_CACHE.exec},{test:y$3.VEC4_CACHE_LAYER.test,code:parseFunctionBody(y$3.VEC4_CACHE_LAYER.exec),exec:y$3.VEC4_CACHE_LAYER.exec}];function generateUniformsSync(Z,X){const K=[`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];for(const J in Z.uniforms){const Q=X[J];if(!Q){Z.uniforms[J]instanceof UniformGroup?Z.uniforms[J].ubo?K.push(`
                        renderer.shader.bindUniformBlock(uv.${J}, "${J}");
                    `):K.push(`
                        renderer.shader.updateUniformGroup(uv.${J});
                    `):Z.uniforms[J]instanceof BufferResource&&K.push(`
                        renderer.shader.bindBufferResource(uv.${J}, "${J}");
                    `);continue}const ee=Z.uniforms[J];let te=!1;for(let re=0;re<uniformParsers.length;re++)if(uniformParsers[re].test(Q,ee)){K.push(`name = "${J}";`,uniformParsers[re].code),te=!0;break}if(!te){const re=(Q.size===1&&!Q.isArray?GLSL_TO_SINGLE_SETTERS_CACHED:GLSL_TO_ARRAY_SETTERS)[Q.type].replace("location",`ud["${J}"].location`);K.push(`
            cu = ud["${J}"];
            cv = cu.value;
            v = uv["${J}"];
            ${re};`)}}return new Function("ud","uv","renderer","syncData",K.join(`
`))}class GlUniformGroupSystem{constructor(X){this._cache={},this._uniformGroupSyncHash={},this._renderer=X,this._systemCheck(),this.gl=null,this._cache={}}_systemCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}contextChange(X){this.gl=X}updateUniformGroup(X,K,J){const Q=this._renderer.shader._getProgramData(K);(!X.isStatic||X._dirtyId!==Q.uniformDirtyGroups[X.uid])&&(Q.uniformDirtyGroups[X.uid]=X._dirtyId,this._getUniformSyncFunction(X,K)(Q.uniformData,X.uniforms,this._renderer,J))}_getUniformSyncFunction(X,K){var J;return((J=this._uniformGroupSyncHash[X._signature])==null?void 0:J[K._key])||this._createUniformSyncFunction(X,K)}_createUniformSyncFunction(X,K){const J=this._uniformGroupSyncHash[X._signature]||(this._uniformGroupSyncHash[X._signature]={}),Q=this._getSignature(X,K._uniformData,"u");return this._cache[Q]||(this._cache[Q]=this._generateUniformsSync(X,K._uniformData)),J[K._key]=this._cache[Q],J[K._key]}_generateUniformsSync(X,K){return generateUniformsSync(X,K)}_getSignature(X,K,J){const Q=X.uniforms,ee=[`${J}-`];for(const te in Q)ee.push(te),K[te]&&ee.push(K[te].type);return ee.join("-")}destroy(){this._renderer=null,this._cache=null}}GlUniformGroupSystem.extension={type:[u$z.WebGLSystem],name:"uniformGroup"};function migrateFragmentFromV7toV8(Z){return Z=Z.replaceAll("texture2D","texture").replaceAll("gl_FragColor","fragColor").replaceAll("varying","in"),Z=`
        out vec4 fragColor;
    ${Z}
    `,Z}function mapWebGLBlendModesToPixi(Z){const X={};return X.normal=[Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.add=[Z.ONE,Z.ONE],X.multiply=[Z.DST_COLOR,Z.ONE_MINUS_SRC_ALPHA,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.screen=[Z.ONE,Z.ONE_MINUS_SRC_COLOR,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.none=[0,0],X["normal-npm"]=[Z.SRC_ALPHA,Z.ONE_MINUS_SRC_ALPHA,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X["add-npm"]=[Z.SRC_ALPHA,Z.ONE,Z.ONE,Z.ONE],X["screen-npm"]=[Z.SRC_ALPHA,Z.ONE_MINUS_SRC_COLOR,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.erase=[Z.ZERO,Z.ONE_MINUS_SRC_ALPHA],X}const h$8=0,n$7=1,a$5=2,c$5=3,p$6=4,b$7=5,i$6=class{constructor(){this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode="none",this._blendEq=!1,this.map=[],this.map[h$8]=this.setBlend,this.map[n$7]=this.setOffset,this.map[a$5]=this.setCullFace,this.map[c$5]=this.setDepthTest,this.map[p$6]=this.setFrontFace,this.map[b$7]=this.setDepthMask,this.checks=[],this.defaultState=new State,this.defaultState.blend=!0}contextChange(Z){this.gl=Z,this.blendModesMap=mapWebGLBlendModesToPixi(Z),this.set(this.defaultState),this.reset()}set(Z){if(Z=Z||this.defaultState,this.stateId!==Z.data){let X=this.stateId^Z.data,K=0;for(;X;)X&1&&this.map[K].call(this,!!(Z.data&1<<K)),X=X>>1,K++;this.stateId=Z.data}for(let X=0;X<this.checks.length;X++)this.checks[X](this,Z)}forceState(Z){Z=Z||this.defaultState;for(let X=0;X<this.map.length;X++)this.map[X].call(this,!!(Z.data&1<<X));for(let X=0;X<this.checks.length;X++)this.checks[X](this,Z);this.stateId=Z.data}setBlend(Z){this._updateCheck(i$6._checkBlendMode,Z),this.gl[Z?"enable":"disable"](this.gl.BLEND)}setOffset(Z){this._updateCheck(i$6._checkPolygonOffset,Z),this.gl[Z?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(Z){this.gl[Z?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(Z){this.gl.depthMask(Z)}setCullFace(Z){this.gl[Z?"enable":"disable"](this.gl.CULL_FACE)}setFrontFace(Z){this.gl.frontFace(this.gl[Z?"CW":"CCW"])}setBlendMode(Z){if(this.blendModesMap[Z]||(Z="normal"),Z===this.blendMode)return;this.blendMode=Z;const X=this.blendModesMap[Z],K=this.gl;X.length===2?K.blendFunc(X[0],X[1]):K.blendFuncSeparate(X[0],X[1],X[2],X[3]),X.length===6?(this._blendEq=!0,K.blendEquationSeparate(X[4],X[5])):this._blendEq&&(this._blendEq=!1,K.blendEquationSeparate(K.FUNC_ADD,K.FUNC_ADD))}setPolygonOffset(Z,X){this.gl.polygonOffset(Z,X)}reset(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode="",this.setBlendMode("normal")}_updateCheck(Z,X){const K=this.checks.indexOf(Z);X&&K===-1?this.checks.push(Z):!X&&K!==-1&&this.checks.splice(K,1)}static _checkBlendMode(Z,X){Z.setBlendMode(X.blendMode)}static _checkPolygonOffset(Z,X){Z.setPolygonOffset(1,X.polygonOffset)}destroy(){this.gl=null,this.checks.length=0}};let GlStateSystem=i$6;GlStateSystem.extension={type:[u$z.WebGLSystem],name:"state"};class GlTexture{constructor(X){this.target=GL_TARGETS.TEXTURE_2D,this.texture=X,this.width=-1,this.height=-1,this.type=GL_TYPES.UNSIGNED_BYTE,this.internalFormat=GL_FORMATS.RGBA,this.format=GL_FORMATS.RGBA,this.samplerType=0}}const glUploadBufferImageResource={id:"image",upload(Z,X,K){X.width===Z.width||X.height===Z.height?K.texSubImage2D(K.TEXTURE_2D,0,0,0,X.format,X.type,Z.resource):K.texImage2D(X.target,0,X.internalFormat,Z.width,Z.height,0,X.format,X.type,Z.resource),X.width=Z.width,X.height=Z.height}},s$a={"bc2-rgba-unorm":!0,"bc3-rgba-unorm":!0,"bc7-rgba-unorm":!0,"etc2-rgba8unorm":!0,"astc-4x4-unorm":!0},glUploadCompressedTextureResource={id:"compressed",upload(Z,X,K){K.pixelStorei(K.UNPACK_ALIGNMENT,4);let J=Z.pixelWidth,Q=Z.pixelHeight;const ee=!!s$a[Z.format];for(let te=0;te<Z.resource.length;te++){const re=Z.resource[te];ee?K.compressedTexImage2D(K.TEXTURE_2D,te,X.internalFormat,J,Q,0,re):K.texImage2D(K.TEXTURE_2D,te,X.internalFormat,J,Q,0,X.format,X.type,re),J=Math.max(J>>1,1),Q=Math.max(Q>>1,1)}}},glUploadImageResource={id:"image",upload(Z,X,K){const J=Z.alphaMode==="premultiply-alpha-on-upload";K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL,J);const Q=X.width,ee=X.height,te=Z.pixelWidth,re=Z.pixelHeight,ne=Z.resourceWidth,ie=Z.resourceHeight;ne<te||ie<re?((Q!==te||ee!==re)&&K.texImage2D(X.target,0,X.internalFormat,te,re,0,X.format,X.type,null),K.texSubImage2D(K.TEXTURE_2D,0,0,0,ne,ie,X.format,X.type,Z.resource)):Q===te||ee===re?K.texSubImage2D(K.TEXTURE_2D,0,0,0,X.format,X.type,Z.resource):K.texImage2D(X.target,0,X.internalFormat,te,re,0,X.format,X.type,Z.resource),X.width=te,X.height=re}},glUploadVideoResource={id:"video",upload(Z,X,K){if(!Z.isValid){K.texImage2D(X.target,0,X.internalFormat,1,1,0,X.format,X.type,null);return}glUploadImageResource.upload(Z,X,K)}},scaleModeToGlFilter={linear:9729,nearest:9728},mipmapScaleModeToGlFilter={linear:{linear:9987,nearest:9985},nearest:{linear:9986,nearest:9984}},wrapModeToGlAddress={"clamp-to-edge":33071,repeat:10497,"mirror-repeat":33648},compareModeToGlCompare={never:512,less:513,equal:514,"less-equal":515,greater:516,"not-equal":517,"greater-equal":518,always:519};function applyStyleParams(Z,X,K,J,Q,ee){const te=ee;if(X[Q](te,X.TEXTURE_WRAP_S,wrapModeToGlAddress[Z.addressModeU]),X[Q](te,X.TEXTURE_WRAP_T,wrapModeToGlAddress[Z.addressModeV]),X[Q](te,X.TEXTURE_WRAP_R,wrapModeToGlAddress[Z.addressModeW]),X[Q](te,X.TEXTURE_MAG_FILTER,scaleModeToGlFilter[Z.magFilter]),K){const re=mipmapScaleModeToGlFilter[Z.minFilter][Z.mipmapFilter];X[Q](te,X.TEXTURE_MIN_FILTER,re)}else X[Q](te,X.TEXTURE_MIN_FILTER,scaleModeToGlFilter[Z.minFilter]);if(J&&Z.maxAnisotropy>1){const re=Math.min(Z.maxAnisotropy,X.getParameter(J.MAX_TEXTURE_MAX_ANISOTROPY_EXT));X[Q](te,J.TEXTURE_MAX_ANISOTROPY_EXT,re)}Z.compare&&X[Q](te,X.TEXTURE_COMPARE_FUNC,compareModeToGlCompare[Z.compare])}function mapFormatToGlFormat(Z){return{r8unorm:Z.RED,r8snorm:Z.RED,r8uint:Z.RED,r8sint:Z.RED,r16uint:Z.RED,r16sint:Z.RED,r16float:Z.RED,rg8unorm:Z.RG,rg8snorm:Z.RG,rg8uint:Z.RG,rg8sint:Z.RG,r32uint:Z.RED,r32sint:Z.RED,r32float:Z.RED,rg16uint:Z.RG,rg16sint:Z.RG,rg16float:Z.RG,rgba8unorm:Z.RGBA,"rgba8unorm-srgb":Z.RGBA,rgba8snorm:Z.RGBA,rgba8uint:Z.RGBA,rgba8sint:Z.RGBA,bgra8unorm:Z.RGBA,"bgra8unorm-srgb":Z.RGBA,rgb9e5ufloat:Z.RGB,rgb10a2unorm:Z.RGBA,rg11b10ufloat:Z.RGB,rg32uint:Z.RG,rg32sint:Z.RG,rg32float:Z.RG,rgba16uint:Z.RGBA,rgba16sint:Z.RGBA,rgba16float:Z.RGBA,rgba32uint:Z.RGBA,rgba32sint:Z.RGBA,rgba32float:Z.RGBA,stencil8:Z.STENCIL_INDEX8,depth16unorm:Z.DEPTH_COMPONENT,depth24plus:Z.DEPTH_COMPONENT,"depth24plus-stencil8":Z.DEPTH_STENCIL,depth32float:Z.DEPTH_COMPONENT,"depth32float-stencil8":Z.DEPTH_STENCIL}}var a$4=Object.defineProperty,E=Object.getOwnPropertySymbols,t$1=Object.prototype.hasOwnProperty,C$1=Object.prototype.propertyIsEnumerable,A$2=(Z,X,K)=>X in Z?a$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,S$1=(Z,X)=>{for(var K in X||(X={}))t$1.call(X,K)&&A$2(Z,K,X[K]);if(E)for(var K of E(X))C$1.call(X,K)&&A$2(Z,K,X[K]);return Z};function mapFormatToGlInternalFormat(Z,X){return S$1(S$1(S$1(S$1(S$1({r8unorm:Z.R8,r8snorm:Z.R8_SNORM,r8uint:Z.R8UI,r8sint:Z.R8I,r16uint:Z.R16UI,r16sint:Z.R16I,r16float:Z.R16F,rg8unorm:Z.RG8,rg8snorm:Z.RG8_SNORM,rg8uint:Z.RG8UI,rg8sint:Z.RG8I,r32uint:Z.R32UI,r32sint:Z.R32I,r32float:Z.R32F,rg16uint:Z.RG16UI,rg16sint:Z.RG16I,rg16float:Z.RG16F,rgba8unorm:Z.RGBA,"rgba8unorm-srgb":Z.SRGB8_ALPHA8,rgba8snorm:Z.RGBA8_SNORM,rgba8uint:Z.RGBA8UI,rgba8sint:Z.RGBA8I,bgra8unorm:Z.RGBA8,"bgra8unorm-srgb":Z.SRGB8_ALPHA8,rgb9e5ufloat:Z.RGB9_E5,rgb10a2unorm:Z.RGB10_A2,rg11b10ufloat:Z.R11F_G11F_B10F,rg32uint:Z.RG32UI,rg32sint:Z.RG32I,rg32float:Z.RG32F,rgba16uint:Z.RGBA16UI,rgba16sint:Z.RGBA16I,rgba16float:Z.RGBA16F,rgba32uint:Z.RGBA32UI,rgba32sint:Z.RGBA32I,rgba32float:Z.RGBA32F,stencil8:Z.STENCIL_INDEX8,depth16unorm:Z.DEPTH_COMPONENT16,depth24plus:Z.DEPTH_COMPONENT24,"depth24plus-stencil8":Z.DEPTH24_STENCIL8,depth32float:Z.DEPTH_COMPONENT32F,"depth32float-stencil8":Z.DEPTH32F_STENCIL8},X.s3tc?{"bc2-rgba-unorm":X.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,"bc3-rgba-unorm":X.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT}:{}),X.s3tc_sRGB?{"bc2-rgba-unorm-srgb":X.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,"bc3-rgba-unorm-srgb":X.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}:{}),X.bptc?{"bc7-rgba-unorm":X.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,"bc7-rgba-unorm-srgb":X.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT}:{}),X.etc?{"etc2-rgb8unorm":X.etc.COMPRESSED_RGB8_ETC2,"etc2-rgb8unorm-srgb":X.etc.COMPRESSED_SRGB8_ETC2,"etc2-rgb8a1unorm":X.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgb8a1unorm-srgb":X.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgba8unorm":X.etc.COMPRESSED_RGBA8_ETC2_EAC,"etc2-rgba8unorm-srgb":X.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,"eac-r11unorm":X.etc.COMPRESSED_R11_EAC,"eac-rg11unorm":X.etc.COMPRESSED_SIGNED_RG11_EAC}:{}),X.astc?{"astc-4x4-unorm":X.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,"astc-4x4-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,"astc-5x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,"astc-5x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,"astc-6x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,"astc-6x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,"astc-6x6-unorm":X.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,"astc-6x6-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,"astc-8x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,"astc-8x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,"astc-8x6-unorm":X.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,"astc-8x6-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,"astc-8x8-unorm":X.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,"astc-8x8-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,"astc-10x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,"astc-10x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,"astc-10x6-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,"astc-10x6-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,"astc-10x8-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,"astc-10x8-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,"astc-10x10-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,"astc-10x10-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,"astc-12x10-unorm":X.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,"astc-12x10-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,"astc-12x12-unorm":X.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,"astc-12x12-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR}:{})}function mapFormatToGlType(Z){return{r8unorm:Z.UNSIGNED_BYTE,r8snorm:Z.BYTE,r8uint:Z.UNSIGNED_BYTE,r8sint:Z.BYTE,r16uint:Z.UNSIGNED_SHORT,r16sint:Z.SHORT,r16float:Z.HALF_FLOAT,rg8unorm:Z.UNSIGNED_BYTE,rg8snorm:Z.BYTE,rg8uint:Z.UNSIGNED_BYTE,rg8sint:Z.BYTE,r32uint:Z.UNSIGNED_INT,r32sint:Z.INT,r32float:Z.FLOAT,rg16uint:Z.UNSIGNED_SHORT,rg16sint:Z.SHORT,rg16float:Z.HALF_FLOAT,rgba8unorm:Z.UNSIGNED_BYTE,"rgba8unorm-srgb":Z.UNSIGNED_BYTE,rgba8snorm:Z.BYTE,rgba8uint:Z.UNSIGNED_BYTE,rgba8sint:Z.BYTE,bgra8unorm:Z.UNSIGNED_BYTE,"bgra8unorm-srgb":Z.UNSIGNED_BYTE,rgb9e5ufloat:Z.UNSIGNED_INT_5_9_9_9_REV,rgb10a2unorm:Z.UNSIGNED_INT_2_10_10_10_REV,rg11b10ufloat:Z.UNSIGNED_INT_10F_11F_11F_REV,rg32uint:Z.UNSIGNED_INT,rg32sint:Z.INT,rg32float:Z.FLOAT,rgba16uint:Z.UNSIGNED_SHORT,rgba16sint:Z.SHORT,rgba16float:Z.HALF_FLOAT,rgba32uint:Z.UNSIGNED_INT,rgba32sint:Z.INT,rgba32float:Z.FLOAT,stencil8:Z.UNSIGNED_BYTE,depth16unorm:Z.UNSIGNED_SHORT,depth24plus:Z.UNSIGNED_INT,"depth24plus-stencil8":Z.UNSIGNED_INT_24_8,depth32float:Z.FLOAT,"depth32float-stencil8":Z.FLOAT_32_UNSIGNED_INT_24_8_REV}}function unpremultiplyAlpha(Z){Z instanceof Uint8ClampedArray&&(Z=new Uint8Array(Z.buffer));const X=Z.length;for(let K=0;K<X;K+=4){const J=Z[K+3];if(J!==0){const Q=255.001/J;Z[K]=Z[K]*Q+.5,Z[K+1]=Z[K+1]*Q+.5,Z[K+2]=Z[K+2]*Q+.5}}}const v$4=4;class GlTextureSystem{constructor(X){this.managedTextures=[],this._glTextures=Object.create(null),this._glSamplers=Object.create(null),this._boundTextures=[],this._activeTextureLocation=-1,this._boundSamplers=Object.create(null),this._uploads={image:glUploadImageResource,buffer:glUploadBufferImageResource,video:glUploadVideoResource,compressed:glUploadCompressedTextureResource},this._useSeparateSamplers=!1,this._renderer=X}contextChange(X){if(this._gl=X,!this._mapFormatToInternalFormat){const K=this._renderer.context.extensions;this._mapFormatToInternalFormat=mapFormatToGlInternalFormat(X,K),this._mapFormatToType=mapFormatToGlType(X),this._mapFormatToFormat=mapFormatToGlFormat(X)}for(let K=0;K<16;K++)this.bind(Texture.EMPTY,K)}initSource(X){this.bind(X)}bind(X,K=0){const J=X.source;X?(this.bindSource(J,K),this._useSeparateSamplers&&this._bindSampler(J.style,K)):(this.bindSource(null,K),this._useSeparateSamplers&&this._bindSampler(null,K))}bindSource(X,K=0){const J=this._gl;if(X._touched=this._renderer.textureGC.count,this._boundTextures[K]!==X){this._boundTextures[K]=X,this._activateLocation(K),X=X||Texture.EMPTY.source;const Q=this.getGlSource(X);J.bindTexture(Q.target,Q.texture)}}_bindSampler(X,K=0){const J=this._gl;if(!X){this._boundSamplers[K]=null,J.bindSampler(K,null);return}const Q=this._getGlSampler(X);this._boundSamplers[K]!==Q&&(this._boundSamplers[K]=Q,J.bindSampler(K,Q))}unbind(X){const K=X.source,J=this._boundTextures,Q=this._gl;for(let ee=0;ee<J.length;ee++)if(J[ee]===K){this._activateLocation(ee);const te=this.getGlSource(K);Q.bindTexture(te.target,null),J[ee]=null}}_activateLocation(X){this._activeTextureLocation!==X&&(this._activeTextureLocation=X,this._gl.activeTexture(this._gl.TEXTURE0+X))}_initSource(X){const K=this._gl,J=new GlTexture(K.createTexture());if(J.type=this._mapFormatToType[X.format],J.internalFormat=this._mapFormatToInternalFormat[X.format],J.format=this._mapFormatToFormat[X.format],X.autoGenerateMipmaps){const Q=Math.max(X.width,X.height);X.mipLevelCount=Math.floor(Math.log2(Q))+1}return this._glTextures[X.uid]=J,X.on("update",this.onSourceUpdate,this),X.on("resize",this.onSourceUpdate,this),X.on("styleChange",this.onStyleChange,this),X.on("destroy",this.onSourceDestroy,this),X.on("unload",this.onSourceUnload,this),X.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(X),this.onSourceUpdate(X),this.onStyleChange(X),J}onStyleChange(X){const K=this._gl,J=this.getGlSource(X);K.bindTexture(K.TEXTURE_2D,J.texture),this._boundTextures[this._activeTextureLocation]=X,applyStyleParams(X.style,K,X.mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"texParameteri",K.TEXTURE_2D)}onSourceUnload(X){const K=this._glTextures[X.uid];K&&(this.unbind(X),this._glTextures[X.uid]=null,this._gl.deleteTexture(K.texture))}onSourceUpdate(X){const K=this._gl,J=this.getGlSource(X);K.bindTexture(K.TEXTURE_2D,J.texture),this._boundTextures[this._activeTextureLocation]=X,this._uploads[X.uploadMethodId]?this._uploads[X.uploadMethodId].upload(X,J,this._gl):K.texImage2D(K.TEXTURE_2D,0,K.RGBA,X.pixelWidth,X.pixelHeight,0,K.RGBA,K.UNSIGNED_BYTE,null),X.autoGenerateMipmaps&&X.mipLevelCount>1&&this.onUpdateMipmaps(X)}onUpdateMipmaps(X){this.bindSource(X,0);const K=this.getGlSource(X);this._gl.generateMipmap(K.target)}onSourceDestroy(X){X.off("destroy",this.onSourceDestroy,this),X.off("update",this.onSourceUpdate,this),X.off("unload",this.onSourceUnload,this),X.off("styleChange",this.onStyleChange,this),X.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(X),1),this.onSourceUnload(X)}_initSampler(X){const K=this._gl,J=this._gl.createSampler();return this._glSamplers[X._resourceId]=J,applyStyleParams(X,K,this._boundTextures[this._activeTextureLocation].mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"samplerParameteri",J),this._glSamplers[X._resourceId]}_getGlSampler(X){return this._glSamplers[X._resourceId]||this._initSampler(X)}getGlSource(X){return this._glTextures[X.uid]||this._initSource(X)}generateCanvas(X){const{pixels:K,width:J,height:Q}=this.getPixels(X),ee=DOMAdapter.get().createCanvas();ee.width=J,ee.height=Q;const te=ee.getContext("2d");if(te){const re=te.createImageData(J,Q);re.data.set(K),te.putImageData(re,0,0)}return ee}getPixels(X){const K=X.source.resolution,J=X.frame,Q=Math.max(Math.round(J.width*K),1),ee=Math.max(Math.round(J.height*K),1),te=new Uint8Array(v$4*Q*ee),re=this._renderer,ne=re.renderTarget.getRenderTarget(X),ie=re.renderTarget.getGpuRenderTarget(ne),se=re.gl;return se.bindFramebuffer(se.FRAMEBUFFER,ie.resolveTargetFramebuffer),se.readPixels(Math.round(J.x*K),Math.round(J.y*K),Q,ee,se.RGBA,se.UNSIGNED_BYTE,te),{pixels:new Uint8ClampedArray(te.buffer),width:Q,height:ee}}destroy(){this.managedTextures.slice().forEach(X=>this.onSourceDestroy(X)),this.managedTextures=null,this._renderer=null}}GlTextureSystem.extension={type:[u$z.WebGLSystem],name:"texture"};class GlGraphicsAdaptor{init(){const X=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"}}),K=compileHighShaderGlProgram({name:"graphics",bits:[colorBitGl,generateTextureBatchBitGl(MAX_TEXTURES),localUniformBitGl,roundPixelsBitGl]});this.shader=new Shader({glProgram:K,resources:{localUniforms:X,batchSamplers:batchSamplersUniformGroup}})}execute(X,K){const J=K.view.context,Q=J.customShader||this.shader,ee=X.renderer,te=ee.graphicsContext,{geometry:re,instructions:ne}=te.getContextRenderData(J);ee.shader.bind(Q),ee.shader.bindUniformBlock(ee.globalUniforms.uniformGroup,"globalUniforms"),ee.geometry.bind(re,Q.glProgram);const ie=ne.instructions;for(let se=0;se<ne.instructionSize;se++){const oe=ie[se];if(oe.size){for(let ae=0;ae<oe.textures.textures.length;ae++)ee.texture.bind(oe.textures.textures[ae],ae);ee.geometry.draw("triangle-list",oe.size,oe.start)}}}destroy(){this.shader.destroy(!0),this.shader=null}}GlGraphicsAdaptor.extension={type:[u$z.WebGLPipesAdaptor],name:"graphics"};class GlMeshAdaptor{init(){const X=compileHighShaderGlProgram({name:"mesh",bits:[localUniformBitGl,textureBitGl,roundPixelsBitGl]});this._shader=new Shader({glProgram:X,resources:{uTexture:Texture.EMPTY.source}}),this._shader.addResource("globalUniforms",0,0),this._shader.addResource("localUniforms",1,0)}execute(X,K){const J=X.renderer,Q=K.view;let ee=Q._shader;if(!ee){ee=this._shader;const te=Q.texture.source;ee.resources.uTexture=te,ee.resources.uSampler=te.style}ee.groups[0]=J.globalUniforms.bindGroup,ee.groups[1]=X.localUniformsBindGroup,J.encoder.draw({geometry:Q._geometry,shader:ee,state:Q.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GlMeshAdaptor.extension={type:[u$z.WebGLPipesAdaptor],name:"mesh"};function executeInstructions(Z,X){const K=Z.instructionSet,J=K.instructions;for(let Q=0;Q<K.instructionSize;Q++){const ee=J[Q];X[ee.renderPipeId].execute(ee)}}class RenderGroupPipe{constructor(X){this._renderer=X}addRenderGroup(X,K){this._renderer.renderPipes.batch.break(K),K.add(X)}execute(X){X.isRenderable&&(this._renderer.globalUniforms.push({worldTransformMatrix:X.worldTransform,worldColor:X.worldColorAlpha}),executeInstructions(X,this._renderer.renderPipes),this._renderer.globalUniforms.pop())}destroy(){this._renderer=null}}RenderGroupPipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"renderGroup"};function collectRenderGroups(Z,X=[]){X.push(Z);for(let K=0;K<Z.renderGroupChildren.length;K++)collectRenderGroups(Z.renderGroupChildren[K],X);return X}const g$4=new Container;function updateRenderGroupTransforms(Z,X=!1){updateRenderGroupTransform(Z);const K=Z.childrenToUpdate,J=Z.updateTick;Z.updateTick++;for(const Q in K){const ee=K[Q],te=ee.list,re=ee.index;for(let ne=0;ne<re;ne++)updateTransformAndChildren(te[ne],J,0);ee.index=0}if(X)for(let Q=0;Q<Z.renderGroupChildren.length;Q++)updateRenderGroupTransforms(Z.renderGroupChildren[Q],X)}function updateRenderGroupTransform(Z){const X=Z.root;let K;if(Z.renderGroupParent){const J=Z.renderGroupParent;Z.worldTransform.appendFrom(X.rgTransform,J.worldTransform),Z.worldColor=mixColors(X.rgColor,J.worldColor),K=X.rgAlpha*J.worldAlpha}else Z.worldTransform.copyFrom(X.rgTransform),Z.worldColor=X.localColor,K=X.localAlpha;K=K<0?0:K>1?1:K,Z.worldAlpha=K,Z.worldColorAlpha=Z.worldColor+((K*255|0)<<24)}function updateTransformAndChildren(Z,X,K){if(X===Z.updateTick)return;Z.updateTick=X,Z.didChange=!1;const J=Z.localTransform;updateLocalTransform(J,Z);const Q=Z.parent;if(Q&&!Q.isRenderGroupRoot?(K=K|Z._updateFlags,Z.rgTransform.appendFrom(J,Q.rgTransform),K&&n$6(Z,Q,K)):(K=Z._updateFlags,Z.rgTransform.copyFrom(J),K&&n$6(Z,g$4,K)),!Z.isRenderGroupRoot){const ee=Z.children,te=ee.length;for(let ne=0;ne<te;ne++)updateTransformAndChildren(ee[ne],X,K);const re=Z.renderGroup;Z.view&&!re.structureDidChange&&re.updateRenderable(Z)}}function n$6(Z,X,K){if(K&UPDATE_COLOR){Z.rgColor=mixColors(Z.localColor,X.rgColor);const J=Z.localAlpha*X.rgAlpha;Z.rgAlpha=J<0?0:J>1?1:J,Z.rgColorAlpha=Z.rgColor+((J*255|0)<<24)}K&UPDATE_BLEND&&(Z.rgBlendMode=Z.localBlendMode==="inherit"?X.rgBlendMode:Z.localBlendMode),K&UPDATE_VISIBLE&&(Z.rgVisibleRenderable=Z.localVisibleRenderable&X.rgVisibleRenderable),Z._updateFlags=0}function validateRenderables(Z,X){const{list:K,index:J}=Z.childrenRenderablesToUpdate;let Q=!1;for(let ee=0;ee<J;ee++){const te=K[ee],re=te.view;if(Q=X[re.renderPipeId].validateRenderable(te),Q)break}return Z.structureDidChange=Q,Q}class RenderGroupSystem{constructor(X){this._renderer=X}render({container:X,transform:K}){X.isRenderGroup=!0;const J=this._renderer,Q=collectRenderGroups(X.renderGroup,[]),ee=J.renderPipes;for(let te=0;te<Q.length;te++){const re=Q[te];re.runOnRender(),re.instructionSet.renderPipes=ee,re.structureDidChange||validateRenderables(re,ee),updateRenderGroupTransforms(re),re.structureDidChange?(re.structureDidChange=!1,buildInstructions(re,ee)):f$6(re),re.childrenRenderablesToUpdate.index=0,J.renderPipes.batch.upload(re.instructionSet)}K&&X.renderGroup.worldTransform.copyFrom(K),J.globalUniforms.start({worldTransformMatrix:X.renderGroup.worldTransform}),executeInstructions(X.renderGroup,ee),ee.uniformBatch&&ee.uniformBatch.renderEnd()}destroy(){this._renderer=null}}RenderGroupSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"renderGroup"};function f$6(Z){const{list:X,index:K}=Z.childrenRenderablesToUpdate;for(let J=0;J<K;J++){const Q=X[J];Q.didViewUpdate&&Z.updateRenderable(Q)}}let i$5;class SpritePipe{constructor(X){this._gpuSpriteHash=Object.create(null),this._renderer=X,i$5=this._gpuSpriteHash}addRenderable(X,K){const J=this._getGpuSprite(X);X.view._didUpdate&&this._updateBatchableSprite(X,J),this._renderer.renderPipes.batch.addToBatch(J)}updateRenderable(X){const K=i$5[X.uid];X.view._didUpdate&&this._updateBatchableSprite(X,K),K.batcher.updateElement(K)}validateRenderable(X){const K=X.view._texture,J=this._getGpuSprite(X);return J.texture._source!==K._source?!J.batcher.checkAndUpdateTexture(J,K):!1}destroyRenderable(X){const K=i$5[X.uid];BigPool.return(K),i$5[X.uid]=null}_updateBatchableSprite(X,K){const J=X.view;J._didUpdate=!1,K.bounds=J.bounds,K.texture=J._texture}_getGpuSprite(X){return i$5[X.uid]||this._initGPUSprite(X)}_initGPUSprite(X){const K=BigPool.get(BatchableSprite);K.renderable=X;const J=X.view;return K.texture=J._texture,K.bounds=J.bounds,K.roundPixels=this._renderer._roundPixels|J.roundPixels,i$5[X.uid]=K,X.view._didUpdate=!1,X.on("destroyed",()=>{this.destroyRenderable(X)}),K}destroy(){for(const X in this._gpuSpriteHash)BigPool.return(this._gpuSpriteHash[X]);this._gpuSpriteHash=null,this._renderer=null}}SpritePipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"sprite"};var u$9=Object.defineProperty,c$4=Object.getOwnPropertySymbols,s$9=Object.prototype.hasOwnProperty,b$6=Object.prototype.propertyIsEnumerable,n$5=(Z,X,K)=>X in Z?u$9(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$3=(Z,X)=>{for(var K in X||(X={}))s$9.call(X,K)&&n$5(Z,K,X[K]);if(c$4)for(var K of c$4(X))b$6.call(X,K)&&n$5(Z,K,X[K]);return Z};const l$4=class{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color(0),this.color=this._backgroundColor,this.alpha=1}init(Z){Z=a$3(a$3({},l$4.defaultOptions),Z),this.clearBeforeRender=Z.clearBeforeRender,this.color=Z.background||Z.backgroundColor||this._backgroundColor,this.alpha=Z.backgroundAlpha,this._backgroundColor.setAlpha(Z.backgroundAlpha)}get color(){return this._backgroundColor}set color(Z){this._backgroundColor.setValue(Z)}get alpha(){return this._backgroundColor.alpha}set alpha(Z){this._backgroundColor.setAlpha(Z)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};let BackgroundSystem=l$4;BackgroundSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"background",priority:0},BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};const n$4={};b$r.handle(u$z.BlendMode,Z=>{if(!Z.name)throw new Error("BlendMode extension must have a name property");n$4[Z.name]=Z.ref},Z=>{delete n$4[Z.name]});class BlendModePipe{constructor(X){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=X}setBlendMode(X,K,J){if(this._activeBlendMode===K){this._isAdvanced&&this._renderableList.push(X);return}this._activeBlendMode=K,this._isAdvanced&&this._endAdvancedBlendMode(J),this._isAdvanced=!!n$4[K],this._isAdvanced&&(this._beginAdvancedBlendMode(J),this._renderableList.push(X))}_beginAdvancedBlendMode(X){this._renderer.renderPipes.batch.break(X);const K=this._activeBlendMode;if(!n$4[K])return;this._filterHash[K]||(this._filterHash[K]=new FilterEffect({filters:[new n$4[K]]}));const J={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect:this._filterHash[K],canBundle:!1};this._renderableList=J.renderables,X.add(J)}_endAdvancedBlendMode(X){this._renderableList=null,this._renderer.renderPipes.batch.break(X),X.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(X){this._isAdvanced&&this._endAdvancedBlendMode(X)}destroy(){this._renderer=null,this._renderableList=null;for(const X in this._filterHash)this._filterHash[X].destroy();this._filterHash=null}}BlendModePipe.extension={type:[u$z.WebGLPipes,u$z.WebGPUPipes,u$z.CanvasPipes],name:"blendMode"};var f$5=Object.defineProperty,x$6=Object.getOwnPropertySymbols,O$2=Object.prototype.hasOwnProperty,b$5=Object.prototype.propertyIsEnumerable,d$5=(Z,X,K)=>X in Z?f$5(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$8=(Z,X)=>{for(var K in X||(X={}))O$2.call(X,K)&&d$5(Z,K,X[K]);if(x$6)for(var K of x$6(X))b$5.call(X,K)&&d$5(Z,K,X[K]);return Z};const p$5=class{constructor(Z){this._renderer=Z}_normalizeOptions(Z,X={}){return Z instanceof Container||Z instanceof Texture?u$8({target:Z},X):u$8(u$8({},X),Z)}async image(Z){const X=new Image;return X.src=await this.base64(Z),X}async base64(Z){Z=this._normalizeOptions(Z,p$5.defaultImageOptions);const{format:X,quality:K}=Z,J=this.canvas(Z);if(J.toBlob!==void 0)return new Promise((Q,ee)=>{J.toBlob(te=>{if(!te){ee(new Error("ICanvas.toBlob failed!"));return}const re=new FileReader;re.onload=()=>Q(re.result),re.onerror=ee,re.readAsDataURL(te)},X,K)});if(J.toDataURL!==void 0)return J.toDataURL(X,K);if(J.convertToBlob!==void 0){const Q=await J.convertToBlob({type:X,quality:K});return new Promise((ee,te)=>{const re=new FileReader;re.onload=()=>ee(re.result),re.onerror=te,re.readAsDataURL(Q)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(Z){Z=this._normalizeOptions(Z);const X=Z.target,K=this._renderer,J=X instanceof Texture?X:K.textureGenerator.generateTexture(Z),Q=K.texture.generateCanvas(J);return X instanceof Container&&J.destroy(),Q}pixels(Z){Z=this._normalizeOptions(Z);const X=Z.target,K=this._renderer,J=X instanceof Texture?X:K.textureGenerator.generateTexture(Z),Q=K.texture.getPixels(J);return X instanceof Container&&J.destroy(),Q}texture(Z){return Z=this._normalizeOptions(Z),Z.target instanceof Texture?Z.target:this._renderer.textureGenerator.generateTexture(Z)}download(Z){var X;Z=this._normalizeOptions(Z);const K=this.canvas(Z),J=document.createElement("a");J.download=(X=Z.filename)!=null?X:"image.png",J.href=K.toDataURL("image/png"),document.body.appendChild(J),J.click(),document.body.removeChild(J)}log(Z){var X;const K=(X=Z.width)!=null?X:200;Z=this._normalizeOptions(Z);const J=this.canvas(Z),Q=J.toDataURL();console.log(`[Pixi Texture] ${J.width}px ${J.height}px`);const ee=["font-size: 1px;",`padding: ${K}px 300px;`,`background: url(${Q}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",ee)}destroy(){this._renderer=null}};let ExtractSystem=p$5;ExtractSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem],name:"extract"},ExtractSystem.defaultImageOptions={format:"png",quality:1};class RenderTexture extends Texture{static create(X){return new Texture({source:new TextureSource(X)})}resize(X,K,J){return this.source.resize(X,K,J),this}}var x$5=Object.defineProperty,y$2=Object.defineProperties,h$7=Object.getOwnPropertyDescriptors,a$2=Object.getOwnPropertySymbols,f$4=Object.prototype.hasOwnProperty,g$3=Object.prototype.propertyIsEnumerable,m$7=(Z,X,K)=>X in Z?x$5(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,c$3=(Z,X)=>{for(var K in X||(X={}))f$4.call(X,K)&&m$7(Z,K,X[K]);if(a$2)for(var K of a$2(X))g$3.call(X,K)&&m$7(Z,K,X[K]);return Z},l$3=(Z,X)=>y$2(Z,h$7(X));const A$1=new Rectangle,b$4=new Bounds,B=[0,0,0,0];class GenerateTextureSystem{constructor(X){this._renderer=X}generateTexture(X){var K;X instanceof Container&&(X={target:X,frame:void 0,textureSourceOptions:{},resolution:void 0});const J=X.resolution||this._renderer.resolution,Q=X.target;let ee=X.clearColor;ee?ee=Array.isArray(ee)&&ee.length===4?ee:Color.shared.setValue(ee).toArray():ee=B;const te=((K=X.frame)==null?void 0:K.copyTo(A$1))||getLocalBounds(Q,b$4).rectangle;te.width=Math.max(te.width,1/J)|0,te.height=Math.max(te.height,1/J)|0;const re=RenderTexture.create(l$3(c$3({},X.textureSourceOptions),{width:te.width,height:te.height,resolution:J})),ne=Matrix.shared.translate(-te.x,-te.y);return this._renderer.render({container:Q,transform:ne,target:re,clearColor:ee}),re}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem],name:"textureGenerator"};class GlobalUniformSystem{constructor(X){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=X}reset(){this._stackIndex=0;for(let X=0;X<this._activeUniforms.length;X++)this._uniformsPool.push(this._activeUniforms[X]);for(let X=0;X<this._activeBindGroups.length;X++)this._bindGroupPool.push(this._activeBindGroups[X]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(X){this.reset(),this.push(X)}bind({size:X,projectionMatrix:K,worldTransformMatrix:J,worldColor:Q,offset:ee}){const te=this._renderer.renderTarget.renderTarget,re=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{projectionData:te,worldTransformMatrix:new Matrix,worldColor:4294967295,offset:new Point},ne={projectionMatrix:K||this._renderer.renderTarget.projectionMatrix,resolution:X||te.size,worldTransformMatrix:J||re.worldTransformMatrix,worldColor:Q||re.worldColor,offset:ee||re.offset,bindGroup:null},ie=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(ie);const se=ie.uniforms;se.projectionMatrix=ne.projectionMatrix,se.uResolution=ne.resolution,se.worldTransformMatrix.copyFrom(ne.worldTransformMatrix),se.worldTransformMatrix.tx-=ne.offset.x,se.worldTransformMatrix.ty-=ne.offset.y,color32BitToUniform(ne.worldColor,se.worldColorAlpha,0),ie.update();let oe;this._renderer.renderPipes.uniformBatch?oe=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(ie,!1):(this._renderer.uniformBuffer.updateUniformGroup(ie),oe=this._bindGroupPool.pop()||new BindGroup,this._activeBindGroups.push(oe),oe.setResource(ie,0)),ne.bindGroup=oe,this._currentGlobalUniformData=ne}push(X){this.bind(X),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1]}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new UniformGroup({projectionMatrix:{value:new Matrix,type:"mat3x3<f32>"},worldTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},worldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{ubo:!0,isStatic:!0})}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"globalUniforms"};const WGSL_TO_STD40_SIZE={f32:4,"vec2<f32>":8,"vec3<f32>":12,"vec4<f32>":16,"mat2x2<f32>":48,"mat3x3<f32>":48,"mat4x4<f32>":64};function createUBOElements(Z){const X=Z.map(ee=>({data:ee,offset:0,size:0}));let K=0,J=0,Q=0;for(let ee=0;ee<X.length;ee++){const te=X[ee];if(K=WGSL_TO_STD40_SIZE[te.data.type],!K)throw new Error(`Unknown type ${te.data.type}`);if(te.data.size>1&&(K=Math.max(K,16)*te.data.size),te.size=K,J%K!==0&&J<16){const re=J%K%16;J+=re,Q+=re}J+K>16?(Q=Math.ceil(Q/16)*16,te.offset=Q,Q+=K,J=K):(te.offset=Q,J+=K,Q+=K)}return Q=Math.ceil(Q/16)*16,{uboElements:X,size:Q}}const UBO_TO_SINGLE_SETTERS_FN={f32:(Z,X,K)=>{Z[X]=K},"vec2<f32>":(Z,X,K)=>{Z[X]=K[0],Z[X+1]=K[1]},"vec3<f32>":(Z,X,K)=>{Z[X]=K[0],Z[X+1]=K[1],Z[X+2]=K[2]},"vec4<f32>":(Z,X,K)=>{Z[X]=K[0],Z[X+1]=K[1],Z[X+2]=K[2],Z[X+3]=K[3]},"mat2x2<f32>":(Z,X,K)=>{Z[X]=K[0],Z[X+1]=K[1],Z[X+4]=K[2],Z[X+5]=K[3]},"mat3x3<f32>":(Z,X,K)=>{Z[X]=K[0],Z[X+1]=K[1],Z[X+2]=K[2],Z[X+4]=K[3],Z[X+5]=K[4],Z[X+6]=K[5],Z[X+8]=K[6],Z[X+9]=K[7],Z[X+10]=K[8]},"mat4x4<f32>":(Z,X,K)=>{for(let J=0;J<16;J++)Z[X+J]=K[J]}},UBO_TO_SINGLE_SETTERS={f32:parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN.f32),"vec2<f32>":parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN["vec2<f32>"]),"vec3<f32>":parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN["vec3<f32>"]),"vec4<f32>":parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN["vec4<f32>"]),"mat2x2<f32>":parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN["mat2x2<f32>"]),"mat3x3<f32>":parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN["mat3x3<f32>"]),"mat4x4<f32>":parseFunctionBody(UBO_TO_SINGLE_SETTERS_FN["mat4x4<f32>"])},o$2={UPLOAD_PIXI_MAT_TO_MAT3:{test:Z=>Z.value.a!==void 0,exec:(Z,X,K,J,Q)=>{{const ee=X[Z].toArray(!0);K[J]=ee[0],K[J+1]=ee[1],K[J+2]=ee[2],K[J+4]=ee[3],K[J+5]=ee[4],K[J+6]=ee[5],K[J+8]=ee[6],K[J+9]=ee[7],K[J+10]=ee[8]}}},VEC4_RECTANGLE:{test:Z=>Z.type==="vec4<f32>"&&Z.size===1&&Z.value.width!==void 0,exec:(Z,X,K,J,Q)=>{Q=X[Z],K[J]=Q.x,K[J+1]=Q.y,K[J+2]=Q.width,K[J+3]=Q.height}},VEC2_POINT:{test:Z=>Z.type==="vec2<f32>"&&Z.size===1&&Z.value.x!==void 0,exec:(Z,X,K,J,Q)=>{Q=X[Z],K[J]=Q.x,K[J+1]=Q.y}}},uniformBufferParsers=[{type:"mat3x3<f32>",test:o$2.UPLOAD_PIXI_MAT_TO_MAT3.test,exec:o$2.UPLOAD_PIXI_MAT_TO_MAT3.exec,code:parseFunctionBody(o$2.UPLOAD_PIXI_MAT_TO_MAT3.exec)},{type:"vec4<f32>",test:o$2.VEC4_RECTANGLE.test,exec:o$2.VEC4_RECTANGLE.exec,code:parseFunctionBody(o$2.VEC4_RECTANGLE.exec)},{type:"vec2<f32>",test:o$2.VEC2_POINT.test,exec:o$2.VEC2_POINT.exec,code:parseFunctionBody(o$2.VEC2_POINT.exec)}];function generateUniformBufferSync(Z){const X=[`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
    `];let K=0;for(let Q=0;Q<Z.length;Q++){const ee=Z[Q],te=ee.data.name;let re=!1,ne=0;for(let ie=0;ie<uniformBufferParsers.length;ie++)if(uniformBufferParsers[ie].test(ee.data)){ne=ee.offset/4,X.push(`name = "${te}";`,`offset += ${ne-K};`,uniformBufferParsers[ie].code),re=!0;break}if(!re)if(ee.data.size>1){const ie=Math.max(WGSL_TO_STD40_SIZE[ee.data.type]/16,1),se=ee.data.value.length/ee.data.size,oe=(4-se%4)%4;ne=ee.offset/4,X.push(`
                    v = uv.${te};
                    offset += ${ne-K};

                    let arrayOffset = offset;

                    t = 0;

                    for(var i=0; i < ${ee.data.size*ie}; i++)
                    {
                        for(var j = 0; j < ${se}; j++)
                        {
                            data[arrayOffset++] = v[t++];
                        }
                        ${oe!==0?"arrayOffset += ${remainder};":""}
                    }
                `)}else{const ie=UBO_TO_SINGLE_SETTERS[ee.data.type];ne=ee.offset/4,X.push(`
                    v = uv.${te};
                    offset += ${ne-K};
                    ${ie};
                `)}K=ne}const J=X.join(`
`);return new Function("uv","data","offset",J)}class UniformBufferSystem{constructor(){this._syncFunctionHash=Object.create(null),this._systemCheck()}_systemCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")}ensureUniformGroup(X){X._syncFunction||this._initUniformGroup(X)}_initUniformGroup(X){const K=X._signature;let J=this._syncFunctionHash[K];if(!J){const Q=Object.keys(X.uniformStructures).map(re=>X.uniformStructures[re]),ee=createUBOElements(Q),te=this._generateUniformBufferSync(ee.uboElements);J=this._syncFunctionHash[K]={layout:ee,syncFunction:te}}return X._syncFunction=J.syncFunction,X.buffer=new Buffer({data:new Float32Array(J.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}),X._syncFunction}_generateUniformBufferSync(X){return generateUniformBufferSync(X)}syncUniformGroup(X,K,J){const Q=X._syncFunction||this._initUniformGroup(X);return K||(K=X.buffer.data),J||(J=0),Q(X.uniforms,K,J),!0}updateUniformGroup(X){if(X.isStatic&&!X._dirtyId)return!1;X._dirtyId=0;const K=this.syncUniformGroup(X);return X.buffer.update(),K}destroy(){this._syncFunctionHash=null}}UniformBufferSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"uniformBuffer"};let i$4=!1;const VERSION="8.0.0-rc";function sayHello(Z){if(!i$4){if(DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const X=[`%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${Z}) http://www.pixijs.com/

`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...X)}else globalThis.console&&globalThis.console.log(`PixiJS ${VERSION} - ${Z} - http://www.pixijs.com/`);i$4=!0}}class HelloSystem{constructor(X){this._renderer=X}init(X){X.hello&&sayHello(this._renderer.name)}}HelloSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"hello",priority:0},HelloSystem.defaultOptions={hello:!1};var a$1=Object.defineProperty,c$2=Object.getOwnPropertySymbols,d$4=Object.prototype.hasOwnProperty,h$6=Object.prototype.propertyIsEnumerable,s$8=(Z,X,K)=>X in Z?a$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$7=(Z,X)=>{for(var K in X||(X={}))d$4.call(X,K)&&s$8(Z,K,X[K]);if(c$2)for(var K of c$2(X))h$6.call(X,K)&&s$8(Z,K,X[K]);return Z};const i$3=class{constructor(Z){this._renderer=Z,this.count=0,this.checkCount=0}init(Z){Z=u$7(u$7({},i$3.defaultOptions),Z),this.checkCountMax=Z.textureGCCheckCountMax,this.maxIdle=Z.textureGCAMaxIdle,this.active=Z.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const Z=this._renderer.texture.managedTextures;for(let X=0;X<Z.length;X++){const K=Z[X];K.resource&&K._touched>-1&&this.count-K._touched>this.maxIdle&&(K._touched=-1,K.unload())}}destroy(){this._renderer=null}};let TextureGCSystem=i$3;TextureGCSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem],name:"textureGC"},TextureGCSystem.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:3600,textureGCCheckCountMax:600},b$r.add(TextureGCSystem);var m$6=Object.defineProperty,n$3=Object.getOwnPropertySymbols,h$5=Object.prototype.hasOwnProperty,l$2=Object.prototype.propertyIsEnumerable,u$6=(Z,X,K)=>X in Z?m$6(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$7=(Z,X)=>{for(var K in X||(X={}))h$5.call(X,K)&&u$6(Z,K,X[K]);if(n$3)for(var K of n$3(X))l$2.call(X,K)&&u$6(Z,K,X[K]);return Z};const r$2=class{get resolution(){return this.texture.source._resolution}set resolution(Z){this.texture.source.resize(this.texture.source.width,this.texture.source.height,Z)}init(Z){Z=s$7(s$7({},r$2.defaultOptions),Z),Z.element&&(deprecation(v8_0_0,"ViewSystem.element has been renamed to ViewSystem.canvas"),Z.canvas=Z.element),this.screen=new Rectangle(0,0,Z.width,Z.height),this.canvas=Z.canvas||DOMAdapter.get().createCanvas(),this.antialias=!!Z.antialias,this.texture=getCanvasTexture(this.canvas,Z),this.multiView=!!Z.multiView,this.autoDensity&&(this.canvas.style.width=`${this.texture.width}px`,this.canvas.style.height=`${this.texture.height}px`),this.resolution=Z.resolution}resize(Z,X,K){this.texture.source.resize(Z,X,K),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height,this.autoDensity&&(this.canvas.style.width=`${Z}px`,this.canvas.style.height=`${X}px`)}destroy(Z=!1){(typeof Z=="boolean"?Z:Z!=null&&Z.removeView)&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};let ViewSystem=r$2;ViewSystem.extension={type:[u$z.WebGLSystem,u$z.WebGPUSystem,u$z.CanvasSystem],name:"view",priority:0},ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};const SharedSystems=[BackgroundSystem,GlobalUniformSystem,HelloSystem,ViewSystem,RenderGroupSystem,UniformBufferSystem,TextureGCSystem,GenerateTextureSystem,ExtractSystem],SharedRenderPipes=[BlendModePipe,BatcherPipe,SpritePipe,RenderGroupPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe],T$2=[...SharedSystems,GlBackBufferSystem,GlContextSystem,GlBufferSystem,GlTextureSystem,GlRenderTargetSystem,GlGeometrySystem,GlUniformGroupSystem,GlShaderSystem,GlEncoderSystem,GlStateSystem,GlStencilSystem,GlColorMaskSystem],h$4=[...SharedRenderPipes],v$3=[GlBatchAdaptor,GlMeshAdaptor,GlGraphicsAdaptor],r$1=[],s$6=[],o$1=[];b$r.handleByNamedList(u$z.WebGLSystem,r$1),b$r.handleByNamedList(u$z.WebGLPipes,s$6),b$r.handleByNamedList(u$z.WebGLPipesAdaptor,o$1),b$r.add(...T$2,...h$4,...v$3);class WebGLRenderer extends AbstractRenderer{constructor(){const X={name:"webgl2",type:RendererType.WEBGL,systems:r$1,renderPipes:s$6,renderPipeAdaptors:o$1};super(X)}}var WebGLRenderer$1={__proto__:null,WebGLRenderer};class BindGroupSystem{constructor(X){this._hash=Object.create(null),this._renderer=X}contextChange(X){this._gpu=X}getBindGroup(X,K,J){return X._updateKey(),this._hash[X._key]||this._createBindGroup(X,K,J)}_createBindGroup(X,K,J){var Q;const ee=this._gpu.device,te=K.layout[J],re=[];for(const ie in te){const se=(Q=X.resources[ie])!=null?Q:X.resources[te[ie]];let oe;if(se._resourceType==="uniformGroup"){const ae=se;this._renderer.uniformBuffer.updateUniformGroup(ae);const le=ae.buffer;oe={buffer:this._renderer.buffer.getGPUBuffer(le),offset:0,size:le.descriptor.size}}else if(se._resourceType==="buffer"){const ae=se;oe={buffer:this._renderer.buffer.getGPUBuffer(ae),offset:0,size:ae.descriptor.size}}else if(se._resourceType==="bufferResource"){const ae=se;oe={buffer:this._renderer.buffer.getGPUBuffer(ae.buffer),offset:ae.offset,size:ae.size}}else if(se._resourceType==="textureSampler"){const ae=se;oe=this._renderer.texture.getGpuSampler(ae)}else if(se._resourceType==="textureSource"){const ae=se;oe=this._renderer.texture.getGpuSource(ae).createView({})}re.push({binding:te[ie],resource:oe})}const ne=ee.createBindGroup({layout:K._gpuLayout.bindGroups[J],entries:re});return this._hash[X._key]=ne,ne}destroy(){for(const X of Object.keys(this._hash))this._hash[X]=null;this._hash=null,this._renderer=null}}BindGroupSystem.extension={type:[u$z.WebGPUSystem],name:"bindGroup"};class BufferSystem{constructor(){this._gpuBuffers=Object.create(null)}contextChange(X){this._gpu=X}getGPUBuffer(X){return this._gpuBuffers[X.uid]||this.createGPUBuffer(X)}updateBuffer(X){const K=this._gpuBuffers[X.uid]||this.createGPUBuffer(X);return X._updateID&&X.data&&(X._updateID=0,this._gpu.device.queue.writeBuffer(K,0,X.data.buffer,0,X._updateSize)),K}destroyAll(){for(const X in this._gpuBuffers)this._gpuBuffers[X].destroy();this._gpuBuffers={}}createGPUBuffer(X){const K=this._gpu.device.createBuffer(X.descriptor);return X._updateID=0,X.data&&(fastCopy(X.data.buffer,K.getMappedRange()),K.unmap()),this._gpuBuffers[X.uid]=K,X.on("update",this.updateBuffer,this),X.on("change",this.onBufferChange,this),X.on("destroy",this.onBufferDestroy,this),K}onBufferChange(X){let K=this._gpuBuffers[X.uid];K.destroy(),K=this.createGPUBuffer(X),X._updateID=0}onBufferDestroy(X){this._gpuBuffers[X.uid].destroy(),this._gpuBuffers[X.uid]=null}destroy(){for(const X of Object.keys(this._gpuBuffers)){const K=Number(X);this._gpuBuffers[K].destroy(),this._gpuBuffers[K]=null}this._gpuBuffers=null}}BufferSystem.extension={type:[u$z.WebGPUSystem],name:"buffer"};function GpuReadBuffer(Z,X){const K=Z.descriptor.size,J=X.gpu.device,Q=new Buffer({data:new Float32Array(24e5),usage:BufferUsage.MAP_READ|BufferUsage.COPY_DST}),ee=X.buffer.createGPUBuffer(Q),te=J.createCommandEncoder();te.copyBufferToBuffer(X.buffer.getGPUBuffer(Z),0,ee,0,K),J.queue.submit([te.finish()]),ee.mapAsync(GPUMapMode.READ,0,K).then(()=>{ee.getMappedRange(0,K),ee.unmap()})}class UniformBufferBatch{constructor({minUniformOffsetAlignment:X}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=X,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(X){if(X>this._minUniformOffsetAlignment/4)throw new Error(`UniformBufferBatch: array is too large: ${X*4}`);const K=this.byteIndex;let J=K+X*4;if(J=Math.ceil(J/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,J>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=J,K}addGroup(X){const K=this.addEmptyGroup(X.length);for(let J=0;J<X.length;J++)this.data[K/4+J]=X[J];return K}destroy(){this._buffer.destroy(),this._buffer=null,this.data=null}}class GpuColorMaskSystem{constructor(X){this._colorMaskCache=15,this._renderer=X}setMask(X){this._colorMaskCache!==X&&(this._colorMaskCache=X,this._renderer.pipeline.setColorMask(X))}destroy(){this._renderer=null,this._colorMaskCache=null}}GpuColorMaskSystem.extension={type:[u$z.WebGPUSystem],name:"colorMask"};class GpuDeviceSystem{constructor(X){this._renderer=X}async init(X){return this._initPromise?this._initPromise:(this._initPromise=this._createDeviceAndAdaptor(X).then(K=>{this.gpu=K,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise)}contextChange(X){this._renderer.gpu=X}async _createDeviceAndAdaptor(X){const K=await navigator.gpu.requestAdapter({powerPreference:X.powerPreference,forceFallbackAdapter:X.forceFallbackAdapter}),J=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(ee=>K.features.has(ee)),Q=await K.requestDevice({requiredFeatures:J});return{adapter:K,device:Q}}destroy(){this.gpu=null,this._renderer=null}}GpuDeviceSystem.extension={type:[u$z.WebGPUSystem],name:"device"},GpuDeviceSystem.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};var c$1=Object.defineProperty,p$4=Object.getOwnPropertySymbols,m$5=Object.prototype.hasOwnProperty,l$1=Object.prototype.propertyIsEnumerable,h$3=(Z,X,K)=>X in Z?c$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$5=(Z,X)=>{for(var K in X||(X={}))m$5.call(X,K)&&h$3(Z,K,X[K]);if(p$4)for(var K of p$4(X))l$1.call(X,K)&&h$3(Z,K,X[K]);return Z};class GpuEncoderSystem{constructor(X){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=X}renderStart(){this.commandFinished=new Promise(X=>{this._resolveCommandFinished=X}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(X){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(X.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(X){this.renderPassEncoder.setViewport(X.x,X.y,X.width,X.height,0,1)}setPipelineFromGeometryProgramAndState(X,K,J,Q){const ee=this._renderer.pipeline.getPipeline(X,K,J,Q);this.setPipeline(ee)}setPipeline(X){this._boundPipeline!==X&&(this._boundPipeline=X,this.renderPassEncoder.setPipeline(X))}_setVertexBuffer(X,K){this._boundVertexBuffer[X]!==K&&(this._boundVertexBuffer[X]=K,this.renderPassEncoder.setVertexBuffer(X,this._renderer.buffer.updateBuffer(K)))}_setIndexBuffer(X){this._boundIndexBuffer!==X&&(this._boundIndexBuffer=X,this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(X),"uint32"))}setBindGroup(X,K,J){if(this._boundBindGroup[X]===K)return;this._boundBindGroup[X]=K,K._touch(this._renderer.textureGC.count);const Q=this._renderer.bindGroup.getBindGroup(K,J,X);this.renderPassEncoder.setBindGroup(X,Q)}setGeometry(X){for(const K in X.attributes){const J=X.attributes[K];this._setVertexBuffer(J.shaderLocation,J.buffer)}X.indexBuffer&&this._setIndexBuffer(X.indexBuffer)}_setShaderBindGroups(X,K){for(const J in X.groups){const Q=X.groups[J];K||this._syncBindGroup(Q),this.setBindGroup(J,Q,X.gpuProgram)}}_syncBindGroup(X){for(const K in X.resources){const J=X.resources[K];J.isUniformGroup&&this._renderer.uniformBuffer.updateUniformGroup(J)}}draw(X){const{geometry:K,shader:J,state:Q,topology:ee,size:te,start:re,instanceCount:ne,skipSync:ie}=X;this.setPipelineFromGeometryProgramAndState(K,J.gpuProgram,Q,ee),this.setGeometry(K),this._setShaderBindGroups(J,ie),K.indexBuffer?this.renderPassEncoder.drawIndexed(te||K.indexBuffer.data.length,ne||1,re||0):this.renderPassEncoder.draw(te||K.getSize(),ne||1,re||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished()}restoreRenderPass(){const X=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(X);const K=this._boundPipeline,J=u$5({},this._boundVertexBuffer),Q=this._boundIndexBuffer,ee=u$5({},this._boundBindGroup);this._clearCache();const te=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(te.x,te.y,te.width,te.height,0,1),this.setPipeline(K);for(const re in J)this._setVertexBuffer(re,J[re]);for(const re in ee)this.setBindGroup(re,ee[re],null);this._setIndexBuffer(Q)}_clearCache(){for(let X=0;X<16;X++)this._boundBindGroup[X]=null,this._boundVertexBuffer[X]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(X){this._gpu=X}}GpuEncoderSystem.extension={type:[u$z.WebGPUSystem],name:"encoder",priority:1};class GpuStencilSystem{constructor(X){this._renderTargetStencilState=Object.create(null),this._renderer=X,X.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(X){let K=this._renderTargetStencilState[X.uid];K||(K=this._renderTargetStencilState[X.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this._activeRenderTarget=X,this.setStencilMode(K.stencilMode,K.stencilReference)}setStencilMode(X,K){const J=this._renderTargetStencilState[this._activeRenderTarget.uid];J.stencilMode=X,J.stencilReference=K;const Q=this._renderer;Q.pipeline.setStencilMode(X),Q.encoder.renderPassEncoder.setStencilReference(K)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}GpuStencilSystem.extension={type:[u$z.WebGPUSystem],name:"stencil"};const s$5=128;class GpuUniformBatchPipe{constructor(X){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=X,this._batchBuffer=new UniformBufferBatch({minUniformOffsetAlignment:s$5});const K=256/s$5;for(let J=0;J<K;J++){let Q=BufferUsage.UNIFORM|BufferUsage.COPY_DST;J===0&&(Q|=BufferUsage.COPY_SRC),this._buffers.push(new Buffer({data:this._batchBuffer.data,usage:Q}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(const X in this._bindGroupHash)this._bindGroupHash[X]=null;this._batchBuffer.clear()}getUniformBindGroup(X,K){if(!K&&this._bindGroupHash[X.uid])return this._bindGroupHash[X.uid];this._renderer.uniformBuffer.ensureUniformGroup(X);const J=X.buffer.data,Q=this._batchBuffer.addEmptyGroup(J.length);return this._renderer.uniformBuffer.syncUniformGroup(X,this._batchBuffer.data,Q/4),this._bindGroupHash[X.uid]=this._getBindGroup(Q/s$5),this._bindGroupHash[X.uid]}getUniformBufferResource(X){this._renderer.uniformBuffer.updateUniformGroup(X);const K=X.buffer.data,J=this._batchBuffer.addGroup(K);return this._getBufferResource(J/s$5)}getArrayBindGroup(X){const K=this._batchBuffer.addGroup(X);return this._getBindGroup(K/s$5)}getArrayBufferResource(X){const K=this._batchBuffer.addGroup(X)/s$5;return this._getBufferResource(K)}_getBufferResource(X){if(!this._bufferResources[X]){const K=this._buffers[X%2];this._bufferResources[X]=new BufferResource({buffer:K,offset:(X/2|0)*256,size:s$5})}return this._bufferResources[X]}_getBindGroup(X){if(!this._bindGroups[X]){const K=new BindGroup({0:this._getBufferResource(X)});this._bindGroups[X]=K}return this._bindGroups[X]}_uploadBindGroups(){const X=this._renderer.buffer,K=this._buffers[0];K.update(this._batchBuffer.byteIndex),X.updateBuffer(K);const J=this._renderer.gpu.device.createCommandEncoder();for(let Q=1;Q<this._buffers.length;Q++){const ee=this._buffers[Q];J.copyBufferToBuffer(X.getGPUBuffer(K),s$5,X.getGPUBuffer(ee),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([J.finish()])}destroy(){for(let X=0;X<this._bindGroups.length;X++)this._bindGroups[X].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let X=0;X<this._buffers.length;X++)this._buffers[X].destroy();this._buffers=null;for(let X=0;X<this._bufferResources.length;X++)this._bufferResources[X].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}GpuUniformBatchPipe.extension={type:[u$z.WebGPUPipes],name:"uniformBatch"};const h$2={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function f$3(Z,X,K,J,Q,ee,te,re){return Z<<26|X<<18|te<<14|K<<8|J<<3|re<<1|Q<<4|ee}class PipelineSystem{constructor(X){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._pipeCache=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=X}contextChange(X){this._gpu=X,this.setStencilMode(STENCIL_MODES.DISABLED)}setMultisampleCount(X){this._multisampleCount=X}setColorMask(X){this._colorMask=X}setStencilMode(X){this._stencilMode=X,this._stencilState=GpuStencilModesToPixi[X]}setPipeline(X,K,J,Q){const ee=this.getPipeline(X,K,J);Q.setPipeline(ee)}getPipeline(X,K,J,Q){X._layoutKey||this._generateBufferKey(X),K._layoutKey||(this._generateProgramKey(K),this._renderer.shader.createProgramLayout(K)),Q=Q||X.topology;const ee=f$3(X._layoutKey,K._layoutKey,J.data,J._blendModeId,this._stencilMode,this._multisampleCount,this._colorMask,h$2[Q]);return this._pipeCache[ee]?this._pipeCache[ee]:(this._pipeCache[ee]=this._createPipeline(X,K,J,Q),this._pipeCache[ee])}_createPipeline(X,K,J,Q){const ee=this._gpu.device,te=this._createVertexBufferLayouts(X),re=this._renderer.state.getColorTargets(J);let ne=this._stencilState;ne=GpuStencilModesToPixi[this._stencilMode],re[0].writeMask=this._stencilMode===STENCIL_MODES.RENDERING_MASK_ADD?0:this._colorMask;const ie={vertex:{module:this._getModule(K.vertex.source),entryPoint:K.vertex.entryPoint,buffers:te},fragment:{module:this._getModule(K.fragment.source),entryPoint:K.fragment.entryPoint,targets:re},primitive:{topology:Q,cullMode:J.cullMode},layout:K._gpuLayout.pipeline,multisample:{count:this._multisampleCount},depthStencil:ne,label:"PIXI Pipeline"};return ee.createRenderPipeline(ie)}_getModule(X){return this._moduleCache[X]||this._createModule(X)}_createModule(X){const K=this._gpu.device;return this._moduleCache[X]=K.createShaderModule({code:X}),this._moduleCache[X]}_generateProgramKey(X){const{vertex:K,fragment:J}=X,Q=K.source+J.source+K.entryPoint+J.entryPoint;return X._layoutKey=createIdFromString(Q,"program"),X._layoutKey}_generateBufferKey(X){const K=[];let J=0;const Q=Object.keys(X.attributes).sort();for(let te=0;te<Q.length;te++){const re=X.attributes[Q[te]];K[J++]=re.shaderLocation,K[J++]=re.offset,K[J++]=re.format,K[J++]=re.stride}const ee=K.join("");return X._layoutKey=createIdFromString(ee,"geometry"),X._layoutKey}_createVertexBufferLayouts(X){if(this._bufferLayoutsCache[X._layoutKey])return this._bufferLayoutsCache[X._layoutKey];const K=[];return X.buffers.forEach(J=>{const Q={arrayStride:0,stepMode:"vertex",attributes:[]},ee=Q.attributes;for(const te in X.attributes){const re=X.attributes[te];re.buffer===J&&(Q.arrayStride=re.stride,ee.push({shaderLocation:re.shaderLocation,offset:re.offset,format:re.format}))}ee.length&&K.push(Q)}),this._bufferLayoutsCache[X._layoutKey]=K,K}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}PipelineSystem.extension={type:[u$z.WebGPUSystem],name:"pipeline"};class GpuRenderTarget{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class GpuRenderTargetAdaptor{init(X,K){this._renderer=X,this._renderTargetSystem=K}copyToTexture(X,K,J,Q){const ee=this._renderer,te=this._getGpuColorTexture(X),re=ee.texture.getGpuSource(K.source);return ee.encoder.commandEncoder.copyTextureToTexture({texture:te,origin:J},{texture:re},Q),K}startRenderPass(X,K=!0,J,Q){const ee=this._renderTargetSystem.getGpuRenderTarget(X),te=this.getDescriptor(X,K,J);ee.descriptor=te,this._renderer.encoder.beginRenderPass(ee),this._renderer.encoder.setViewport(Q),this._renderer.pipeline.setMultisampleCount(ee.msaaSamples)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(X){const K=this._renderTargetSystem.getGpuRenderTarget(X);return K.contexts[0]?K.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(X.colorTextures[0].source)}getDescriptor(X,K,J){typeof K=="boolean"&&(K=K?CLEAR.ALL:CLEAR.NONE);const Q=this._renderTargetSystem,ee=Q.getGpuRenderTarget(X),te=X.colorTextures.map((ne,ie)=>{const se=ee.contexts[ie];let oe,ae;se?oe=se.getCurrentTexture().createView():oe=this._renderer.texture.getGpuSource(ne).createView({mipLevelCount:1}),ee.msaaTextures[ie]&&(ae=oe,oe=this._renderer.texture.getTextureView(ee.msaaTextures[ie]));const le=K&CLEAR.COLOR?"clear":"load";return J!=null||(J=Q.defaultClearColor),{view:oe,resolveTarget:ae,clearValue:J,storeOp:"store",loadOp:le}});let re;if(X.depthTexture){const ne=K&CLEAR.STENCIL?"clear":"load";re={view:this._renderer.texture.getGpuSource(X.depthTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:ne}}return{colorAttachments:te,depthStencilAttachment:re}}clear(X,K=!0,J,Q){this.startRenderPass(X,K,J,Q)}initGpuRenderTarget(X){X.isRoot=!0;const K=new GpuRenderTarget;return X.colorTextures.forEach((J,Q)=>{if(CanvasSource.test(J.resource)){const ee=X.colorTexture.resource.getContext("webgpu");try{ee.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:"opaque"})}catch(te){console.error(te)}K.contexts[Q]=ee}if(K.msaa=J.source.antialias,J.source.antialias){const ee=new TextureSource({width:0,height:0,sampleCount:4});K.msaaTextures[Q]=ee}}),K.msaa&&(K.msaaSamples=4,X.depthTexture&&(X.depthTexture.source.sampleCount=4)),K}resizeGpuRenderTarget(X){const K=this._renderTargetSystem.getGpuRenderTarget(X);K.width=X.width,K.height=X.height,K.msaa&&X.colorTextures.forEach((J,Q)=>{const ee=K.msaaTextures[Q];ee==null||ee.resize(J.source.width,J.source.height,J.source._resolution)})}}class GpuRenderTargetSystem extends RenderTargetSystem{constructor(X){super(X),this.adaptor=new GpuRenderTargetAdaptor,this.adaptor.init(X,this)}}GpuRenderTargetSystem.extension={type:[u$z.WebGPUSystem],name:"renderTarget"};class GpuShaderSystem{contextChange(X){this._gpu=X}createProgramLayout(X){const K=this._gpu.device;if(!X._gpuLayout)if(X.gpuLayout){const J=X.gpuLayout.map(ee=>K.createBindGroupLayout({entries:ee})),Q={bindGroupLayouts:J};X._gpuLayout={bindGroups:J,pipeline:K.createPipelineLayout(Q)}}else X._gpuLayout={bindGroups:null,pipeline:"auto"}}destroy(){this._gpu=null}}GpuShaderSystem.extension={type:[u$z.WebGPUSystem],name:"shader"};const GpuBlendModesToPixi={};GpuBlendModesToPixi.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},GpuBlendModesToPixi.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},GpuBlendModesToPixi.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},GpuBlendModesToPixi.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},GpuBlendModesToPixi.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},GpuBlendModesToPixi.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},GpuBlendModesToPixi["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},GpuBlendModesToPixi["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},GpuBlendModesToPixi["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},GpuBlendModesToPixi.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}};class GpuStateSystem{constructor(){this.defaultState=new State,this.defaultState.blend=!0}contextChange(X){this.gpu=X}getColorTargets(X){return[{format:"bgra8unorm",writeMask:0,blend:GpuBlendModesToPixi[X.blendMode]||GpuBlendModesToPixi.normal}]}destroy(){this.gpu=null}}GpuStateSystem.extension={type:[u$z.WebGPUSystem],name:"state"};const gpuUploadBufferImageResource={type:"image",upload(Z,X,K){const J=Z.resource,Q=(Z.pixelWidth|0)*(Z.pixelHeight|0),ee=J.byteLength/Q;K.device.queue.writeTexture({texture:X},J,{offset:0,rowsPerImage:Z.pixelHeight,bytesPerRow:Z.pixelHeight*ee},{width:Z.pixelWidth,height:Z.pixelHeight,depthOrArrayLayers:1})}},blockDataMap={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},s$4={blockBytes:4,blockWidth:1,blockHeight:1},gpuUploadCompressedTextureResource={type:"compressed",upload(Z,X,K){let J=Z.pixelWidth,Q=Z.pixelHeight;const ee=blockDataMap[Z.format]||s$4;for(let te=0;te<Z.resource.length;te++){const re=Z.resource[te],ne=Math.ceil(J/ee.blockWidth)*ee.blockBytes;K.device.queue.writeTexture({texture:X,mipLevel:te},re,{offset:0,bytesPerRow:ne},{width:Math.ceil(J/ee.blockWidth)*ee.blockWidth,height:Math.ceil(Q/ee.blockHeight)*ee.blockHeight,depthOrArrayLayers:1}),J=Math.max(J>>1,1),Q=Math.max(Q>>1,1)}}},gpuUploadImageResource={type:"image",upload(Z,X,K){const J=Z.resource;if(!J)return;const Q=Math.min(X.width,Z.resourceWidth||Z.pixelWidth),ee=Math.min(X.height,Z.resourceHeight||Z.pixelHeight),te=Z.alphaMode==="premultiply-alpha-on-upload";K.device.queue.copyExternalImageToTexture({source:J},{texture:X,premultipliedAlpha:te},{width:Q,height:ee})}},gpuUploadVideoResource={type:"video",upload(Z,X,K){gpuUploadImageResource.upload(Z,X,K)}};class GpuMipmapGenerator{constructor(X){this.device=X,this.sampler=X.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(X){let K=this.pipelines[X];return K||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),K=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:X}]}}),this.pipelines[X]=K),K}generateMipmap(X){const K=this._getMipmapPipeline(X.format);if(X.dimension==="3d"||X.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let J=X;const Q=X.depthOrArrayLayers||1,ee=X.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!ee){const ne={size:{width:Math.ceil(X.width/2),height:Math.ceil(X.height/2),depthOrArrayLayers:Q},format:X.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:X.mipLevelCount-1};J=this.device.createTexture(ne)}const te=this.device.createCommandEncoder({}),re=K.getBindGroupLayout(0);for(let ne=0;ne<Q;++ne){let ie=X.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:ne,arrayLayerCount:1}),se=ee?1:0;for(let oe=1;oe<X.mipLevelCount;++oe){const ae=J.createView({baseMipLevel:se++,mipLevelCount:1,dimension:"2d",baseArrayLayer:ne,arrayLayerCount:1}),le=te.beginRenderPass({colorAttachments:[{view:ae,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),ce=this.device.createBindGroup({layout:re,entries:[{binding:0,resource:this.sampler},{binding:1,resource:ie}]});le.setPipeline(K),le.setBindGroup(0,ce),le.draw(3,1,0,0),le.end(),ie=ae}}if(!ee){const ne={width:Math.ceil(X.width/2),height:Math.ceil(X.height/2),depthOrArrayLayers:Q};for(let ie=1;ie<X.mipLevelCount;++ie)te.copyTextureToTexture({texture:J,mipLevel:ie-1},{texture:X,mipLevel:ie},ne),ne.width=Math.ceil(ne.width/2),ne.height=Math.ceil(ne.height/2)}return this.device.queue.submit([te.finish()]),ee||J.destroy(),X}}class GpuTextureSystem{constructor(X){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:gpuUploadImageResource,buffer:gpuUploadBufferImageResource,video:gpuUploadVideoResource,compressed:gpuUploadCompressedTextureResource},this._renderer=X}contextChange(X){this._gpu=X}initSource(X){if(X.autoGenerateMipmaps){const ne=Math.max(X.pixelWidth,X.pixelHeight);X.mipLevelCount=Math.floor(Math.log2(ne))+1}let K=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;X.uploadMethodId!=="compressed"&&(K|=GPUTextureUsage.RENDER_ATTACHMENT,K|=GPUTextureUsage.COPY_SRC);const J=blockDataMap[X.format]||{blockBytes:4,blockWidth:1,blockHeight:1},Q=Math.ceil(X.pixelWidth/J.blockWidth)*J.blockWidth,ee=Math.ceil(X.pixelHeight/J.blockHeight)*J.blockHeight,te={label:X.label,size:{width:Q,height:ee},format:X.format,sampleCount:X.sampleCount,mipLevelCount:X.mipLevelCount,dimension:X.dimension,usage:K},re=this._gpu.device.createTexture(te);return this._gpuSources[X.uid]=re,X.on("update",this.onSourceUpdate,this),X.on("resize",this.onSourceResize,this),X.on("destroy",this.onSourceDestroy,this),X.on("unload",this.onSourceUnload,this),X.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(X),this.onSourceUpdate(X),re}onSourceUpdate(X){const K=this.getGpuSource(X);K&&(this._uploads[X.uploadMethodId]&&this._uploads[X.uploadMethodId].upload(X,K,this._gpu),X.autoGenerateMipmaps&&X.mipLevelCount>1&&this.onUpdateMipmaps(X))}onSourceUnload(X){const K=this._gpuSources[X.uid];K&&(this._gpuSources[X.uid]=null,K.destroy())}onUpdateMipmaps(X){this._mipmapGenerator||(this._mipmapGenerator=new GpuMipmapGenerator(this._gpu.device));const K=this.getGpuSource(X);this._mipmapGenerator.generateMipmap(K)}onSourceDestroy(X){X.off("update",this.onSourceUpdate,this),X.off("unload",this.onSourceUnload,this),X.off("destroy",this.onSourceDestroy,this),X.off("resize",this.onSourceResize,this),X.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(X),1),this.onSourceUnload(X)}onSourceResize(X){const K=this._gpuSources[X.uid];K?(K.width!==X.pixelWidth||K.height!==X.pixelHeight)&&(this._textureViewHash[X.uid]=null,this._bindGroupHash[X.uid]=null,this.onSourceUnload(X),this.initSource(X)):this.initSource(X)}_initSampler(X){return this._gpuSamplers[X._resourceId]=this._gpu.device.createSampler(X),this._gpuSamplers[X._resourceId]}getGpuSampler(X){return this._gpuSamplers[X._resourceId]||this._initSampler(X)}getGpuSource(X){return this._gpuSources[X.uid]||this.initSource(X)}getTextureBindGroup(X){var K;return(K=this._bindGroupHash[X.uid])!=null?K:this._createTextureBindGroup(X)}_createTextureBindGroup(X){const K=X.source,J=K.uid;return this._bindGroupHash[J]=new BindGroup({0:K,1:K.style}),this._bindGroupHash[J]}getTextureView(X){var K;const J=X.source;return(K=this._textureViewHash[J.uid])!=null?K:this._createTextureView(J)}_createTextureView(X){return this._textureViewHash[X.uid]=this.getGpuSource(X).createView(),this._textureViewHash[X.uid]}generateCanvas(X){const K=this._renderer,J=K.gpu.device.createCommandEncoder(),Q=DOMAdapter.get().createCanvas();Q.width=X.source.pixelWidth,Q.height=X.source.pixelHeight;const ee=Q.getContext("webgpu");return ee.configure({device:K.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),J.copyTextureToTexture({texture:K.texture.getGpuSource(X.source),origin:{x:0,y:0}},{texture:ee.getCurrentTexture()},{width:Q.width,height:Q.height}),K.gpu.device.queue.submit([J.finish()]),Q}getPixels(X){const K=this.generateCanvas(X),J=CanvasPool.getOptimalCanvasAndContext(K.width,K.height),Q=J.context;Q.drawImage(K,0,0);const{width:ee,height:te}=K,re=Q.getImageData(0,0,ee,te),ne=new Uint8ClampedArray(re.data.buffer);return CanvasPool.returnCanvasAndContext(J),{pixels:ne,width:ee,height:te}}destroy(){this.managedTextures.slice().forEach(X=>this.onSourceDestroy(X)),this.managedTextures=null;for(const X of Object.keys(this._bindGroupHash)){const K=Number(X),J=this._bindGroupHash[K];J==null||J.destroy(),this._bindGroupHash[K]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}GpuTextureSystem.extension={type:[u$z.WebGPUSystem],name:"texture"};class GpuGraphicsAdaptor{init(){const X=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),K=compileHighShaderGpuProgram({name:"graphics",bits:[colorBit,generateTextureBatchBit(MAX_TEXTURES),localUniformBitGroup2,roundPixelsBit]});this.shader=new Shader({gpuProgram:K,resources:{localUniforms:X}}),this.shader.addResource("globalUniforms",0,0)}execute(X,K){const J=K.view.context,Q=J.customShader||this.shader,ee=X.renderer,te=ee.graphicsContext,{geometry:re,instructions:ne}=te.getContextRenderData(J),ie=ee.encoder;ie.setPipelineFromGeometryProgramAndState(re,Q.gpuProgram,X.state),ie.setGeometry(re);const se=ee.globalUniforms.bindGroup;ie.setBindGroup(0,se,Q.gpuProgram);const oe=ee.renderPipes.uniformBatch.getUniformBindGroup(Q.resources.localUniforms,!0);ie.setBindGroup(2,oe,Q.gpuProgram);const ae=ne.instructions;for(let le=0;le<ne.instructionSize;le++){const ce=ae[le];if(Q.groups[1]=ce.bindGroup,!ce.gpuBindGroup){const de=ce.textures;ce.bindGroup=getTextureBatchBindGroup(de.textures,de.count),ce.gpuBindGroup=ee.bindGroup.getBindGroup(ce.bindGroup,Q.gpuProgram,1)}ie.setBindGroup(1,ce.bindGroup,Q.gpuProgram),ie.renderPassEncoder.drawIndexed(ce.size,1,ce.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}GpuGraphicsAdaptor.extension={type:[u$z.WebGPUPipesAdaptor],name:"graphics"};class GpuMeshAdapter{init(){const X=compileHighShaderGpuProgram({name:"mesh",bits:[localUniformBit,textureBit,roundPixelsBit]});this._shader=new Shader({gpuProgram:X,resources:{uTexture:Texture.EMPTY._source,uSampler:Texture.EMPTY._source.style}})}execute(X,K){const J=X.renderer,Q=K.view;let ee=Q._shader;ee||(ee=this._shader,ee.groups[2]=J.texture.getTextureBindGroup(Q.texture)),ee.groups[0]=J.globalUniforms.bindGroup;const te=X.localUniforms;ee.groups[1]=J.renderPipes.uniformBatch.getUniformBindGroup(te,!0),J.encoder.draw({geometry:Q._geometry,shader:ee,state:Q.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GpuMeshAdapter.extension={type:[u$z.WebGPUPipesAdaptor],name:"mesh"};const T$1=[...SharedSystems,GpuEncoderSystem,GpuDeviceSystem,BufferSystem,GpuTextureSystem,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,PipelineSystem,GpuColorMaskSystem,GpuStencilSystem,BindGroupSystem],v$2=[...SharedRenderPipes,GpuUniformBatchPipe],C=[GpuBatchAdaptor,GpuMeshAdapter,GpuGraphicsAdaptor],s$3=[],r=[],i$2=[];b$r.handleByNamedList(u$z.WebGPUSystem,s$3),b$r.handleByNamedList(u$z.WebGPUPipes,r),b$r.handleByNamedList(u$z.WebGPUPipesAdaptor,i$2),b$r.add(...T$1,...v$2,...C);class WebGPURenderer extends AbstractRenderer{constructor(){const X={name:"webgpu",type:RendererType.WEBGPU,systems:s$3,renderPipes:r,renderPipeAdaptors:i$2};super(X)}}var WebGPURenderer$1={__proto__:null,WebGPURenderer};const i$1={POINTS:"point-list",LINES:"line-list",LINE_STRIP:"line-strip",TRIANGLES:"triangle-list",TRIANGLE_STRIP:"triangle-strip"},DRAW_MODES=new Proxy(i$1,{get(Z,X){return deprecation(v8_0_0,`DRAW_MODES.${X} is deprecated, use '${i$1[X]}' instead`),Z[X]}}),n$2=new Rectangle(0,0,1,1);function viewportFromFrame(Z,X,K){K||(K=n$2);const J=X.pixelWidth,Q=X.pixelHeight;return Z.x=K.x*J|0,Z.y=K.y*Q|0,Z.width=K.width*J|0,Z.height=K.height*Q|0,Z}const GLSL_TO_STD40_SIZE={float:4,vec2:8,vec3:12,vec4:16,int:4,ivec2:8,ivec3:12,ivec4:16,uint:4,uvec2:8,uvec3:12,uvec4:16,bool:4,bvec2:8,bvec3:12,bvec4:16,mat2:32,mat3:48,mat4:64};var MSAA_QUALITY=(Z=>(Z[Z.NONE=0]="NONE",Z[Z.LOW=2]="LOW",Z[Z.MEDIUM=4]="MEDIUM",Z[Z.HIGH=8]="HIGH",Z))(MSAA_QUALITY||{}),DEPRECATED_WRAP_MODES=(Z=>(Z.CLAMP="clamp-to-edge",Z.REPEAT="repeat",Z.MIRRORED_REPEAT="mirror-repeat",Z))(DEPRECATED_WRAP_MODES||{});const WRAP_MODES=new Proxy(DEPRECATED_WRAP_MODES,{get(Z,X){return deprecation(v8_0_0,`DRAW_MODES.${X} is deprecated, use '${DEPRECATED_WRAP_MODES[X]}' instead`),Z[X]}});var DEPRECATED_SCALE_MODES=(Z=>(Z.NEAREST="nearest",Z.LINEAR="linear",Z))(DEPRECATED_SCALE_MODES||{});const SCALE_MODES=new Proxy(DEPRECATED_SCALE_MODES,{get(Z,X){return deprecation(v8_0_0,`DRAW_MODES.${X} is deprecated, use '${DEPRECATED_SCALE_MODES[X]}' instead`),Z[X]}});class TextureUvs{constructor(){this.x0=0,this.y0=0,this.x1=1,this.y1=0,this.x2=1,this.y2=1,this.x3=0,this.y3=1,this.uvsFloat32=new Float32Array(8)}set(X,K,J){const Q=K.width,ee=K.height;if(J){const te=X.width/2/Q,re=X.height/2/ee,ne=X.x/Q+te,ie=X.y/ee+re;J=groupD8.add(J,groupD8.NW),this.x0=ne+te*groupD8.uX(J),this.y0=ie+re*groupD8.uY(J),J=groupD8.add(J,2),this.x1=ne+te*groupD8.uX(J),this.y1=ie+re*groupD8.uY(J),J=groupD8.add(J,2),this.x2=ne+te*groupD8.uX(J),this.y2=ie+re*groupD8.uY(J),J=groupD8.add(J,2),this.x3=ne+te*groupD8.uX(J),this.y3=ie+re*groupD8.uY(J)}else this.x0=X.x/Q,this.y0=X.y/ee,this.x1=(X.x+X.width)/Q,this.y1=X.y/ee,this.x2=(X.x+X.width)/Q,this.y2=(X.y+X.height)/ee,this.x3=X.x/Q,this.y3=(X.y+X.height)/ee;this.uvsFloat32[0]=this.x0,this.uvsFloat32[1]=this.y0,this.uvsFloat32[2]=this.x1,this.uvsFloat32[3]=this.y1,this.uvsFloat32[4]=this.x2,this.uvsFloat32[5]=this.y2,this.uvsFloat32[6]=this.x3,this.uvsFloat32[7]=this.y3}}let e=0;function generateUID(){return e++}function multiplyHexColors(Z,X){if(Z===16777215||!X)return X;if(X===16777215||!Z)return Z;const K=Z>>16&255,J=Z>>8&255,Q=Z&255,ee=X>>16&255,te=X>>8&255,re=X&255,ne=K*ee/255,ie=J*te/255,se=Q*re/255;return(ne<<16)+(ie<<8)+se}function updateWorldTransform(Z,X,K){const J=Z.a,Q=Z.b,ee=Z.c,te=Z.d,re=Z.tx,ne=Z.ty,ie=X.a,se=X.b,oe=X.c,ae=X.d;K.a=J*ie+Q*oe,K.b=J*se+Q*ae,K.c=ee*ie+te*oe,K.d=ee*se+te*ae,K.tx=re*ie+ne*oe+X.tx,K.ty=re*se+ne*ae+X.ty}const P$2={rectangle:buildRectangle,polygon:buildPolygon,triangle:buildTriangle,circle:buildCircle,ellipse:buildCircle,roundedRectangle:buildCircle};function buildGeometryFromPath(Z){const X=[],K=[],J=[],Q=Z.path.shapePath,ee=Z.textureMatrix;Q.shapePrimitives.forEach(({shape:re,transform:ne})=>{const ie=J.length,se=X.length/2,oe=[],ae=P$2[re.type];ae.build(re,oe),ne&&transformVertices(oe,ne),ae.triangulate(oe,X,2,se,J,ie);const le=K.length/2;ee?(ne&&ee.append(ne.clone().invert()),buildUvs(X,2,se,K,le,2,X.length/2-se,ee)):buildSimpleUvs(K,le,2,X.length/2-se)});const te=Z.out;return te?(te.positions=new Float32Array(X),te.uvs=new Float32Array(K),te.indices=new Uint32Array(J),te):new MeshGeometry({positions:new Float32Array(X),uvs:new Float32Array(K),indices:new Uint32Array(J)})}var P$1=Object.defineProperty,w$3=Object.getOwnPropertySymbols,A=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable,Y=(Z,X,K)=>X in Z?P$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,v$1=(Z,X)=>{for(var K in X||(X={}))A.call(X,K)&&Y(Z,K,X[K]);if(w$3)for(var K of w$3(X))z.call(X,K)&&Y(Z,K,X[K]);return Z};const m$4=class extends MeshGeometry{constructor(...Z){var X;super({});let K=(X=Z[0])!=null?X:{};typeof K=="number"&&(deprecation(v8_0_0,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),K={width:K,height:Z[1],verticesX:Z[2],verticesY:Z[3]}),this.build(K)}build(Z){var X,K,J,Q;Z=v$1(v$1({},m$4.defaultOptions),Z),this.verticesX=(X=this.verticesX)!=null?X:Z.verticesX,this.verticesY=(K=this.verticesY)!=null?K:Z.verticesY,this.width=(J=this.width)!=null?J:Z.width,this.height=(Q=this.height)!=null?Q:Z.height;const ee=this.verticesX*this.verticesY,te=[],re=[],ne=[],ie=this.verticesX-1,se=this.verticesY-1,oe=this.width/ie,ae=this.height/se;for(let ce=0;ce<ee;ce++){const de=ce%this.verticesX,he=ce/this.verticesX|0;te.push(de*oe,he*ae),re.push(de/ie,he/se)}const le=ie*se;for(let ce=0;ce<le;ce++){const de=ce%ie,he=ce/ie|0,pe=he*this.verticesX+de,fe=he*this.verticesX+de+1,ge=(he+1)*this.verticesX+de,me=(he+1)*this.verticesX+de+1;ne.push(pe,fe,ge,fe,me,ge)}this.buffers[0].data=new Float32Array(te),this.buffers[1].data=new Float32Array(re),this.indexBuffer.data=new Uint32Array(ne),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};let PlaneGeometry=m$4;PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};var p$3=Object.defineProperty,H$1=Object.getOwnPropertySymbols,f$2=Object.prototype.hasOwnProperty,x$4=Object.prototype.propertyIsEnumerable,W$1=(Z,X,K)=>X in Z?p$3(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,_$1=(Z,X)=>{for(var K in X||(X={}))f$2.call(X,K)&&W$1(Z,K,X[K]);if(H$1)for(var K of H$1(X))x$4.call(X,K)&&W$1(Z,K,X[K]);return Z};const u$4=class extends PlaneGeometry{constructor(Z){Z=_$1(_$1({},u$4.defaultOptions),Z),super({width:Z.width,height:Z.height,verticesX:4,verticesY:4}),this._textureMatrix=new Matrix,this.update(Z)}update(Z){this.updateUvs(Z),this.updatePositions(Z)}updatePositions(Z){var X,K,J,Q,ee,te;this.width=(X=Z.width)!=null?X:this.width,this.height=(K=Z.height)!=null?K:this.height,this._leftWidth=(J=Z.leftWidth)!=null?J:this._leftWidth,this._rightWidth=(Q=Z.rightWidth)!=null?Q:this._rightWidth,this._topHeight=(ee=Z.topHeight)!=null?ee:this._topHeight,this._bottomHeight=(te=Z.bottomHeight)!=null?te:this._bottomHeight;const re=this.positions,ne=this._leftWidth+this._rightWidth,ie=this.width>ne?1:this.width/ne,se=this._topHeight+this._bottomHeight,oe=this.height>se?1:this.height/se,ae=Math.min(ie,oe);re[9]=re[11]=re[13]=re[15]=this._topHeight*ae,re[17]=re[19]=re[21]=re[23]=this.height-this._bottomHeight*ae,re[25]=re[27]=re[29]=re[31]=this.height,re[2]=re[10]=re[18]=re[26]=this._leftWidth*ae,re[4]=re[12]=re[20]=re[28]=this.width-this._rightWidth*ae,re[6]=re[14]=re[22]=re[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(Z){var X,K,J,Q,ee,te;this._originalWidth=(X=Z.originalWidth)!=null?X:this._originalWidth,this._originalHeight=(K=Z.originalHeight)!=null?K:this._originalHeight,this._leftWidth=(J=Z.leftWidth)!=null?J:this._leftWidth,this._rightWidth=(Q=Z.rightWidth)!=null?Q:this._rightWidth,this._topHeight=(ee=Z.topHeight)!=null?ee:this._topHeight,this._bottomHeight=(te=Z.bottomHeight)!=null?te:this._bottomHeight,Z.textureMatrix&&this._textureMatrix.copyFrom(Z.textureMatrix);const re=this._textureMatrix,ne=this.uvs;ne[0]=ne[8]=ne[16]=ne[24]=0,ne[1]=ne[3]=ne[5]=ne[7]=0,ne[6]=ne[14]=ne[22]=ne[30]=1,ne[25]=ne[27]=ne[29]=ne[31]=1;const ie=1/this._originalWidth,se=1/this._originalHeight;ne[2]=ne[10]=ne[18]=ne[26]=ie*this._leftWidth,ne[9]=ne[11]=ne[13]=ne[15]=se*this._topHeight,ne[4]=ne[12]=ne[20]=ne[28]=1-ie*this._rightWidth,ne[17]=ne[19]=ne[21]=ne[23]=1-se*this._bottomHeight,M$2(re,ne),this.getBuffer("aUV").update()}};let NineSliceGeometry=u$4;NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};function M$2(Z,X,K){K!=null||(K=X);const J=Z.a,Q=Z.b,ee=Z.c,te=Z.d,re=Z.tx,ne=Z.ty;for(let ie=0;ie<X.length;ie+=2){const se=X[ie],oe=X[ie+1];K[ie]=se*J+oe*ee+re,K[ie+1]=se*Q+oe*te+ne}return K}var P=Object.defineProperty,u$3=Object.getOwnPropertySymbols,f$1=Object.prototype.hasOwnProperty,b$3=Object.prototype.propertyIsEnumerable,w$2=(Z,X,K)=>X in Z?P(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,H=(Z,X)=>{for(var K in X||(X={}))f$1.call(X,K)&&w$2(Z,K,X[K]);if(u$3)for(var K of u$3(X))b$3.call(X,K)&&w$2(Z,K,X[K]);return Z},W=(Z,X)=>{var K={};for(var J in Z)f$1.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&u$3)for(var J of u$3(Z))X.indexOf(J)<0&&b$3.call(Z,J)&&(K[J]=Z[J]);return K};const h$1=class extends Container{constructor(Z){var X,K,J,Q;Z instanceof Texture&&(Z={texture:Z});const ee=Z,{leftWidth:te,rightWidth:re,topHeight:ne,bottomHeight:ie,texture:se}=ee,oe=W(ee,["leftWidth","rightWidth","topHeight","bottomHeight","texture"]),ae=se!=null?se:h$1.defaultOptions.texture,le=ae.defaultBorders,ce=new NineSliceGeometry(definedProps({width:ae.width,height:ae.height,originalWidth:ae.width,originalHeight:ae.height,leftWidth:(X=te!=null?te:le==null?void 0:le.left)!=null?X:h$1.defaultOptions.leftWidth,topHeight:(K=ne!=null?ne:le==null?void 0:le.top)!=null?K:h$1.defaultOptions.topHeight,rightWidth:(J=re!=null?re:le==null?void 0:le.right)!=null?J:h$1.defaultOptions.rightWidth,bottomHeight:(Q=ie!=null?ie:le==null?void 0:le.bottom)!=null?Q:h$1.defaultOptions.bottomHeight,textureMatrix:ae.textureMatrix.mapCoord}));super(H({view:new MeshView(definedProps({geometry:ce,texture:ae})),label:"NineSliceSprite"},oe)),this.allowChildren=!1}get width(){return this.view.geometry.width}set width(Z){this.view.geometry.updatePositions({width:Z})}get height(){return this.view.geometry.height}set height(Z){this.view.geometry.updatePositions({height:Z})}get leftWidth(){return this.view.geometry._leftWidth}set leftWidth(Z){this.view.geometry.updateUvs({leftWidth:Z})}get topHeight(){return this.view.geometry._topHeight}set topHeight(Z){this.view.geometry.updateUvs({topHeight:Z})}get rightWidth(){return this.view.geometry._rightWidth}set rightWidth(Z){this.view.geometry.updateUvs({rightWidth:Z})}get bottomHeight(){return this.view.geometry._bottomHeight}set bottomHeight(Z){this.view.geometry.updateUvs({bottomHeight:Z})}get texture(){return this.view.texture}set texture(Z){Z!==this.view.texture&&(this.view.geometry.updateUvs({originalWidth:Z.width,originalHeight:Z.height,textureMatrix:Z.textureMatrix.mapCoord}),this.view.texture=Z)}get roundPixels(){return!!this.view.roundPixels}set roundPixels(Z){this.view.roundPixels=Z?1:0}};let NineSliceSprite=h$1;NineSliceSprite.defaultOptions={texture:Texture.EMPTY,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10};class NineSlicePlane extends NineSliceSprite{constructor(...X){let K=X[0];K instanceof Texture&&(deprecation(v8_0_0,"NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}"),K={texture:K,leftWidth:X[1],topHeight:X[2],rightWidth:X[3],bottomHeight:X[4]}),deprecation(v8_0_0,"NineSlicePlane is deprecated. Use NineSliceSprite instead."),super(K)}}var g$2=Object.defineProperty,l=Object.defineProperties,b$2=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,n$1=Object.prototype.hasOwnProperty,p$2=Object.prototype.propertyIsEnumerable,u$2=(Z,X,K)=>X in Z?g$2(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,d$3=(Z,X)=>{for(var K in X||(X={}))n$1.call(X,K)&&u$2(Z,K,X[K]);if(o)for(var K of o(X))p$2.call(X,K)&&u$2(Z,K,X[K]);return Z},m$3=(Z,X)=>l(Z,b$2(X)),x$3=(Z,X)=>{var K={};for(var J in Z)n$1.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&o)for(var J of o(Z))X.indexOf(J)<0&&p$2.call(Z,J)&&(K[J]=Z[J]);return K};class MeshPlane extends Mesh{constructor(X){const K=X,{texture:J,verticesX:Q,verticesY:ee}=K,te=x$3(K,["texture","verticesX","verticesY"]),re=new PlaneGeometry(definedProps({width:J.width,height:J.height,verticesX:Q,verticesY:ee}));super(definedProps(m$3(d$3({},te),{geometry:re,texture:J}))),this.texture=J,this.autoResize=!0}textureUpdated(){const X=this.geometry,{width:K,height:J}=this.texture;this.autoResize&&(X.width!==K||X.height!==J)&&(X.width=K,X.height=J,X.build({}))}set texture(X){this.view.texture=X,X.once("update",this.textureUpdated,this),this.textureUpdated()}get texture(){return this.view.texture}destroy(X){this.texture.off("update",this.textureUpdated,this),super.destroy(X)}}var S=Object.defineProperty,b$1=Object.getOwnPropertySymbols,_=Object.prototype.hasOwnProperty,O$1=Object.prototype.propertyIsEnumerable,w$1=(Z,X,K)=>X in Z?S(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,x$2=(Z,X)=>{for(var K in X||(X={}))_.call(X,K)&&w$1(Z,K,X[K]);if(b$1)for(var K of b$1(X))O$1.call(X,K)&&w$1(Z,K,X[K]);return Z};const y$1=class extends MeshGeometry{constructor(Z){const{width:X,points:K,textureScale:J}=x$2(x$2({},y$1.defaultOptions),Z);super({positions:new Float32Array(K.length*4),uvs:new Float32Array(K.length*4),indices:new Uint32Array((K.length-1)*6)}),this.points=K,this._width=X,this.textureScale=J,this._build()}get width(){return this._width}_build(){const Z=this.points;if(!Z)return;const X=this.getBuffer("aPosition"),K=this.getBuffer("aUV"),J=this.getIndex();if(Z.length<1)return;X.data.length/4!==Z.length&&(X.data=new Float32Array(Z.length*4),K.data=new Float32Array(Z.length*4),J.data=new Uint16Array((Z.length-1)*6));const Q=K.data,ee=J.data;Q[0]=0,Q[1]=0,Q[2]=0,Q[3]=1;let te=0,re=Z[0];const ne=this._width*this.textureScale,ie=Z.length;for(let oe=0;oe<ie;oe++){const ae=oe*4;if(this.textureScale>0){const le=re.x-Z[oe].x,ce=re.y-Z[oe].y,de=Math.sqrt(le*le+ce*ce);re=Z[oe],te+=de/ne}else te=oe/(ie-1);Q[ae]=te,Q[ae+1]=0,Q[ae+2]=te,Q[ae+3]=1}let se=0;for(let oe=0;oe<ie-1;oe++){const ae=oe*2;ee[se++]=ae,ee[se++]=ae+1,ee[se++]=ae+2,ee[se++]=ae+2,ee[se++]=ae+1,ee[se++]=ae+3}K.update(),J.update(),this.updateVertices()}updateVertices(){const Z=this.points;if(Z.length<1)return;let X=Z[0],K,J=0,Q=0;const ee=this.buffers[0].data,te=Z.length,re=this.textureScale>0?this.textureScale*this._width/2:this._width/2;for(let ne=0;ne<te;ne++){const ie=Z[ne],se=ne*4;ne<Z.length-1?K=Z[ne+1]:K=ie,Q=-(K.x-X.x),J=K.y-X.y;let oe=(1-ne/(te-1))*10;oe>1&&(oe=1);const ae=Math.sqrt(J*J+Q*Q);ae<1e-6?(J=0,Q=0):(J/=ae,Q/=ae,J*=re,Q*=re),ee[se]=ie.x+J,ee[se+1]=ie.y+Q,ee[se+2]=ie.x-J,ee[se+3]=ie.y-Q,X=ie}this.buffers[0].update()}update(){this.textureScale>0?this._build():this.updateVertices()}};let RopeGeometry=y$1;RopeGeometry.defaultOptions={width:200,points:[],textureScale:0};var g$1=Object.defineProperty,O=Object.defineProperties,M$1=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,d$2=Object.prototype.hasOwnProperty,u$1=Object.prototype.propertyIsEnumerable,h=(Z,X,K)=>X in Z?g$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$2=(Z,X)=>{for(var K in X||(X={}))d$2.call(X,K)&&h(Z,K,X[K]);if(i)for(var K of i(X))u$1.call(X,K)&&h(Z,K,X[K]);return Z},m$2=(Z,X)=>O(Z,M$1(X)),x$1=(Z,X)=>{var K={};for(var J in Z)d$2.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&i)for(var J of i(Z))X.indexOf(J)<0&&u$1.call(Z,J)&&(K[J]=Z[J]);return K};const p$1=class extends Mesh{constructor(Z){const X=s$2(s$2({},p$1.defaultOptions),Z),{texture:K,points:J,textureScale:Q}=X,ee=x$1(X,["texture","points","textureScale"]),te=new RopeGeometry(definedProps({width:K.height,points:J,textureScale:Q}));Q>0&&(K.source.style.addressMode="repeat"),super(definedProps(m$2(s$2({},ee),{texture:K,geometry:te}))),this.autoUpdate=!0,this.onRender=this._render}_render(){const Z=this.geometry;(this.autoUpdate||Z._width!==this.texture.height)&&(Z._width=this.texture.height,Z.update())}};let MeshRope=p$1;MeshRope.defaultOptions={textureScale:0};var v=Object.defineProperty,M=Object.defineProperties,T=Object.getOwnPropertyDescriptors,s$1=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,p=(Z,X,K)=>X in Z?v(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,d$1=(Z,X)=>{for(var K in X||(X={}))n.call(X,K)&&p(Z,K,X[K]);if(s$1)for(var K of s$1(X))a.call(X,K)&&p(Z,K,X[K]);return Z},m$1=(Z,X)=>M(Z,T(X)),y=(Z,X)=>{var K={};for(var J in Z)n.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&s$1)for(var J of s$1(Z))X.indexOf(J)<0&&a.call(Z,J)&&(K[J]=Z[J]);return K};class MeshSimple extends Mesh{constructor(X){const K=X,{texture:J,vertices:Q,uvs:ee,indices:te,topology:re}=K,ne=y(K,["texture","vertices","uvs","indices","topology"]),ie=new MeshGeometry(definedProps({positions:Q,uvs:ee,indices:te,topology:re}));super(definedProps(m$1(d$1({},ne),{texture:J,geometry:ie}))),this.autoUpdate=!0,this.onRender=this._render}get vertices(){return this.geometry.getBuffer("aPosition").data}set vertices(X){this.geometry.getBuffer("aPosition").data=X}_render(){this.autoUpdate&&this.geometry.getBuffer("aPosition").update()}}function getTextureDefaultMatrix(Z,X){const{width:K,height:J}=Z.frame;return X.scale(1/K,1/J),X}function generateUniformBufferSyncPolyfill(Z){return(X,K,J)=>{let Q=null,ee=0,te=0;for(let re=0;re<Z.length;re++){const ne=Z[re],ie=ne.data.name;let se=!1,oe=0;for(let ae=0;ae<uniformBufferParsers.length;ae++)if(uniformBufferParsers[ae].test(ne.data)){oe=ne.offset/4,J+=oe-te,uniformBufferParsers[ae].exec(ie,X,K,J,Q),se=!0;break}if(!se)if(ne.data.size>1){const ae=Math.max(WGSL_TO_STD40_SIZE[ne.data.type]/16,1),le=ne.data.value.length/ne.data.size,ce=(4-le%4)%4;oe=ne.offset/4,Q=X[ie],J+=oe-te;let de=J;ee=0;for(let he=0;he<ne.data.size*ae;he++){for(let pe=0;pe<le;pe++)K[de++]=Q[ee++];ce!==0&&(de+=ce)}}else{const ae=UBO_TO_SINGLE_SETTERS_FN[ne.data.type];oe=ne.offset/4,Q=X[ie],J+=oe-te,ae(K,J,Q)}te=oe}}}function generateUniformsSyncPolyfill(Z,X){return(K,J,Q,ee)=>{let te=null,re=null,ne=null;const ie=0,se=Q.gl;for(const oe in Z.uniforms){const ae=X[oe];if(!ae){Z.uniforms[oe]instanceof UniformGroup?Z.uniforms[oe].ubo?Q.shader.bindUniformBlock(J[oe],oe):Q.shader.updateUniformGroup(J[oe]):Z.uniforms[oe]instanceof BufferResource&&Q.shader.bindBufferResource(J[oe],oe);continue}const le=Z.uniforms[oe];let ce=!1;for(let de=0;de<uniformParsers.length;de++)if(uniformParsers[de].test(ae,le)){uniformParsers[de].exec(oe,re,K,J,te,ie,se,Q,ee),ce=!0;break}ce||(ne=K[oe],re=ne.value,te=J[oe],ae.size===1&&!ae.isArray?GLSL_TO_SINGLE_SETTERS_FN_CACHED[ae.type](ne,re,te,K[oe].location,se):GLSL_TO_ARRAY_SETTERS_FN[ae.type](te,K[oe].location,se),ne=K[oe],re=ne.value,te=J[oe])}}}function t(){Object.assign(GlUniformGroupSystem.prototype,{_systemCheck(){},_generateUniformsSync:generateUniformsSyncPolyfill}),Object.assign(UniformBufferSystem.prototype,{_systemCheck(){},_generateUniformBufferSync:generateUniformBufferSyncPolyfill})}t();const DATA_URI=/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;async function logDebugTexture(Z,X,K=200){const J=await X.extract.base64(Z);await X.encoder.commandFinished;const Q=K;console.log(`logging texture ${Z.source.width}px ${Z.source.height}px`);const ee=["font-size: 1px;",`padding: ${Q}px 300px;`,`background: url(${J}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",ee)}var u=Object.defineProperty,$=Object.defineProperties,g=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,x=Object.prototype.hasOwnProperty,m=Object.prototype.propertyIsEnumerable,f=(Z,X,K)=>X in Z?u(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,c=(Z,X)=>{for(var K in X||(X={}))x.call(X,K)&&f(Z,K,X[K]);if(s)for(var K of s(X))m.call(X,K)&&f(Z,K,X[K]);return Z},d=(Z,X)=>$(Z,g(X));const b=["#000080","#228B22","#8B0000","#4169E1","#008080","#800000","#9400D3","#FF8C00","#556B2F","#8B008B"];let w=0;function logScene(Z,X=0,K={color:"#000000"}){Z.isRenderGroupRoot&&(K.color=b[w++]);let J="";for(let te=0;te<X;te++)J+="    ";let Q=Z.label;!Q&&Z instanceof Sprite&&(Q=`sprite:${Z.view.texture.label}`);let ee=`%c ${J}|- ${Q} (worldX:${Z.worldTransform.tx}, renderX:${Z.rgTransform.tx}, localX:${Z.x})`;Z.isRenderGroupRoot&&(ee+=" (RenderGroup)"),Z.filters&&(ee+="(*filters)"),console.log(ee,`color:${K.color}; font-weight:bold;`),X++;for(let te=0;te<Z.children.length;te++){const re=Z.children[te];logScene(re,X,c({},K))}}function logRenderGroupScene(Z,X=0,K={index:0,color:"#000000"}){let J="";for(let ee=0;ee<X;ee++)J+="    ";const Q=`%c ${J}- ${K.index}: ${Z.root.label} worldX:${Z.worldTransform.tx}`;console.log(Q,`color:${K.color}; font-weight:bold;`),X++;for(let ee=0;ee<Z.renderGroupChildren.length;ee++){const te=Z.renderGroupChildren[ee];logRenderGroupScene(te,X,d(c({},K),{index:ee}))}}var hsl=`fn getLuminosity(c: vec3<f32>) -> f32 {
  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
}

fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {
  let d: f32 = lum - getLuminosity(c);
  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);

  // clip back into legal range
  let newLum: f32 = getLuminosity(newColor);
  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));
  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));

  let t1: f32 = newLum / (newLum - cMin);
  let t2: f32 = (1.0 - newLum) / (cMax - newLum);

  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));

  return finalColor;
}

fn getSaturation(c: vec3<f32>) -> f32 {
  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
}

// Set saturation if color components are sorted in ascending order.
fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {
  var result: vec3<f32>;
  if (cSorted.z > cSorted.x) {
    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));
    result = vec3<f32>(0.0, newY, s);
  } else {
    result = vec3<f32>(0.0, 0.0, 0.0);
  }
  return vec3<f32>(result.x, result.y, result.z);
}

fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {
    var result: vec3<f32> = c;

    if (c.r <= c.g && c.r <= c.b) {
        if (c.g <= c.b) {
            result = setSaturationMinMidMax(result, s);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.r, temp.b, temp.g);
        }
    } else if (c.g <= c.r && c.g <= c.b) {
        if (c.r <= c.b) {
            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.g, temp.r, temp.b);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.g, temp.b, temp.r);
        }
    } else {
        if (c.r <= c.g) {
            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.b, temp.r, temp.g);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.b, temp.g, temp.r);
        }
    }

    return result;
}`;return exports.AbstractBitmapFont=AbstractBitmapFont,exports.AbstractRenderer=AbstractRenderer,exports.AccessibilitySystem=AccessibilitySystem,exports.AlphaFilter=AlphaFilter,exports.AlphaMask=AlphaMask,exports.AlphaMaskPipe=AlphaMaskPipe,exports.AnimatedSprite=AnimatedSprite,exports.Application=Application,exports.Assets=Assets,exports.AssetsClass=AssetsClass,exports.BLEND_TO_NPM=BLEND_TO_NPM,exports.BUFFER_TYPE=BUFFER_TYPE,exports.BackgroundLoader=BackgroundLoader,exports.BackgroundSystem=BackgroundSystem,exports.Batch=Batch,exports.BatchGeometry=BatchGeometry,exports.BatchTextureArray=BatchTextureArray,exports.BatchableGraphics=BatchableGraphics,exports.BatchableMesh=BatchableMesh,exports.BatchableSprite=BatchableSprite,exports.Batcher=Batcher,exports.BatcherPipe=BatcherPipe,exports.BigPool=BigPool,exports.BindGroup=BindGroup,exports.BindGroupSystem=BindGroupSystem,exports.BitmapFont=BitmapFont,exports.BitmapFontManager=BitmapFontManager,exports.BitmapText=BitmapText,exports.BitmapTextPipe=BitmapTextPipe,exports.BlendModeFilter=BlendModeFilter,exports.BlendModePipe=BlendModePipe,exports.BlurFilter=BlurFilter,exports.BlurFilterPass=BlurFilterPass,exports.Bounds=Bounds,exports.BrowserAdapter=BrowserAdapter,exports.Buffer=Buffer,exports.BufferImageSource=BufferImageSource,exports.BufferResource=BufferResource,exports.BufferSystem=BufferSystem,exports.BufferUsage=BufferUsage,exports.CLEAR=CLEAR,exports.Cache=Cache,exports.CanvasPool=CanvasPool,exports.CanvasPoolClass=CanvasPoolClass,exports.CanvasSource=CanvasSource,exports.CanvasTextMetrics=CanvasTextMetrics,exports.CanvasTextPipe=CanvasTextPipe,exports.CanvasTextSystem=CanvasTextSystem,exports.Circle=Circle,exports.Color=Color,exports.ColorMask=ColorMask,exports.ColorMaskPipe=ColorMaskPipe,exports.ColorMatrixFilter=ColorMatrixFilter,exports.CompressedSource=CompressedSource,exports.Container=Container,exports.Culler=Culler,exports.CullerPlugin=CullerPlugin,exports.DATA_URI=DATA_URI,exports.DEG_TO_RAD=DEG_TO_RAD,exports.DEPRECATED_SCALE_MODES=DEPRECATED_SCALE_MODES,exports.DEPRECATED_WRAP_MODES=DEPRECATED_WRAP_MODES,exports.DOMAdapter=DOMAdapter,exports.DRAW_MODES=DRAW_MODES,exports.DisplacementFilter=DisplacementFilter,exports.DynamicBitmapFont=DynamicBitmapFont,exports.Ellipse=Ellipse,exports.EventBoundary=EventBoundary,exports.EventEmitter=eventemitter3,exports.EventSystem=EventSystem,exports.EventsTicker=EventsTicker,exports.ExtensionType=u$z,exports.ExtractSystem=ExtractSystem,exports.FederatedContainer=FederatedContainer,exports.FederatedEvent=FederatedEvent,exports.FederatedMouseEvent=FederatedMouseEvent,exports.FederatedPointerEvent=FederatedPointerEvent,exports.FederatedWheelEvent=FederatedWheelEvent,exports.FillGradient=FillGradient,exports.FillPattern=FillPattern,exports.Filter=Filter,exports.FilterEffect=FilterEffect,exports.FilterPipe=FilterPipe,exports.FilterSystem=FilterSystem,exports.FontStylePromiseCache=FontStylePromiseCache,exports.GAUSSIAN_VALUES=GAUSSIAN_VALUES,exports.GLSL_TO_ARRAY_SETTERS=GLSL_TO_ARRAY_SETTERS,exports.GLSL_TO_ARRAY_SETTERS_FN=GLSL_TO_ARRAY_SETTERS_FN,exports.GLSL_TO_SINGLE_SETTERS_CACHED=GLSL_TO_SINGLE_SETTERS_CACHED,exports.GLSL_TO_SINGLE_SETTERS_FN_CACHED=GLSL_TO_SINGLE_SETTERS_FN_CACHED,exports.GLSL_TO_STD40_SIZE=GLSL_TO_STD40_SIZE,exports.GL_FORMATS=GL_FORMATS,exports.GL_TARGETS=GL_TARGETS,exports.GL_TYPES=GL_TYPES,exports.GL_WRAP_MODES=GL_WRAP_MODES,exports.GenerateTextureSystem=GenerateTextureSystem,exports.Geometry=Geometry,exports.GlBackBufferSystem=GlBackBufferSystem,exports.GlBatchAdaptor=GlBatchAdaptor,exports.GlBuffer=GlBuffer,exports.GlBufferSystem=GlBufferSystem,exports.GlColorMaskSystem=GlColorMaskSystem,exports.GlContextSystem=GlContextSystem,exports.GlEncoderSystem=GlEncoderSystem,exports.GlGeometrySystem=GlGeometrySystem,exports.GlGraphicsAdaptor=GlGraphicsAdaptor,exports.GlMeshAdaptor=GlMeshAdaptor,exports.GlProgram=GlProgram,exports.GlProgramData=GlProgramData,exports.GlRenderTarget=GlRenderTarget,exports.GlRenderTargetAdaptor=GlRenderTargetAdaptor,exports.GlRenderTargetSystem=GlRenderTargetSystem,exports.GlShaderSystem=GlShaderSystem,exports.GlStateSystem=GlStateSystem,exports.GlStencilSystem=GlStencilSystem,exports.GlTexture=GlTexture,exports.GlTextureSystem=GlTextureSystem,exports.GlUniformGroupSystem=GlUniformGroupSystem,exports.GlobalUniformSystem=GlobalUniformSystem,exports.GpuBatchAdaptor=GpuBatchAdaptor,exports.GpuBlendModesToPixi=GpuBlendModesToPixi,exports.GpuColorMaskSystem=GpuColorMaskSystem,exports.GpuDeviceSystem=GpuDeviceSystem,exports.GpuEncoderSystem=GpuEncoderSystem,exports.GpuGraphicsAdaptor=GpuGraphicsAdaptor,exports.GpuGraphicsContext=GpuGraphicsContext,exports.GpuMeshAdapter=GpuMeshAdapter,exports.GpuMipmapGenerator=GpuMipmapGenerator,exports.GpuProgram=GpuProgram,exports.GpuReadBuffer=GpuReadBuffer,exports.GpuRenderTarget=GpuRenderTarget,exports.GpuRenderTargetAdaptor=GpuRenderTargetAdaptor,exports.GpuRenderTargetSystem=GpuRenderTargetSystem,exports.GpuShaderSystem=GpuShaderSystem,exports.GpuStateSystem=GpuStateSystem,exports.GpuStencilModesToPixi=GpuStencilModesToPixi,exports.GpuStencilSystem=GpuStencilSystem,exports.GpuTextureSystem=GpuTextureSystem,exports.GpuUniformBatchPipe=GpuUniformBatchPipe,exports.Graphics=Graphics,exports.GraphicsContext=GraphicsContext,exports.GraphicsContextRenderData=GraphicsContextRenderData,exports.GraphicsContextSystem=GraphicsContextSystem,exports.GraphicsPath=GraphicsPath,exports.GraphicsPipe=GraphicsPipe,exports.GraphicsView=GraphicsView,exports.HTMLText=HTMLText,exports.HTMLTextPipe=HTMLTextPipe,exports.HTMLTextRenderData=HTMLTextRenderData,exports.HTMLTextStyle=HTMLTextStyle,exports.HTMLTextSystem=HTMLTextSystem,exports.HelloSystem=HelloSystem,exports.IGLUniformData=IGLUniformData,exports.ImageSource=ImageSource,exports.InstructionSet=InstructionSet,exports.Loader=Loader,exports.LoaderParserPriority=LoaderParserPriority,exports.MAX_TEXTURES=MAX_TEXTURES,exports.MSAA_QUALITY=MSAA_QUALITY,exports.MaskEffectManager=MaskEffectManager,exports.MaskEffectManagerClass=MaskEffectManagerClass,exports.MaskFilter=MaskFilter,exports.Matrix=Matrix,exports.Mesh=Mesh,exports.MeshGeometry=MeshGeometry,exports.MeshPipe=MeshPipe,exports.MeshPlane=MeshPlane,exports.MeshRope=MeshRope,exports.MeshSimple=MeshSimple,exports.MeshView=MeshView,exports.NOOP=NOOP,exports.NineSliceGeometry=NineSliceGeometry,exports.NineSlicePlane=NineSlicePlane,exports.NineSliceSprite=NineSliceSprite,exports.NoiseFilter=NoiseFilter,exports.ObservablePoint=ObservablePoint,exports.PI_2=PI_2,exports.PipelineSystem=PipelineSystem,exports.PlaneGeometry=PlaneGeometry,exports.Point=Point,exports.Polygon=Polygon,exports.Pool=Pool,exports.PoolGroupClass=PoolGroupClass,exports.PrepareBase=PrepareBase,exports.PrepareQueue=PrepareQueue,exports.PrepareSystem=PrepareSystem,exports.ProxyRenderable=ProxyRenderable,exports.QuadGeometry=QuadGeometry,exports.RAD_TO_DEG=RAD_TO_DEG,exports.RGRenderable=RGRenderable,exports.Rectangle=Rectangle,exports.RenderGroup=RenderGroup,exports.RenderGroupPipe=RenderGroupPipe,exports.RenderGroupSystem=RenderGroupSystem,exports.RenderTarget=RenderTarget,exports.RenderTargetSystem=RenderTargetSystem,exports.RenderTexture=RenderTexture,exports.RendererType=RendererType,exports.ResizePlugin=ResizePlugin,exports.Resolver=Resolver,exports.RopeGeometry=RopeGeometry,exports.RoundedRectangle=RoundedRectangle,exports.SCALE_MODES=SCALE_MODES,exports.STENCIL_MODES=STENCIL_MODES,exports.SVGParser=SVGParser,exports.SVGToGraphicsPath=SVGToGraphicsPath,exports.ScissorMask=ScissorMask,exports.SdfShader=SdfShader,exports.Shader=Shader,exports.ShaderStage=ShaderStage,exports.ShapePath=ShapePath,exports.SharedRenderPipes=SharedRenderPipes,exports.SharedSystems=SharedSystems,exports.ShockwaveFilter=ShockwaveFilter,exports.Sprite=Sprite,exports.SpritePipe=SpritePipe,exports.SpriteView=SpriteView,exports.Spritesheet=Spritesheet,exports.State=State,exports.StencilMask=StencilMask,exports.StencilMaskPipe=StencilMaskPipe,exports.SystemRunner=SystemRunner,exports.Text=Text,exports.TextStyle=TextStyle,exports.TextView=TextView,exports.Texture=Texture,exports.TextureGCSystem=TextureGCSystem,exports.TextureMatrix=TextureMatrix,exports.TexturePool=TexturePool,exports.TexturePoolClass=TexturePoolClass,exports.TextureSource=TextureSource,exports.TextureStyle=TextureStyle,exports.TextureUvs=TextureUvs,exports.Ticker=Ticker,exports.TickerListener=TickerListener,exports.TickerPlugin=TickerPlugin,exports.TilingSprite=TilingSprite,exports.TilingSpritePipe=TilingSpritePipe,exports.TilingSpriteShader=TilingSpriteShader,exports.TilingSpriteView=TilingSpriteView,exports.Transform=Transform,exports.Triangle=Triangle,exports.UBO_TO_SINGLE_SETTERS=UBO_TO_SINGLE_SETTERS,exports.UBO_TO_SINGLE_SETTERS_FN=UBO_TO_SINGLE_SETTERS_FN,exports.UPDATE_BLEND=UPDATE_BLEND,exports.UPDATE_COLOR=UPDATE_COLOR,exports.UPDATE_PRIORITY=UPDATE_PRIORITY,exports.UPDATE_TRANSFORM=UPDATE_TRANSFORM,exports.UPDATE_VISIBLE=UPDATE_VISIBLE,exports.UniformBufferBatch=UniformBufferBatch,exports.UniformBufferSystem=UniformBufferSystem,exports.UniformGroup=UniformGroup,exports.VERSION=VERSION,exports.VideoSource=VideoSource,exports.ViewSystem=ViewSystem,exports.ViewableBuffer=ViewableBuffer,exports.WGSL_TO_STD40_SIZE=WGSL_TO_STD40_SIZE,exports.WRAP_MODES=WRAP_MODES,exports.WebGLRenderer=WebGLRenderer,exports.WebGPURenderer=WebGPURenderer,exports.WebWorkerAdapter=WebWorkerAdapter,exports.WorkerManager=d$n,exports._getGlobalBounds=_getGlobalBounds,exports.accessibilityTarget=accessibilityTarget,exports.addBits=addBits,exports.addMaskBounds=addMaskBounds,exports.addMaskLocalBounds=addMaskLocalBounds,exports.alphaFrag=y$7,exports.alphaWgsl=s$j,exports.applyStyleParams=applyStyleParams,exports.assignWithIgnore=assignWithIgnore,exports.autoDetectEnvironment=autoDetectEnvironment,exports.autoDetectRenderer=autoDetectRenderer,exports.autoDetectSource=autoDetectSource,exports.basisTranscoderUrls=basisTranscoderUrls,exports.batchSamplersUniformGroup=batchSamplersUniformGroup,exports.bitmapFontCachePlugin=bitmapFontCachePlugin,exports.bitmapFontTextParser=bitmapFontTextParser,exports.bitmapFontXMLParser=bitmapFontXMLParser,exports.bitmapFontXMLStringParser=bitmapFontXMLStringParser,exports.blendTemplateFrag=M$4,exports.blendTemplateVert=B$1,exports.blendTemplateWgsl=O$5,exports.blockDataMap=blockDataMap,exports.blurTemplateWgsl=b$a,exports.browserExt=browserExt,exports.buildAdaptiveBezier=buildAdaptiveBezier,exports.buildAdaptiveQuadratic=buildAdaptiveQuadratic,exports.buildArc=buildArc,exports.buildArcTo=buildArcTo,exports.buildArcToSvg=buildArcToSvg,exports.buildCircle=buildCircle,exports.buildContextBatches=buildContextBatches,exports.buildGeometryFromPath=buildGeometryFromPath,exports.buildInstructions=buildInstructions,exports.buildLine=buildLine,exports.buildPolygon=buildPolygon,exports.buildRectangle=buildRectangle,exports.buildSimpleUvs=buildSimpleUvs,exports.buildTriangle=buildTriangle,exports.buildUvs=buildUvs,exports.cacheTextureArray=cacheTextureArray,exports.calculateProjection=calculateProjection,exports.checkDataUrl=checkDataUrl,exports.checkExtension=checkExtension,exports.childrenHelperMixin=childrenHelperMixin,exports.closePointEps=closePointEps,exports.collectAllRenderables=collectAllRenderables,exports.collectRenderGroups=collectRenderGroups,exports.color32BitToUniform=color32BitToUniform,exports.colorBit=colorBit,exports.colorBitGl=colorBitGl,exports.colorMatrixFilterFrag=F,exports.colorMatrixFilterWgsl=d$a,exports.colorToUniform=colorToUniform,exports.compareModeToGlCompare=compareModeToGlCompare,exports.compileHighShader=compileHighShader,exports.compileHighShaderGl=compileHighShaderGl,exports.compileHighShaderGlProgram=compileHighShaderGlProgram,exports.compileHighShaderGpuProgram=compileHighShaderGpuProgram,exports.compileHooks=compileHooks,exports.compileInputs=compileInputs,exports.compileOutputs=compileOutputs,exports.compileShader=compileShader,exports.convertFillInputToFillStyle=convertFillInputToFillStyle,exports.convertToList=convertToList,exports.copySearchParams=copySearchParams,exports.createIdFromString=createIdFromString,exports.createLevelBuffers=createLevelBuffers,exports.createLevelBuffersFromKTX=createLevelBuffersFromKTX,exports.createStringVariations=createStringVariations,exports.createTexture=createTexture,exports.createUBOElements=createUBOElements,exports.crossOrigin=crossOrigin,exports.cullingMixin=cullingMixin,exports.curveEps=curveEps,exports.defaultFilterVert=P$4,exports.defaultUniformValue=defaultUniformValue,exports.defaultValue=defaultValue,exports.definedProps=definedProps,exports.deprecation=deprecation,exports.detectAvif=detectAvif,exports.detectBasis=detectBasis,exports.detectDefaults=detectDefaults,exports.detectMp4=detectMp4,exports.detectOgv=detectOgv,exports.detectRenderType=detectRenderType,exports.detectVideoAlphaMode=detectVideoAlphaMode,exports.detectWebm=detectWebm,exports.detectWebp=detectWebp,exports.determineCrossOrigin=determineCrossOrigin,exports.displacementFrag=h$f,exports.displacementVert=S$2,exports.displacementWgsl=p$f,exports.earcut=earcut_1,exports.effectsMixin=effectsMixin,exports.emptyViewObserver=emptyViewObserver,exports.ensureIsBuffer=ensureIsBuffer,exports.ensurePrecision=ensurePrecision,exports.ensureTextStyle=ensureTextStyle,exports.executeInstructions=executeInstructions,exports.extensions=b$r,exports.extractFontFamilies=extractFontFamilies,exports.extractStructAndGroups=extractStructAndGroups,exports.fastCopy=fastCopy,exports.findHooksRx=findHooksRx,exports.findMixin=findMixin,exports.floatEqual=floatEqual,exports.fontStringFromTextStyle=fontStringFromTextStyle,exports.formatShader=formatShader,exports.fragmentGPUTemplate=r$4,exports.fragmentGlTemplate=i$e,exports.generateBlurFragSource=generateBlurFragSource,exports.generateBlurGlProgram=generateBlurGlProgram,exports.generateBlurProgram=generateBlurProgram,exports.generateBlurVertSource=generateBlurVertSource,exports.generateGPULayout=generateGPULayout,exports.generateGpuLayoutGroups=generateGpuLayoutGroups,exports.generateLayout=generateLayout,exports.generateLayoutHash=generateLayoutHash,exports.generateProgram=generateProgram,exports.generateTextStyleKey=generateTextStyleKey,exports.generateTextureBatchBit=generateTextureBatchBit,exports.generateTextureBatchBitGl=generateTextureBatchBitGl,exports.generateUID=generateUID,exports.generateUniformBufferSync=generateUniformBufferSync,exports.generateUniformBufferSyncPolyfill=generateUniformBufferSyncPolyfill,exports.generateUniformsSync=generateUniformsSync,exports.generateUniformsSyncPolyfill=generateUniformsSyncPolyfill,exports.getAttributeData=getAttributeData,exports.getBitmapTextLayout=getBitmapTextLayout,exports.getCanvasBoundingBox=getCanvasBoundingBox,exports.getCanvasFillStyle=getCanvasFillStyle,exports.getCanvasTexture=getCanvasTexture,exports.getFilterEffect=getFilterEffect,exports.getFontCss=getFontCss,exports.getFontFamilyName=getFontFamilyName,exports.getGlInfoFromFormat=getGlInfoFromFormat,exports.getGlobalBounds=getGlobalBounds,exports.getGlobalRenderableBounds=getGlobalRenderableBounds,exports.getLocalBounds=getLocalBounds,exports.getMatrixRelativeToParent=getMatrixRelativeToParent,exports.getMaxFragmentPrecision=getMaxFragmentPrecision,exports.getOrientationOfPoints=getOrientationOfPoints,exports.getParent=getParent,exports.getPo2TextureFromSource=getPo2TextureFromSource,exports.getResolutionOfUrl=getResolutionOfUrl,exports.getSVGUrl=getSVGUrl,exports.getSupportedCompressedTextureFormats=getSupportedCompressedTextureFormats,exports.getSupportedGPUCompressedTextureFormats=getSupportedGPUCompressedTextureFormats,exports.getSupportedGlCompressedTextureFormats=getSupportedGlCompressedTextureFormats,exports.getSupportedTextureFormats=getSupportedTextureFormats,exports.getTemporaryCanvasFromImage=getTemporaryCanvasFromImage,exports.getTestContext=getTestContext,exports.getTextureBatchBindGroup=getTextureBatchBindGroup,exports.getTextureDefaultMatrix=getTextureDefaultMatrix,exports.getTextureFormatFromKTXTexture=getTextureFormatFromKTXTexture,exports.getUniformBufferData=getUniformBufferData,exports.getUniformData=getUniformData,exports.getUrlExtension=getUrlExtension,exports.glFormatToGPUFormat=glFormatToGPUFormat,exports.glUploadBufferImageResource=glUploadBufferImageResource,exports.glUploadCompressedTextureResource=glUploadCompressedTextureResource,exports.glUploadImageResource=glUploadImageResource,exports.glUploadVideoResource=glUploadVideoResource,exports.globalUniformsBit=globalUniformsBit,exports.globalUniformsBitGl=globalUniformsBitGl,exports.gpuFormatToBasisTranscoderFormat=gpuFormatToBasisTranscoderFormat,exports.gpuFormatToKTXBasisTranscoderFormat=gpuFormatToKTXBasisTranscoderFormat,exports.gpuUploadBufferImageResource=gpuUploadBufferImageResource,exports.gpuUploadCompressedTextureResource=gpuUploadCompressedTextureResource,exports.gpuUploadImageResource=gpuUploadImageResource,exports.gpuUploadVideoResource=gpuUploadVideoResource,exports.groupD8=groupD8,exports.hasCachedCanvasTexture=hasCachedCanvasTexture,exports.hslWgsl=hsl,exports.hslgl=hslgl,exports.hslgpu=hslgpu,exports.injectBits=injectBits,exports.isMobile=isMobile,exports.isPow2=isPow2,exports.isRenderingToScreen=isRenderingToScreen,exports.isSafari=isSafari,exports.isSingleItem=isSingleItem,exports.ktxTranscoderUrls=ktxTranscoderUrls,exports.lineIntersection=lineIntersection,exports.loadBasis=loadBasis,exports.loadBasisOnWorker=loadBasisOnWorker,exports.loadBitmapFont=loadBitmapFont,exports.loadDDS=loadDDS,exports.loadFontAsBase64=loadFontAsBase64,exports.loadFontCSS=loadFontCSS,exports.loadImageBitmap=loadImageBitmap,exports.loadJson=loadJson,exports.loadKTX=loadKTX,exports.loadKTX2onWorker=loadKTX2onWorker,exports.loadSVGImage=loadSVGImage,exports.loadSvg=loadSvg,exports.loadTextures=loadTextures,exports.loadTxt=loadTxt,exports.loadVideoTextures=loadVideoTextures,exports.loadWebFont=loadWebFont,exports.localUniformBit=localUniformBit,exports.localUniformBitGl=localUniformBitGl,exports.localUniformBitGroup2=localUniformBitGroup2,exports.localUniformMSDFBit=localUniformMSDFBit,exports.localUniformMSDFBitGl=localUniformMSDFBitGl,exports.log2=log2,exports.logDebugTexture=logDebugTexture,exports.logProgramError=logProgramError,exports.logRenderGroupScene=logRenderGroupScene,exports.logScene=logScene,exports.mSDFBit=mSDFBit,exports.mSDFBitGl=mSDFBitGl,exports.mapFormatToGlFormat=mapFormatToGlFormat,exports.mapFormatToGlInternalFormat=mapFormatToGlInternalFormat,exports.mapFormatToGlType=mapFormatToGlType,exports.mapSize=mapSize,exports.mapType=mapType,exports.mapWebGLBlendModesToPixi=mapWebGLBlendModesToPixi,exports.maskFrag=l$b,exports.maskVert=f$b,exports.maskWgsl=o$6,exports.measureHtmlText=measureHtmlText,exports.measureMixin=measureMixin,exports.migrateFragmentFromV7toV8=migrateFragmentFromV7toV8,exports.mipmapScaleModeToGlFilter=mipmapScaleModeToGlFilter,exports.mixColors=mixColors,exports.mixHexColors=mixHexColors,exports.mixStandardAnd32BitColors=mixStandardAnd32BitColors,exports.mixins=mixins,exports.multiplyHexColors=multiplyHexColors,exports.nextPow2=nextPow2,exports.noiseFrag=U,exports.noiseWgsl=f$d,exports.nonCompressedFormats=nonCompressedFormats,exports.normalizeExtensionPriority=normalizeExtensionPriority,exports.onRenderMixin=onRenderMixin,exports.parseDDS=parseDDS,exports.parseFunctionBody=parseFunctionBody,exports.path=path,exports.preloadVideo=preloadVideo,exports.removeItems=removeItems,exports.removeStructAndGroupDuplicates=removeStructAndGroupDuplicates,exports.resolveCharacters=resolveCharacters,exports.resolveCompressedTextureUrl=resolveCompressedTextureUrl,exports.resolveTextureUrl=resolveTextureUrl,exports.resourceToTexture=resourceToTexture,exports.returnFilterEffect=returnFilterEffect,exports.roundPixelsBit=roundPixelsBit,exports.roundPixelsBitGl=roundPixelsBitGl,exports.roundedShapeArc=roundedShapeArc,exports.roundedShapeQuadraticCurve=roundedShapeQuadraticCurve,exports.sayHello=sayHello,exports.scaleModeToGlFilter=scaleModeToGlFilter,exports.segmentIntersection=segmentIntersection,exports.setBasisTranscoderPath=setBasisTranscoderPath,exports.setKTXTranscoderPath=setKTXTranscoderPath,exports.setProgramName=setProgramName,exports.setProgramVersion=setProgramVersion,exports.shockwaveFrag=P$3,exports.shockwaveVert=w$4,exports.shockwaveWgsl=f$c,exports.sortMixin=sortMixin,exports.spritesheetAsset=spritesheetAsset,exports.squaredDistanceToLineSegment=squaredDistanceToLineSegment,exports.testImageFormat=testImageFormat,exports.testVideoFormat=testVideoFormat,exports.textStyleToCSS=textStyleToCSS,exports.textureBit=textureBit,exports.textureBitGl=textureBitGl,exports.tilingBit=tilingBit,exports.tilingBitGl=tilingBitGl,exports.toLocalGlobalMixin=toLocalGlobalMixin,exports.transformVertices=transformVertices,exports.triangulateWithHoles=triangulateWithHoles,exports.uniformBufferParsers=uniformBufferParsers,exports.uniformParsers=uniformParsers,exports.unpremultiplyAlpha=unpremultiplyAlpha,exports.updateLocalTransform=updateLocalTransform,exports.updateQuadBounds=updateQuadBounds,exports.updateRenderGroupTransform=updateRenderGroupTransform,exports.updateRenderGroupTransforms=updateRenderGroupTransforms,exports.updateTransformAndChildren=updateTransformAndChildren,exports.updateTransformBackwards=updateTransformBackwards,exports.updateWorldTransform=updateWorldTransform,exports.v8_0_0=v8_0_0,exports.validFormats=validFormats,exports.validateRenderables=validateRenderables,exports.vertexGPUTemplate=o$f,exports.vertexGlTemplate=t$7,exports.viewportFromFrame=viewportFromFrame,exports.vkFormatToGPUFormat=vkFormatToGPUFormat,exports.warn=warn,exports.webworkerExt=webworkerExt,exports.wrapModeToGlAddress=wrapModeToGlAddress,Object.defineProperty(exports,"__esModule",{value:!0}),exports}({});
//# sourceMappingURL=pixi.min.js.map
